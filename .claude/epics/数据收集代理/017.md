---
name: 用户验收测试和文档完善
type: task
epic: 数据收集代理
status: open
priority: 1
created: 2025-09-25T20:20:35Z
estimated: 12 days
assigned: [待分配]
parallelizable: true
dependencies: ["013", "014", "015", "016"]
---

# 任务: 用户验收测试和文档完善

## 任务描述
进行用户验收测试(UAT)和完善所有相关文档，包括用户手册、API文档、部署文档和培训材料。通过真实的用户场景验证系统功能完整性，确保系统满足用户需求和业务目标，并提供全面的技术文档和用户指导。

## 技术要求

### 核心架构设计

#### UAT Framework 组件
- **测试场景**: 基于真实业务场景的验收测试
- **用户角色**: 多角色用户验收测试覆盖
- **功能验证**: 核心功能完整性和正确性验证
- **性能验收**: 用户视角的性能和可用性测试
- **文档体系**: 完整的技术文档和用户文档

#### 技术栈
- **测试工具**: Selenium + Cypress + Postman
- **文档工具**: Sphinx + MkDocs + Swagger
- **协作平台**: Confluence + GitHub Pages
- **版本控制**: Git + GitHub
- **自动化**: Jenkins + GitHub Actions

### 实现架构

```python
# src/tests/uat_framework.py
import asyncio
import time
import json
import logging
from typing import Dict, List, Optional, Any, Union, Callable, AsyncGenerator
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
from pathlib import Path
import yaml
import pandas as pd
import requests
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import pytest
from pytest_bdd import scenarios, given, when, then, parsers
import aiohttp
import async_timeout

from ..core.config import config
from ..core.logger import get_logger
from ..core.exceptions import UATError, DocumentationError
from ..managers.exchange_manager import exchange_manager
from ..managers.position_manager import position_manager
from ..managers.order_manager import order_manager
from ..processors.data_processor import data_processor
from ..services.export_service import ExportService
from ..services.monitoring_service import MonitoringService
from ..api.main import app

# 初始化日志
logger = get_logger("uat_framework")

# 用户角色枚举
class UserRole(Enum):
    """用户角色枚举"""
    TRADER = "trader"
    ANALYST = "analyst"
    ADMIN = "admin"
    VIEWER = "viewer"
    DEPLOYER = "deployer"

# 测试场景枚举
class TestScenario(Enum):
    """测试场景枚举"""
    DATA_COLLECTION = "data_collection"
    MONITORING = "monitoring"
    REPORTING = "reporting"
    CONFIGURATION = "configuration"
    DEPLOYMENT = "deployment"
    INTEGRATION = "integration"

# UAT状态枚举
class UATStatus(Enum):
    """UAT状态枚举"""
    PLANNED = "planned"
    IN_PROGRESS = "in_progress"
    PASSED = "passed"
    FAILED = "failed"
    BLOCKED = "blocked"
    RETEST = "retest"

@dataclass
class UserStory:
    """用户故事数据类"""
    story_id: str
    title: str
    description: str
    role: UserRole
    scenario: TestScenario
    acceptance_criteria: List[str]
    priority: int
    estimated_time: int  # 分钟
    status: UATStatus = UATStatus.PLANNED
    test_cases: List['TestCase'] = field(default_factory=list)
    actual_time: Optional[int] = None
    tester: Optional[str] = None
    test_results: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

@dataclass
class TestCase:
    """测试用例数据类"""
    case_id: str
    title: str
    description: str
    steps: List[str]
    expected_results: List[str]
    priority: int
    automated: bool = False
    status: UATStatus = UATStatus.PLANNED
    execution_time: Optional[int] = None
    actual_results: List[str] = field(default_factory=list)
    evidence: List[str] = field(default_factory=list)  # 截图、日志等
    tester: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class UATSession:
    """UAT会话数据类"""
    session_id: str
    name: str
    description: str
    start_time: datetime
    end_time: Optional[datetime] = None
    tester: str
    environment: str
    stories_tested: List[str] = field(default_factory=list)
    overall_status: UATStatus = UATStatus.IN_PROGRESS
    findings: List[Dict[str, Any]] = field(default_factory=list)
    summary: str = ""

class WebUIAutomation:
    """Web UI自动化测试"""

    def __init__(self):
        self.driver = None
        self.wait_timeout = 30
        self.screenshot_dir = Path("uat_screenshots")
        self.screenshot_dir.mkdir(exist_ok=True)

    def setup_driver(self, headless: bool = True):
        """设置浏览器驱动"""
        try:
            options = Options()
            if headless:
                options.add_argument("--headless")
            options.add_argument("--no-sandbox")
            options.add_argument("--disable-dev-shm-usage")
            options.add_argument("--window-size=1920,1080")

            self.driver = webdriver.Chrome(options=options)
            self.driver.implicitly_wait(10)

            logger.info("浏览器驱动设置完成")
            return True

        except Exception as e:
            logger.error(f"设置浏览器驱动失败: {e}")
            return False

    def navigate_to_url(self, url: str):
        """导航到URL"""
        try:
            self.driver.get(url)
            self.take_screenshot("navigate_to_url")
            logger.info(f"导航到: {url}")
            return True

        except Exception as e:
            logger.error(f"导航失败: {e}")
            return False

    def login(self, username: str, password: str) -> bool:
        """用户登录"""
        try:
            # 等待登录页面加载
            wait = WebDriverWait(self.driver, self.wait_timeout)
            username_field = wait.until(
                EC.presence_of_element_located((By.ID, "username"))
            )
            password_field = self.driver.find_element(By.ID, "password")
            login_button = self.driver.find_element(By.ID, "login-button")

            # 输入凭据
            username_field.clear()
            username_field.send_keys(username)
            password_field.clear()
            password_field.send_keys(password)

            # 点击登录
            login_button.click()

            # 等待登录完成
            wait.until(
                EC.url_contains("/dashboard")
            )

            self.take_screenshot("login_success")
            logger.info(f"用户登录成功: {username}")
            return True

        except Exception as e:
            logger.error(f"登录失败: {e}")
            self.take_screenshot("login_failed")
            return False

    def verify_dashboard_loaded(self) -> bool:
        """验证仪表板加载"""
        try:
            wait = WebDriverWait(self.driver, self.wait_timeout)

            # 检查关键元素
            dashboard_title = wait.until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "h1.dashboard-title"))
            )
            market_data_section = self.driver.find_element(By.ID, "market-data-section")
            monitoring_section = self.driver.find_element(By.ID, "monitoring-section")

            self.take_screenshot("dashboard_loaded")
            logger.info("仪表板加载验证成功")
            return True

        except Exception as e:
            logger.error(f"仪表板加载验证失败: {e}")
            self.take_screenshot("dashboard_load_failed")
            return False

    def navigate_to_data_collection(self) -> bool:
        """导航到数据收集页面"""
        try:
            wait = WebDriverWait(self.driver, self.wait_timeout)

            # 点击数据收集链接
            data_collection_link = wait.until(
                EC.element_to_be_clickable((By.LINK_TEXT, "数据收集"))
            )
            data_collection_link.click()

            # 等待页面加载
            wait.until(
                EC.presence_of_element_located((By.ID, "data-collection-container"))
            )

            self.take_screenshot("data_collection_page")
            logger.info("成功导航到数据收集页面")
            return True

        except Exception as e:
            logger.error(f"导航到数据收集页面失败: {e}")
            self.take_screenshot("data_collection_navigation_failed")
            return False

    def verify_real_time_data(self) -> bool:
        """验证实时数据显示"""
        try:
            wait = WebDriverWait(self.driver, self.wait_timeout)

            # 检查实时数据元素
            ticker_section = wait.until(
                EC.presence_of_element_located((By.ID, "real-time-tickers"))
            )

            # 等待数据加载
            time.sleep(2)  # 等待数据更新

            # 检查数据是否显示
            ticker_data = self.driver.find_elements(By.CLASS_NAME, "ticker-item")
            if len(ticker_data) > 0:
                self.take_screenshot("real_time_data_success")
                logger.info(f"实时数据验证成功，显示 {len(ticker_data)} 个交易对")
                return True
            else:
                logger.warning("未找到实时数据")
                return False

        except Exception as e:
            logger.error(f"实时数据验证失败: {e}")
            self.take_screenshot("real_time_data_failed")
            return False

    def test_data_export(self) -> bool:
        """测试数据导出功能"""
        try:
            wait = WebDriverWait(self.driver, self.wait_timeout)

            # 点击导出按钮
            export_button = wait.until(
                EC.element_to_be_clickable((By.ID, "export-data-button"))
            )
            export_button.click()

            # 选择导出格式
            format_select = wait.until(
                EC.presence_of_element_located((By.ID, "export-format"))
            )
            format_select.click()

            csv_option = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//select[@id='export-format']/option[@value='csv']"))
            )
            csv_option.click()

            # 点击确认导出
            confirm_button = wait.until(
                EC.element_to_be_clickable((By.ID, "confirm-export"))
            )
            confirm_button.click()

            # 等待导出完成
            success_message = wait.until(
                EC.presence_of_element_located((By.CLASS_NAME, "export-success"))
            )

            self.take_screenshot("data_export_success")
            logger.info("数据导出功能测试成功")
            return True

        except Exception as e:
            logger.error(f"数据导出功能测试失败: {e}")
            self.take_screenshot("data_export_failed")
            return False

    def test_monitoring_alerts(self) -> bool:
        """测试监控告警功能"""
        try:
            wait = WebDriverWait(self.driver, self.wait_timeout)

            # 导航到监控页面
            monitoring_link = wait.until(
                EC.element_to_be_clickable((By.LINK_TEXT, "监控告警"))
            )
            monitoring_link.click()

            # 等待页面加载
            wait.until(
                EC.presence_of_element_located((By.ID, "alerts-container"))
            )

            # 检查告警列表
            alerts_list = self.driver.find_elements(By.CLASS_NAME, "alert-item")
            logger.info(f"找到 {len(alerts_list)} 个告警")

            # 测试告警配置
            config_button = wait.until(
                EC.element_to_be_clickable((By.ID, "configure-alerts"))
            )
            config_button.click()

            # 等待配置页面
            wait.until(
                EC.presence_of_element_located((By.ID, "alert-config-form"))
            )

            self.take_screenshot("monitoring_alerts_success")
            logger.info("监控告警功能测试成功")
            return True

        except Exception as e:
            logger.error(f"监控告警功能测试失败: {e}")
            self.take_screenshot("monitoring_alerts_failed")
            return False

    def test_system_configuration(self) -> bool:
        """测试系统配置功能"""
        try:
            wait = WebDriverWait(self.driver, self.wait_timeout)

            # 导航到配置页面
            config_link = wait.until(
                EC.element_to_be_clickable((By.LINK_TEXT, "系统配置"))
            )
            config_link.click()

            # 等待配置页面加载
            wait.until(
                EC.presence_of_element_located((By.ID, "system-config-form"))
            )

            # 测试配置修改
            exchange_config = wait.until(
                EC.presence_of_element_located((By.ID, "exchange-config"))
            )
            exchange_config.click()

            # 修改配置
            api_key_field = wait.until(
                EC.presence_of_element_located((By.NAME, "api_key"))
            )
            api_key_field.clear()
            api_key_field.send_keys("test_api_key")

            # 保存配置
            save_button = wait.until(
                EC.element_to_be_clickable((By.ID, "save-config"))
            )
            save_button.click()

            # 等待保存确认
            success_message = wait.until(
                EC.presence_of_element_located((By.CLASS_NAME, "config-saved"))
            )

            self.take_screenshot("system_config_success")
            logger.info("系统配置功能测试成功")
            return True

        except Exception as e:
            logger.error(f"系统配置功能测试失败: {e}")
            self.take_screenshot("system_config_failed")
            return False

    def take_screenshot(self, name: str):
        """截图"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{name}_{timestamp}.png"
            filepath = self.screenshot_dir / filename

            if self.driver:
                self.driver.save_screenshot(str(filepath))
                logger.debug(f"截图保存: {filename}")
            return str(filepath)

        except Exception as e:
            logger.error(f"截图失败: {e}")
            return None

    def close(self):
        """关闭浏览器"""
        if self.driver:
            self.driver.quit()
            logger.info("浏览器已关闭")

class APIAutomation:
    """API自动化测试"""

    def __init__(self):
        self.base_url = config.get("api_base_url", "http://localhost:8000")
        self.auth_token = None
        self.session = requests.Session()
        self.test_results = []

    def authenticate(self, username: str, password: str) -> bool:
        """API认证"""
        try:
            auth_data = {
                "username": username,
                "password": password
            }

            response = self.session.post(
                f"{self.base_url}/auth/token",
                json=auth_data
            )

            if response.status_code == 200:
                auth_result = response.json()
                self.auth_token = auth_result.get("access_token")
                self.session.headers.update({
                    "Authorization": f"Bearer {self.auth_token}"
                })
                logger.info("API认证成功")
                return True
            else:
                logger.error(f"API认证失败: {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"API认证异常: {e}")
            return False

    def test_market_data_api(self) -> bool:
        """测试市场数据API"""
        try:
            # 测试获取行情数据
            response = self.session.get(
                f"{self.base_url}/api/v1/markets/tickers",
                params={"exchange": "binance", "symbol": "BTC/USDT"}
            )

            if response.status_code == 200:
                data = response.json()
                if isinstance(data, list) and len(data) > 0:
                    logger.info("市场数据API测试成功")
                    self.test_results.append({
                        "test": "market_data_api",
                        "status": "passed",
                        "response_time": response.elapsed.total_seconds()
                    })
                    return True
                else:
                    logger.error("市场数据API返回数据格式错误")
                    return False
            else:
                logger.error(f"市场数据API请求失败: {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"市场数据API测试异常: {e}")
            return False

    def test_position_api(self) -> bool:
        """测试仓位API"""
        try:
            response = self.session.get(
                f"{self.base_url}/api/v1/positions"
            )

            if response.status_code == 200:
                data = response.json()
                if isinstance(data, list):
                    logger.info("仓位API测试成功")
                    self.test_results.append({
                        "test": "position_api",
                        "status": "passed",
                        "response_time": response.elapsed.total_seconds()
                    })
                    return True
                else:
                    logger.error("仓位API返回数据格式错误")
                    return False
            else:
                logger.error(f"仓位API请求失败: {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"仓位API测试异常: {e}")
            return False

    def test_order_api(self) -> bool:
        """测试订单API"""
        try:
            response = self.session.get(
                f"{self.base_url}/api/v1/orders"
            )

            if response.status_code == 200:
                data = response.json()
                if isinstance(data, list):
                    logger.info("订单API测试成功")
                    self.test_results.append({
                        "test": "order_api",
                        "status": "passed",
                        "response_time": response.elapsed.total_seconds()
                    })
                    return True
                else:
                    logger.error("订单API返回数据格式错误")
                    return False
            else:
                logger.error(f"订单API请求失败: {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"订单API测试异常: {e}")
            return False

    def test_system_status_api(self) -> bool:
        """测试系统状态API"""
        try:
            response = self.session.get(
                f"{self.base_url}/api/v1/system/status"
            )

            if response.status_code == 200:
                data = response.json()
                if isinstance(data, dict) and "status" in data:
                    logger.info("系统状态API测试成功")
                    self.test_results.append({
                        "test": "system_status_api",
                        "status": "passed",
                        "response_time": response.elapsed.total_seconds()
                    })
                    return True
                else:
                    logger.error("系统状态API返回数据格式错误")
                    return False
            else:
                logger.error(f"系统状态API请求失败: {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"系统状态API测试异常: {e}")
            return False

    def get_test_summary(self) -> Dict[str, Any]:
        """获取测试摘要"""
        passed_tests = len([r for r in self.test_results if r["status"] == "passed"])
        total_tests = len(self.test_results)

        return {
            "total_tests": total_tests,
            "passed_tests": passed_tests,
            "failed_tests": total_tests - passed_tests,
            "success_rate": passed_tests / total_tests if total_tests > 0 else 0,
            "avg_response_time": sum(r.get("response_time", 0) for r in self.test_results) / total_tests if total_tests > 0 else 0
        }

class DocumentationGenerator:
    """文档生成器"""

    def __init__(self):
        self.output_dir = Path("docs")
        self.output_dir.mkdir(exist_ok=True)
        self.template_dir = Path("templates")
        self.template_dir.mkdir(exist_ok=True)

    def generate_user_manual(self) -> str:
        """生成用户手册"""
        try:
            manual_path = self.output_dir / "user_manual.md"

            manual_content = f"""# 数据收集代理用户手册

## 概述
数据收集代理是一个基于CCXT库的多交易所统一数据接口系统，负责实时获取市场数据、仓位信息和挂单数据。

## 系统要求
- Python 3.8+
- PostgreSQL 12+
- Redis 6.0+
- 足够的磁盘空间用于数据存储

## 安装部署

### 1. 环境准备
```bash
# 创建虚拟环境
python -m venv venv
source venv/bin/activate

# 安装依赖
pip install -r requirements.txt
```

### 2. 数据库配置
```bash
# 初始化数据库
python scripts/init_db.py

# 运行数据库迁移
python scripts/migrate.py
```

### 3. 启动服务
```bash
# 启动数据收集服务
python -m src.main

# 启动API服务
python -m src.api.main
```

## 用户界面

### 仪表板
系统提供直观的Web仪表板，包含：
- 实时市场数据显示
- 系统监控指标
- 告警信息展示
- 数据导出功能

### 主要功能

#### 1. 数据收集
- 支持多个主流交易所
- 实时行情数据获取
- OHLCV历史数据
- 订单簿深度数据

#### 2. 仓位管理
- 实时仓位同步
- PnL计算和显示
- 仓位历史记录

#### 3. 订单监控
- 订单状态跟踪
- 执行效率分析
- 异常订单处理

#### 4. 监控告警
- 系统性能监控
- 业务指标监控
- 多渠道告警通知

#### 5. 数据导出
- 多格式数据导出
- 批量数据处理
- 定时导出任务

## 常见问题

### Q: 如何添加新的交易所？
A: 在配置文件中添加交易所配置，包括API密钥和基础URL。

### Q: 数据收集失败怎么办？
A: 检查网络连接、API密钥配置和交易所状态。

### Q: 如何优化性能？
A: 调整数据收集频率、启用缓存、优化数据库索引。

## 联系支持
如有问题，请联系技术支持团队。

---
*文档生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

            with open(manual_path, 'w', encoding='utf-8') as f:
                f.write(manual_content)

            logger.info(f"用户手册生成完成: {manual_path}")
            return str(manual_path)

        except Exception as e:
            logger.error(f"生成用户手册失败: {e}")
            return None

    def generate_api_documentation(self) -> str:
        """生成API文档"""
        try:
            api_doc_path = self.output_dir / "api_documentation.md"

            api_content = f"""# 数据收集代理API文档

## 概述
数据收集代理提供完整的RESTful API接口，支持数据的查询、管理和导出。

## 认证
所有API请求需要在请求头中包含有效的JWT token：
```
Authorization: Bearer <your_jwt_token>
```

## 基础信息
- **基础URL**: `{self.base_url or 'http://localhost:8000'}`
- **API版本**: v1
- **数据格式**: JSON

## 端点列表

### 认证端点

#### POST /auth/token
获取访问令牌

**请求体**:
```json
{{
    "username": "your_username",
    "password": "your_password"
}}
```

**响应**:
```json
{{
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    "token_type": "bearer"
}}
```

### 市场数据端点

#### GET /api/v1/markets/tickers
获取行情数据

**参数**:
- `exchange` (可选): 交易所名称
- `symbol` (可选): 交易对符号

**响应**:
```json
[
    {{
        "symbol": "BTC/USDT",
        "price": 45000.0,
        "timestamp": "2025-09-25T10:30:00Z",
        "volume": 1000.0
    }}
]
```

#### GET /api/v1/markets/ohlcv
获取OHLCV数据

**参数**:
- `exchange`: 交易所名称
- `symbol`: 交易对符号
- `timeframe`: 时间框架 (1m, 5m, 1h, 1d)
- `limit`: 数据条数限制
- `start_time`: 开始时间
- `end_time`: 结束时间

**响应**:
```json
[
    {{
        "timestamp": "2025-09-25T10:30:00Z",
        "open": 44900.0,
        "high": 45100.0,
        "low": 44800.0,
        "close": 45000.0,
        "volume": 1000.0
    }}
]
```

#### GET /api/v1/markets/orderbook
获取订单簿数据

**参数**:
- `exchange`: 交易所名称
- `symbol`: 交易对符号
- `limit`: 深度限制

#### GET /api/v1/markets/trades
获取交易数据

**参数**:
- `exchange`: 交易所名称
- `symbol`: 交易对符号
- `limit`: 数据条数限制

### 仓位管理端点

#### GET /api/v1/positions
获取仓位信息

**参数**:
- `exchange` (可选): 交易所名称
- `symbol` (可选): 交易对符号

#### GET /api/v1/positions/pnl
获取PnL摘要

**参数**:
- `exchange` (可选): 交易所名称

### 订单管理端点

#### GET /api/v1/orders
获取订单信息

**参数**:
- `exchange` (可选): 交易所名称
- `symbol` (可选): 交易对符号
- `status` (可选): 订单状态

### 系统管理端点

#### GET /api/v1/system/status
获取系统状态

#### POST /api/v1/system/cache/clear
清空缓存

**参数**:
- `pattern` (可选): 清空模式

### WebSocket端点

#### ws://localhost:8000/ws
实时数据推送

**消息格式**:
```json
{{
    "type": "subscribe",
    "subscription_type": "ticker",
    "channel": "binance_BTC/USDT"
}}
```

## 错误码

| 错误码 | 描述 |
|--------|------|
| 400 | 请求参数错误 |
| 401 | 认证失败 |
| 403 | 权限不足 |
| 404 | 资源不存在 |
| 429 | 请求过于频繁 |
| 500 | 服务器内部错误 |

## 速率限制
- 默认限制: 100请求/分钟
- API密钥用户: 1000请求/分钟
- 管理员: 5000请求/分钟

## 示例代码

### Python示例
```python
import requests

# 获取访问令牌
auth_response = requests.post(
    "http://localhost:8000/auth/token",
    json={"username": "admin", "password": "admin"}
)
token = auth_response.json()["access_token"]

# 设置请求头
headers = {"Authorization": f"Bearer {token}"}

# 获取行情数据
response = requests.get(
    "http://localhost:8000/api/v1/markets/tickers",
    headers=headers,
    params={"exchange": "binance", "symbol": "BTC/USDT"}
)
data = response.json()
```

### JavaScript示例
```javascript
async function getMarketData() {
    const authResponse = await fetch('http://localhost:8000/auth/token', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            username: 'admin',
            password: 'admin'
        })
    });

    const authData = await authResponse.json();
    const token = authData.access_token;

    const response = await fetch(
        'http://localhost:8000/api/v1/markets/tickers?exchange=binance&symbol=BTC/USDT',
        {
            headers: {'Authorization': `Bearer ${token}`}
        }
    );

    const data = await response.json();
    return data;
}
```

---
*API文档生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

            with open(api_doc_path, 'w', encoding='utf-8') as f:
                f.write(api_content)

            logger.info(f"API文档生成完成: {api_doc_path}")
            return str(api_doc_path)

        except Exception as e:
            logger.error(f"生成API文档失败: {e}")
            return None

    def generate_deployment_guide(self) -> str:
        """生成部署指南"""
        try:
            deployment_path = self.output_dir / "deployment_guide.md"

            deployment_content = f"""# 数据收集代理部署指南

## 部署架构
数据收集代理采用微服务架构，包含以下主要组件：
- 数据收集服务
- API服务
- 监控服务
- 数据库服务
- 缓存服务

## 环境要求

### 硬件要求
- CPU: 4核心及以上
- 内存: 8GB及以上
- 磁盘: 100GB及以上SSD
- 网络: 稳定的互联网连接

### 软件要求
- 操作系统: Ubuntu 20.04+ / CentOS 8+
- Python: 3.8+
- PostgreSQL: 12+
- Redis: 6.0+
- Docker: 20.10+
- Docker Compose: 1.29+

## 部署方式

### 1. Docker容器化部署（推荐）

#### 准备工作
```bash
# 克隆代码仓库
git clone https://github.com/your-org/crypto_trading_multi_agents.git
cd crypto_trading_multi_agents

# 复制配置文件
cp docker-compose.yml.example docker-compose.yml
cp .env.example .env
```

#### 配置环境变量
编辑 `.env` 文件：
```bash
# 数据库配置
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_USER=datacollector
POSTGRES_PASSWORD=your_password
POSTGRES_DB=datacollection

# Redis配置
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=your_redis_password

# API配置
API_SECRET_KEY=your_secret_key
JWT_SECRET_KEY=your_jwt_secret

# 交易所配置
BINANCE_API_KEY=your_binance_api_key
BINANCE_API_SECRET=your_binance_api_secret
```

#### 启动服务
```bash
# 构建镜像
docker-compose build

# 启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps
```

#### 数据库初始化
```bash
# 等待数据库启动
sleep 30

# 运行数据库迁移
docker-compose exec backend python scripts/migrate.py

# 创建管理员用户
docker-compose exec backend python scripts/create_admin.py
```

### 2. 传统部署方式

#### 安装依赖
```bash
# 更新系统
sudo apt update && sudo apt upgrade -y

# 安装Python和pip
sudo apt install python3 python3-pip python3-venv -y

# 安装PostgreSQL
sudo apt install postgresql postgresql-contrib -y

# 安装Redis
sudo apt install redis-server -y
```

#### 配置数据库
```bash
# 创建数据库用户
sudo -u postgres createuser --interactive
sudo -u postgres createdb datacollection

# 配置PostgreSQL
sudo nano /etc/postgresql/12/main/postgresql.conf
```

#### 部署应用
```bash
# 创建应用目录
sudo mkdir -p /opt/datacollector
sudo chown $USER:$USER /opt/datacollector

# 复制应用文件
cp -r src/ /opt/datacollector/
cp requirements.txt /opt/datacollector/

# 创建虚拟环境
cd /opt/datacollector
python3 -m venv venv
source venv/bin/activate

# 安装依赖
pip install -r requirements.txt

# 配置环境变量
cp .env.example .env
nano .env
```

#### 配置systemd服务
创建 `/etc/systemd/system/datacollector.service`:
```ini
[Unit]
Description=Data Collection Agent
After=network.target

[Service]
Type=simple
User=datacollector
WorkingDirectory=/opt/datacollector
Environment=PATH=/opt/datacollector/venv/bin
ExecStart=/opt/datacollector/venv/bin/python -m src.main
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

启动服务：
```bash
sudo systemctl daemon-reload
sudo systemctl enable datacollector
sudo systemctl start datacollector
```

## 监控和日志

### 日志配置
- 应用日志: `/var/log/datacollector/`
- 访问日志: `/var/log/nginx/access.log`
- 错误日志: `/var/log/nginx/error.log`

### 监控配置
- Prometheus: `http://localhost:9090`
- Grafana: `http://localhost:3000`
- 应用监控: `http://localhost:8000/metrics`

## 备份和恢复

### 数据库备份
```bash
# 创建备份
pg_dump -h localhost -U datacollector -d datacollection > backup_$(date +%Y%m%d).sql

# 恢复备份
psql -h localhost -U datacollector -d datacollection < backup_20250925.sql
```

### 配置备份
```bash
# 备份配置文件
tar -czf config_backup_$(date +%Y%m%d).tar.gz /opt/datacollector/.env /etc/systemd/system/datacollector.service
```

## 故障排除

### 常见问题

#### 1. 服务无法启动
```bash
# 检查服务状态
sudo systemctl status datacollector

# 查看日志
sudo journalctl -u datacollector -f
```

#### 2. 数据库连接失败
```bash
# 检查数据库状态
sudo systemctl status postgresql

# 测试连接
psql -h localhost -U datacollector -d datacollection
```

#### 3. Redis连接失败
```bash
# 检查Redis状态
sudo systemctl status redis-server

# 测试连接
redis-cli ping
```

#### 4. API请求失败
```bash
# 检查API服务状态
curl http://localhost:8000/health

# 检查网络连接
telnet localhost 8000
```

### 性能优化

#### 1. 数据库优化
```sql
-- 创建索引
CREATE INDEX idx_ohlcv_timestamp ON ohlcv_data(timestamp);
CREATE INDEX idx_positions_exchange ON positions(exchange, symbol);
```

#### 2. Redis优化
```bash
# 配置Redis内存
maxmemory 1gb
maxmemory-policy allkeys-lru
```

#### 3. 应用优化
```python
# 调整工作进程数
workers = multiprocessing.cpu_count() * 2 + 1
```

## 安全配置

### 1. 防火墙配置
```bash
# 开放必要端口
sudo ufw allow 22/tcp
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
```

### 2. SSL/TLS配置
```nginx
# Nginx SSL配置
server {{
    listen 443 ssl;
    server_name your-domain.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;

    location / {{
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }}
}}
```

### 3. API密钥管理
```bash
# 使用环境变量
export BINANCE_API_KEY="your_api_key"
export BINANCE_API_SECRET="your_api_secret"

# 使用密钥管理服务
vault kv put secret/datacollector/binance api_key="your_key" api_secret="your_secret"
```

## 升级维护

### 版本升级
```bash
# 备份当前版本
docker-compose down
pg_dump > backup_before_upgrade.sql

# 更新代码
git pull origin main

# 重新构建
docker-compose build

# 运行迁移
docker-compose exec backend python scripts/migrate.py

# 启动新版本
docker-compose up -d
```

### 滚动升级
```bash
# 使用蓝绿部署策略
docker-compose -f docker-compose.blue.yml up -d
docker-compose -f docker-compose.green.yml up -d

# 切换流量
# 使用负载均衡器或DNS切换
```

---
*部署指南生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

            with open(deployment_path, 'w', encoding='utf-8') as f:
                f.write(deployment_content)

            logger.info(f"部署指南生成完成: {deployment_path}")
            return str(deployment_path)

        except Exception as e:
            logger.error(f"生成部署指南失败: {e}")
            return None

    def generate_training_materials(self) -> str:
        """生成培训材料"""
        try:
            training_path = self.output_dir / "training_materials.md"

            training_content = f"""# 数据收集代理培训材料

## 培训目标
通过本培训，学员将能够：
- 理解数据收集代理的系统架构
- 掌握系统的安装和配置
- 熟练使用各项功能
- 进行基本的故障排除
- 了解最佳实践和安全注意事项

## 培训对象
- 系统管理员
- 数据分析师
- 交易员
- 开发人员

## 培训内容

### 模块1: 系统概述 (2小时)

#### 1.1 系统介绍
- 什么是数据收集代理
- 系统的主要功能
- 技术架构和组件
- 适用场景和优势

#### 1.2 核心概念
- 交易所API集成
- 数据类型和格式
- 实时vs历史数据
- 缓存和存储策略

#### 1.3 系统要求
- 硬件要求
- 软件依赖
- 网络要求
- 安全考虑

### 模块2: 安装部署 (3小时)

#### 2.1 环境准备
- 操作系统配置
- 数据库安装
- Redis配置
- 网络设置

#### 2.2 应用部署
- 源码部署
- Docker部署
- 云平台部署
- 负载均衡配置

#### 2.3 初始化配置
- 数据库初始化
- 用户创建
- 交易所配置
- 监控设置

#### 实践练习:
- 在测试环境中完成完整部署
- 配置2个交易所连接
- 验证所有服务正常运行

### 模块3: 基础功能使用 (4小时)

#### 3.1 用户界面操作
- 登录和权限管理
- 仪表板导航
- 数据查看和筛选
- 基本操作流程

#### 3.2 数据收集功能
- 交易所连接管理
- 数据类型选择
- 收集频率配置
- 数据质量监控

#### 3.3 仓位和订单管理
- 仓位信息查看
- PnL计算和分析
- 订单状态跟踪
- 执行效率分析

#### 实践练习:
- 添加新的交易所连接
- 配置不同数据类型的收集
- 分析仓位和订单数据
- 生成基本报告

### 模块4: 高级功能 (3小时)

#### 4.1 监控告警
- 系统监控指标
- 告警规则配置
- 通知渠道设置
- 告警响应流程

#### 4.2 数据导出
- 多格式导出
- 批量数据处理
- 定时导出任务
- 数据传输安全

#### 4.3 系统配置
- 参数调优
- 性能优化
- 安全配置
- 备份策略

#### 实践练习:
- 配置监控告警规则
- 设置数据导出任务
- 优化系统性能
- 配置自动备份

### 模块5: 故障排除 (2小时)

#### 5.1 常见问题
- 连接问题
- 数据质量问题
- 性能问题
- 权限问题

#### 5.2 诊断工具
- 日志分析
- 监控仪表板
- 性能分析
- 健康检查

#### 5.3 应急处理
- 服务重启
- 数据恢复
- 紧急配置
- 通知流程

#### 实践练习:
- 模拟常见故障场景
- 使用诊断工具
- 执行应急处理流程
- 编写故障报告

### 模块6: 最佳实践 (2小时)

#### 6.1 安全最佳实践
- API密钥管理
- 访问控制
- 数据加密
- 审计日志

#### 6.2 性能最佳实践
- 资源优化
- 缓存策略
- 数据库优化
- 网络优化

#### 6.3 运维最佳实践
- 监控策略
- 备份策略
- 升级策略
- 文档维护

#### 实践练习:
- 制定安全配置方案
- 优化系统性能
- 制定运维计划
- 完善系统文档

## 培训方式

### 理论学习
- 讲师授课
- 文档阅读
- 视频演示
- 小组讨论

### 实践操作
- 环境搭建
- 功能测试
- 问题排查
- 项目练习

### 评估方式
- 理论考试 (30%)
- 实践操作 (50%)
- 项目作业 (20%)

## 培训时间安排

### 基础培训 (3天)
- Day 1: 模块1 + 模块2
- Day 2: 模块3
- Day 3: 模块4 + 考试

### 高级培训 (2天)
- Day 1: 模块5 + 模块6
- Day 2: 项目实践 + 评估

## 培训材料

### 提供材料
- 本培训文档
- 系统安装包
- 配置文件模板
- 练习题和答案
- 参考手册

### 推荐阅读
- CCXT官方文档
- PostgreSQL文档
- Redis文档
- FastAPI文档

## 认证考试

### 考试内容
- 系统概念和架构 (20%)
- 安装配置 (30%)
- 功能使用 (30%)
- 故障排除 (20%)

### 通过标准
- 理论考试: 80分以上
- 实践操作: 完成所有练习
- 总评: 85分以上

## 后续支持

### 技术支持
- 邮件支持: support@example.com
- 在线文档: docs.example.com
- 社区论坛: forum.example.com
- 定期更新培训

### 进阶培训
- 开发者培训
- 运维培训
- 安全培训
- 性能优化培训

---
*培训材料生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

            with open(training_path, 'w', encoding='utf-8') as f:
                f.write(training_content)

            logger.info(f"培训材料生成完成: {training_path}")
            return str(training_path)

        except Exception as e:
            logger.error(f"生成培训材料失败: {e}")
            return None

class UATCoordinator:
    """UAT协调器"""

    def __init__(self):
        self.user_stories: Dict[str, UserStory] = {}
        self.test_sessions: Dict[str, UATSession] = []
        self.web_automation = WebUIAutomation()
        self.api_automation = APIAutomation()
        self.doc_generator = DocumentationGenerator()

    def create_user_story(self, story: UserStory) -> bool:
        """创建用户故事"""
        try:
            self.user_stories[story.story_id] = story
            logger.info(f"创建用户故事: {story.title}")
            return True
        except Exception as e:
            logger.error(f"创建用户故事失败: {e}")
            return False

    def create_test_session(self, name: str, description: str, tester: str, environment: str) -> str:
        """创建测试会话"""
        try:
            session_id = f"uat_session_{int(time.time())}"
            session = UATSession(
                session_id=session_id,
                name=name,
                description=description,
                start_time=datetime.now(),
                tester=tester,
                environment=environment
            )
            self.test_sessions.append(session)
            logger.info(f"创建测试会话: {name}")
            return session_id
        except Exception as e:
            logger.error(f"创建测试会话失败: {e}")
            return None

    async def execute_user_story(self, story_id: str, session_id: str) -> bool:
        """执行用户故事测试"""
        try:
            story = self.user_stories.get(story_id)
            session = next((s for s in self.test_sessions if s.session_id == session_id), None)

            if not story or not session:
                return False

            logger.info(f"开始执行用户故事: {story.title}")
            story.status = UATStatus.IN_PROGRESS
            story.updated_at = datetime.now()

            session.stories_tested.append(story_id)

            # 根据场景执行不同的测试
            success = False
            if story.scenario == TestScenario.DATA_COLLECTION:
                success = await self._test_data_collection_story(story)
            elif story.scenario == TestScenario.MONITORING:
                success = await self._test_monitoring_story(story)
            elif story.scenario == TestScenario.REPORTING:
                success = await self._test_reporting_story(story)
            elif story.scenario == TestScenario.CONFIGURATION:
                success = await self._test_configuration_story(story)
            elif story.scenario == TestScenario.DEPLOYMENT:
                success = await self._test_deployment_story(story)

            story.status = UATStatus.PASSED if success else UATStatus.FAILED
            story.updated_at = datetime.now()

            logger.info(f"用户故事执行完成: {story.title} - {'通过' if success else '失败'}")
            return success

        except Exception as e:
            logger.error(f"执行用户故事失败: {e}")
            if story_id in self.user_stories:
                self.user_stories[story_id].status = UATStatus.FAILED
                self.user_stories[story_id].updated_at = datetime.now()
            return False

    async def _test_data_collection_story(self, story: UserStory) -> bool:
        """测试数据收集用户故事"""
        try:
            # Web UI测试
            self.web_automation.setup_driver(headless=True)

            success = True

            success &= self.web_automation.navigate_to_url("http://localhost:8000")
            success &= self.web_automation.login("admin", "admin")
            success &= self.web_automation.verify_dashboard_loaded()
            success &= self.web_automation.navigate_to_data_collection()
            success &= self.web_automation.verify_real_time_data()
            success &= self.web_automation.test_data_export()

            # API测试
            self.api_automation.authenticate("admin", "admin")
            success &= self.api_automation.test_market_data_api()
            success &= self.api_automation.test_position_api()
            success &= self.api_automation.test_order_api()

            self.web_automation.close()
            return success

        except Exception as e:
            logger.error(f"数据收集用户故事测试失败: {e}")
            return False

    async def _test_monitoring_story(self, story: UserStory) -> bool:
        """测试监控用户故事"""
        try:
            self.web_automation.setup_driver(headless=True)

            success = True

            success &= self.web_automation.navigate_to_url("http://localhost:8000")
            success &= self.web_automation.login("admin", "admin")
            success &= self.web_automation.test_monitoring_alerts()

            self.web_automation.close()
            return success

        except Exception as e:
            logger.error(f"监控用户故事测试失败: {e}")
            return False

    async def _test_configuration_story(self, story: UserStory) -> bool:
        """测试配置用户故事"""
        try:
            self.web_automation.setup_driver(headless=True)

            success = self.web_automation.navigate_to_url("http://localhost:8000")
            success &= self.web_automation.login("admin", "admin")
            success &= self.web_automation.test_system_configuration()

            self.web_automation.close()
            return success

        except Exception as e:
            logger.error(f"配置用户故事测试失败: {e}")
            return False

    async def _test_reporting_story(self, story: UserStory) -> bool:
        """测试报告用户故事"""
        try:
            # 这里应该测试报告生成功能
            return True
        except Exception as e:
            logger.error(f"报告用户故事测试失败: {e}")
            return False

    async def _test_deployment_story(self, story: UserStory) -> bool:
        """测试部署用户故事"""
        try:
            # 这里应该测试部署相关功能
            return True
        except Exception as e:
            logger.error(f"部署用户故事测试失败: {e}")
            return False

    async def generate_all_documentation(self) -> Dict[str, str]:
        """生成所有文档"""
        try:
            docs = {}

            # 生成用户手册
            user_manual = self.doc_generator.generate_user_manual()
            if user_manual:
                docs["user_manual"] = user_manual

            # 生成API文档
            api_doc = self.doc_generator.generate_api_documentation()
            if api_doc:
                docs["api_documentation"] = api_doc

            # 生成部署指南
            deployment_guide = self.doc_generator.generate_deployment_guide()
            if deployment_guide:
                docs["deployment_guide"] = deployment_guide

            # 生成培训材料
            training_materials = self.doc_generator.generate_training_materials()
            if training_materials:
                docs["training_materials"] = training_materials

            logger.info(f"生成了 {len(docs)} 个文档")
            return docs

        except Exception as e:
            logger.error(f"生成文档失败: {e}")
            return {}

    def get_uat_summary(self) -> Dict[str, Any]:
        """获取UAT摘要"""
        try:
            total_stories = len(self.user_stories)
            passed_stories = len([s for s in self.user_stories.values() if s.status == UATStatus.PASSED])
            failed_stories = len([s for s in self.user_stories.values() if s.status == UATStatus.FAILED])
            pending_stories = len([s for s in self.user_stories.values() if s.status == UATStatus.PLANNED])

            return {
                "total_stories": total_stories,
                "passed_stories": passed_stories,
                "failed_stories": failed_stories,
                "pending_stories": pending_stories,
                "success_rate": passed_stories / total_stories if total_stories > 0 else 0,
                "total_sessions": len(self.test_sessions),
                "active_sessions": len([s for s in self.test_sessions if s.overall_status == UATStatus.IN_PROGRESS])
            }
        except Exception as e:
            logger.error(f"获取UAT摘要失败: {e}")
            return {}

    def generate_uat_report(self) -> str:
        """生成UAT报告"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_path = Path("uat_reports") / f"uat_report_{timestamp}.html"
            report_path.parent.mkdir(exist_ok=True)

            summary = self.get_uat_summary()

            html_content = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <title>用户验收测试报告</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 20px; }}
                    .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
                    .summary {{ display: flex; justify-content: space-around; margin: 20px 0; }}
                    .summary-item {{ text-align: center; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }}
                    .passed {{ background-color: #d4edda; }}
                    .failed {{ background-color: #f8d7da; }}
                    .pending {{ background-color: #fff3cd; }}
                    .story-section {{ margin: 20px 0; }}
                    .story-item {{ margin: 10px 0; padding: 10px; border: 1px solid #ddd; border-radius: 3px; }}
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>数据收集代理用户验收测试报告</h1>
                    <p>生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                </div>

                <div class="summary">
                    <div class="summary-item">
                        <h3>总用户故事</h3>
                        <p>{summary['total_stories']}</p>
                    </div>
                    <div class="summary-item passed">
                        <h3>通过</h3>
                        <p>{summary['passed_stories']}</p>
                    </div>
                    <div class="summary-item failed">
                        <h3>失败</h3>
                        <p>{summary['failed_stories']}</p>
                    </div>
                    <div class="summary-item pending">
                        <h3>待测试</h3>
                        <p>{summary['pending_stories']}</p>
                    </div>
                    <div class="summary-item">
                        <h3>通过率</h3>
                        <p>{summary['success_rate']:.1%}</p>
                    </div>
                </div>

                <h2>用户故事详情</h2>
            """

            for story in self.user_stories.values():
                status_class = story.status.value.lower()
                html_content += f"""
                <div class="story-item {status_class}">
                    <h4>{story.title}</h4>
                    <p>角色: {story.role.value}</p>
                    <p>场景: {story.scenario.value}</p>
                    <p>状态: {story.status.value}</p>
                    <p>优先级: {story.priority}</p>
                    <p>验收标准:</p>
                    <ul>
                """
                for criterion in story.acceptance_criteria:
                    html_content += f"<li>{criterion}</li>"
                html_content += """
                    </ul>
                </div>
                """

            html_content += """
            </body>
            </html>
            """

            with open(report_path, 'w', encoding='utf-8') as f:
                f.write(html_content)

            logger.info(f"UAT报告生成完成: {report_path}")
            return str(report_path)

        except Exception as e:
            logger.error(f"生成UAT报告失败: {e}")
            return None

# 全局实例
uat_coordinator = UATCoordinator()

# 初始化UAT故事
def initialize_uat_stories():
    """初始化UAT用户故事"""
    stories = [
        UserStory(
            story_id="uat_001",
            title="交易员查看实时市场数据",
            description="作为交易员，我希望能够实时查看市场数据，以便做出交易决策",
            role=UserRole.TRADER,
            scenario=TestScenario.DATA_COLLECTION,
            acceptance_criteria=[
                "能够登录系统",
                "能够查看实时行情数据",
                "数据更新延迟小于1秒",
                "支持多个交易所数据对比"
            ],
            priority=1,
            estimated_time=30
        ),
        UserStory(
            story_id="uat_002",
            title="分析师查看历史数据趋势",
            description="作为分析师，我希望能够查看历史数据趋势，以便进行技术分析",
            role=UserRole.ANALYST,
            scenario=TestScenario.DATA_COLLECTION,
            acceptance_criteria=[
                "能够选择时间范围",
                "能够查看OHLCV数据",
                "支持多种时间框架",
                "数据导出功能正常"
            ],
            priority=2,
            estimated_time=25
        ),
        UserStory(
            story_id="uat_003",
            title="管理员监控系统状态",
            description="作为管理员，我希望能够监控系统运行状态，及时发现和处理异常",
            role=UserRole.ADMIN,
            scenario=TestScenario.MONITORING,
            acceptance_criteria=[
                "能够查看系统资源使用情况",
                "能够配置告警规则",
                "告警通知正常发送",
                "监控仪表板显示正常"
            ],
            priority=1,
            estimated_time=20
        ),
        UserStory(
            story_id="uat_004",
            title="部署人员进行系统配置",
            description="作为部署人员，我希望能够进行系统配置，确保系统正常运行",
            role=UserRole.DEPLOYER,
            scenario=TestScenario.CONFIGURATION,
            acceptance_criteria=[
                "能够配置交易所连接",
                "能够设置系统参数",
                "配置变更生效",
                "配置验证正常"
            ],
            priority=2,
            estimated_time=35
        )
    ]

    for story in stories:
        uat_coordinator.create_user_story(story)

    logger.info(f"初始化了 {len(stories)} 个用户故事")

# 主UAT运行器
async def run_uat_suite():
    """运行UAT套件"""
    logger.info("开始运行用户验收测试套件")

    try:
        # 初始化用户故事
        initialize_uat_stories()

        # 创建测试会话
        session_id = uat_coordinator.create_test_session(
            name="完整UAT测试",
            description="数据收集代理完整功能验收测试",
            tester="uat_tester",
            environment="staging"
        )

        # 执行所有用户故事测试
        results = []
        for story_id in uat_coordinator.user_stories.keys():
            result = await uat_coordinator.execute_user_story(story_id, session_id)
            results.append((story_id, result))

        # 生成文档
        docs = await uat_coordinator.generate_all_documentation()

        # 生成UAT报告
        uat_report = uat_coordinator.generate_uat_report()

        # 获取测试摘要
        summary = uat_coordinator.get_uat_summary()

        logger.info(f"UAT套件运行完成 - 通过率: {summary['success_rate']:.1%}")
        return {
            "results": results,
            "documents": docs,
            "uat_report": uat_report,
            "summary": summary
        }

    except Exception as e:
        logger.error(f"UAT套件运行失败: {e}")
        return None

if __name__ == "__main__":
    # 运行UAT
    asyncio.run(run_uat_suite())
```

## 接受标准

### 必须满足的条件
- [ ] 实现完整的用户验收测试框架
- [ ] 支持多角色用户场景测试
- [ ] 提供Web UI自动化测试
- [ ] 实现API自动化测试
- [ ] 生成完整的用户手册
- [ ] 创建详细的API文档
- [ ] 提供部署和运维文档
- [ ] 生成培训材料
- [ ] 通过所有用户故事验收标准
- [ ] 生成综合UAT报告

### UAT要求
- **用户故事通过率**: > 95%
- **功能完整性**: 100%核心功能覆盖
- **用户体验**: 界面友好、操作流畅
- **文档质量**: 完整、准确、易于理解
- **培训效果**: 用户能够独立操作系统

### 文档要求
- **用户手册**: 完整的操作指南
- **API文档**: 详细的接口说明
- **部署文档**: 详细的部署步骤
- **培训材料**: 系统的培训内容
- **版本控制**: 文档版本管理

## 实现步骤

### 第一阶段：UAT框架搭建 (2天)
1. 设计UAT测试框架
2. 创建用户故事模板
3. 实现Web UI自动化
4. 开发API自动化测试

### 第二阶段：用户验收测试 (3天)
1. 执行交易员角色测试
2. 执行分析师角色测试
3. 执行管理员角色测试
4. 执行部署人员角色测试

### 第三阶段：文档生成 (4天)
1. 生成用户手册
2. 创建API文档
3. 编写部署指南
4. 制作培训材料

### 第四阶段：报告和验收 (3天)
1. 生成UAT测试报告
2. 进行用户反馈收集
3. 完善文档和系统
4. 最终验收确认

## 交付物

### 文档
- 完整的用户手册
- 详细的API文档
- 部署和运维指南
- 系统培训材料
- UAT测试报告

### 测试脚本
- Web UI自动化测试脚本
- API自动化测试脚本
- 用户故事测试用例
- 性能和负载测试脚本

### 配置
- UAT测试环境配置
- 自动化测试配置
- 文档生成配置
- CI/CD集成配置

## 风险和依赖

### 技术风险
- 自动化测试稳定性
- 用户界面变更影响
- 测试环境差异性
- 文档同步问题

### 依赖关系
- 依赖于稳定的测试环境
- 依赖于功能完整性
- 依赖于用户参与
- 依赖于文档准确性

### 缓解措施
- 实现健壮的测试框架
- 使用相对定位和等待机制
- 标准化测试环境配置
- 建立文档更新流程

## 验收标准
- 所有用户故事通过验收测试
- 自动化测试脚本稳定运行
- 文档完整且易于理解
- 用户能够独立操作系统
- UAT通过率达到95%以上
- 系统功能满足业务需求
- 部署和运维流程完善