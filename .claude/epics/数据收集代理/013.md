---
name: RESTful API服务和WebSocket实现
type: task
epic: 数据收集代理
status: open
priority: 2
created: 2025-09-25T20:20:35Z
estimated: 10 days
assigned: [待分配]
parallelizable: true
dependencies: ["003", "009", "012"]
---

# 任务: RESTful API服务和WebSocket实现

## 任务描述
实现RESTful API服务和WebSocket实时数据推送，包括API设计、WebSocket服务、文档生成和测试。通过高性能的API服务和实时数据推送机制，为客户端提供稳定、高效的数据访问接口，支持高频交易系统的实时数据需求。

## 技术要求

### 核心架构设计

#### API Service 组件
- **RESTful API**: 标准的RESTful API接口，支持数据查询和管理
- **WebSocket Service**: 实时数据推送服务，支持多路复用和心跳检测
- **API网关**: 统一的API入口，支持负载均衡和限流
- **认证授权**: JWT token认证和基于角色的访问控制
- **文档系统**: 自动生成的API文档和测试界面

#### 技术栈
- **Web框架**: FastAPI + Uvicorn
- **WebSocket**: FastAPI WebSocket + Socket.IO (可选)
- **认证**: JWT + OAuth2
- **文档**: OpenAPI/Swagger + ReDoc
- **测试**: Pytest + HTTPX + WebSocket测试
- **监控**: Prometheus + Grafana

### 实现架构

```python
# src/api/main.py
import asyncio
import time
import json
from typing import Dict, List, Optional, Any, Callable, Union
from datetime import datetime, timedelta
from enum import Enum
import logging
from contextlib import asynccontextmanager
import uuid
from collections import defaultdict, deque
import weakref

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from fastapi.openapi.docs import get_swagger_ui_html, get_redoc_html
from fastapi.openapi.utils import get_openapi
from fastapi.responses import JSONResponse
from fastapi.routing import APIRoute
from fastapi.exceptions import RequestValidationError
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response
from pydantic import BaseModel, Field, validator
import jwt
from prometheus_client import make_asgi_app
from httpx import AsyncClient
import websockets

from ..core.config import config
from ..core.logger import get_logger
from ..core.metrics import metrics
from ..core.exceptions import APIError, AuthenticationError, RateLimitError
from ..managers.exchange_manager import exchange_manager
from ..managers.position_manager import position_manager
from ..managers.order_manager import order_manager
from ..processors.data_processor import data_processor
from ..validation.data_validator import data_validator
from ..cache.cache_manager import cache_manager
from ..models.api import *
from ..models.market_data import OHLCV, Ticker, OrderBook, Trade
from ..models.position import PositionInfo
from ..models.order import OrderInfo

# 初始化日志
logger = get_logger("api_service")

# 安全配置
security = HTTPBearer()
ALGORITHM = "HS256"
SECRET_KEY = config.get("api_secret_key", "your-secret-key")

class UserRole(Enum):
    """用户角色枚举"""
    ADMIN = "admin"
    TRADER = "trader"
    VIEWER = "viewer"

class Permission(Enum):
    """权限枚举"""
    READ_DATA = "read_data"
    WRITE_DATA = "write_data"
    MANAGE_SYSTEM = "manage_system"
    VIEW_POSITIONS = "view_positions"
    MANAGE_ORDERS = "manage_orders"

class WebSocketEventType(Enum):
    """WebSocket事件类型枚举"""
    TICKER_UPDATE = "ticker_update"
    OHLCV_UPDATE = "ohlcv_update"
    ORDERBOOK_UPDATE = "orderbook_update"
    TRADE_UPDATE = "trade_update"
    POSITION_UPDATE = "position_update"
    ORDER_UPDATE = "order_update"
    SYSTEM_ALERT = "system_alert"
    HEARTBEAT = "heartbeat"

class SubscriptionType(Enum):
    """订阅类型枚举"""
    TICKER = "ticker"
    OHLCV = "ohlcv"
    ORDERBOOK = "orderbook"
    TRADE = "trade"
    POSITION = "position"
    ORDER = "order"

class ConnectionManager:
    """WebSocket连接管理器"""

    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.subscriptions: Dict[str, Dict[str, set]] = defaultdict(lambda: defaultdict(set))
        self.client_metadata: Dict[str, Dict[str, Any]] = {}
        self.heartbeat_interval = 30  # 30秒心跳
        self.connection_timeout = 60  # 60秒超时

    async def connect(self, websocket: WebSocket, client_id: str):
        """连接WebSocket"""
        await websocket.accept()
        self.active_connections[client_id] = websocket
        self.client_metadata[client_id] = {
            'connected_at': datetime.now(),
            'last_heartbeat': datetime.now(),
            'subscription_count': 0,
            'message_count': 0
        }
        logger.info(f"WebSocket连接建立: {client_id}")

    async def disconnect(self, client_id: str):
        """断开WebSocket连接"""
        if client_id in self.active_connections:
            await self.active_connections[client_id].close()
            del self.active_connections[client_id]
            del self.client_metadata[client_id]

            # 清理订阅
            for subscription_type, clients in self.subscriptions.items():
                for channel, client_set in clients.items():
                    client_set.discard(client_id)

            logger.info(f"WebSocket连接断开: {client_id}")

    async def send_personal_message(self, message: str, client_id: str):
        """发送个人消息"""
        if client_id in self.active_connections:
            try:
                await self.active_connections[client_id].send_text(message)
                self.client_metadata[client_id]['message_count'] += 1
            except Exception as e:
                logger.error(f"发送个人消息失败: {e}")
                await self.disconnect(client_id)

    async def broadcast(self, message: str, subscription_type: str, channel: str):
        """广播消息"""
        if subscription_type in self.subscriptions:
            if channel in self.subscriptions[subscription_type]:
                disconnected_clients = []

                for client_id in self.subscriptions[subscription_type][channel]:
                    if client_id in self.active_connections:
                        try:
                            await self.active_connections[client_id].send_text(message)
                            self.client_metadata[client_id]['message_count'] += 1
                        except Exception as e:
                            logger.error(f"广播消息失败: {e}")
                            disconnected_clients.append(client_id)
                    else:
                        disconnected_clients.append(client_id)

                # 清理断开的连接
                for client_id in disconnected_clients:
                    await self.disconnect(client_id)

    async def subscribe(self, client_id: str, subscription_type: str, channel: str):
        """订阅频道"""
        self.subscriptions[subscription_type][channel].add(client_id)
        self.client_metadata[client_id]['subscription_count'] += 1
        logger.info(f"客户端 {client_id} 订阅 {subscription_type}/{channel}")

    async def unsubscribe(self, client_id: str, subscription_type: str, channel: str):
        """取消订阅"""
        if subscription_type in self.subscriptions:
            if channel in self.subscriptions[subscription_type]:
                self.subscriptions[subscription_type][channel].discard(client_id)
                self.client_metadata[client_id]['subscription_count'] -= 1
        logger.info(f"客户端 {client_id} 取消订阅 {subscription_type}/{channel}")

    def get_connection_stats(self) -> Dict[str, Any]:
        """获取连接统计"""
        return {
            'total_connections': len(self.active_connections),
            'total_subscriptions': sum(
                len(clients) for channels in self.subscriptions.values()
                for clients in channels.values()
            ),
            'client_metadata': self.client_metadata.copy()
        }

    async def check_heartbeats(self):
        """检查心跳"""
        current_time = datetime.now()
        timeout_clients = []

        for client_id, metadata in self.client_metadata.items():
            if (current_time - metadata['last_heartbeat']).total_seconds() > self.connection_timeout:
                timeout_clients.append(client_id)

        for client_id in timeout_clients:
            logger.warning(f"客户端 {client_id} 心跳超时，断开连接")
            await self.disconnect(client_id)

    async def send_heartbeat(self, client_id: str):
        """发送心跳"""
        heartbeat_message = {
            'type': WebSocketEventType.HEARTBEAT.value,
            'timestamp': datetime.now().isoformat(),
            'client_id': client_id
        }
        await self.send_personal_message(json.dumps(heartbeat_message), client_id)

# 全局连接管理器
connection_manager = ConnectionManager()

class RateLimiter:
    """速率限制器"""

    def __init__(self):
        self.requests = defaultdict(lambda: deque(maxlen=1000))
        self.limits = {
            'default': {'requests': 100, 'window': 60},  # 100请求/分钟
            'api_key': {'requests': 1000, 'window': 60},  # 1000请求/分钟
            'admin': {'requests': 5000, 'window': 60}  # 5000请求/分钟
        }

    def is_allowed(self, client_id: str, user_type: str = 'default') -> bool:
        """检查是否允许请求"""
        current_time = time.time()
        window_start = current_time - self.limits[user_type]['window']

        # 清理过期请求
        while self.requests[client_id] and self.requests[client_id][0] < window_start:
            self.requests[client_id].popleft()

        # 检查请求数量
        if len(self.requests[client_id]) >= self.limits[user_type]['requests']:
            return False

        # 记录请求
        self.requests[client_id].append(current_time)
        return True

    def get_remaining(self, client_id: str, user_type: str = 'default') -> int:
        """获取剩余请求数量"""
        current_time = time.time()
        window_start = current_time - self.limits[user_type]['window']

        # 清理过期请求
        while self.requests[client_id] and self.requests[client_id][0] < window_start:
            self.requests[client_id].popleft()

        remaining = self.limits[user_type]['requests'] - len(self.requests[client_id])
        return max(0, remaining)

# 全局速率限制器
rate_limiter = RateLimiter()

class AuthManager:
    """认证管理器"""

    @staticmethod
    def create_access_token(data: dict, expires_delta: timedelta = None) -> str:
        """创建访问令牌"""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(hours=1)

        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt

    @staticmethod
    def verify_token(token: str) -> dict:
        """验证令牌"""
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            return payload
        except jwt.ExpiredSignatureError:
            raise AuthenticationError("Token已过期")
        except jwt.InvalidTokenError:
            raise AuthenticationError("无效的令牌")

    @staticmethod
    def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> dict:
        """获取当前用户"""
        try:
            token = credentials.credentials
            payload = AuthManager.verify_token(token)
            return payload
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"认证失败: {str(e)}",
                headers={"WWW-Authenticate": "Bearer"},
            )

class MetricsMiddleware(BaseHTTPMiddleware):
    """指标中间件"""

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        start_time = time.time()

        # 获取客户端信息
        client_ip = request.client.host
        user_agent = request.headers.get("user-agent", "")

        response = await call_next(request)

        # 记录指标
        process_time = time.time() - start_time
        metrics.record_http_request(
            method=request.method,
            endpoint=str(request.url.path),
            status_code=response.status_code,
            process_time=process_time,
            client_ip=client_ip
        )

        return response

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """请求日志中间件"""

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        start_time = time.time()

        # 记录请求开始
        logger.info(f"请求开始: {request.method} {request.url}")

        response = await call_next(request)

        # 记录请求完成
        process_time = time.time() - start_time
        logger.info(f"请求完成: {request.method} {request.url} - {response.status_code} - {process_time:.3f}s")

        return response

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # 启动时初始化
    logger.info("API服务启动中...")

    # 启动心跳检查任务
    heartbeat_task = asyncio.create_task(heartbeat_monitor())

    yield

    # 关闭时清理
    logger.info("API服务关闭中...")
    heartbeat_task.cancel()
    try:
        await heartbeat_task
    except asyncio.CancelledError:
        pass

# 创建FastAPI应用
app = FastAPI(
    title="加密货币数据收集API",
    description="提供加密货币市场数据、仓位信息和订单管理的RESTful API和WebSocket服务",
    version="1.0.0",
    lifespan=lifespan,
    docs_url="/docs",
    redoc_url="/redoc"
)

# 添加中间件
app.add_middleware(MetricsMiddleware)
app.add_middleware(RequestLoggingMiddleware)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 添加Prometheus指标
metrics_app = make_asgi_app()
app.mount("/metrics", metrics_app)

# 自定义API路由
class CustomAPIRoute(APIRoute):
    """自定义API路由"""

    def get_route_handler(self):
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            # 速率限制检查
            client_id = request.client.host
            if not rate_limiter.is_allowed(client_id):
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail="请求过于频繁，请稍后重试"
                )

            # 记录请求开始
            start_time = time.time()

            try:
                response = await original_route_handler(request)
            except Exception as e:
                # 记录错误
                logger.error(f"API请求错误: {str(e)}")
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail="内部服务器错误"
                )

            # 添加速率限制头
            remaining = rate_limiter.get_remaining(client_id)
            response.headers["X-RateLimit-Limit"] = "100"
            response.headers["X-RateLimit-Remaining"] = str(remaining)
            response.headers["X-RateLimit-Reset"] = str(int(time.time() + 60))

            return response

        return custom_route_handler

# 设置自定义路由
app.router.route_class = CustomAPIRoute

# 异常处理
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """验证异常处理"""
    logger.error(f"请求验证失败: {exc.errors()}")
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors(), "message": "请求参数验证失败"}
    )

@app.exception_handler(APIError)
async def api_error_handler(request: Request, exc: APIError):
    """API异常处理"""
    logger.error(f"API错误: {str(exc)}")
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={"message": str(exc)}
    )

# 基础路由
@app.get("/")
async def root():
    """根路径"""
    return {
        "message": "加密货币数据收集API",
        "version": "1.0.0",
        "docs": "/docs",
        "websocket": "/ws"
    }

@app.get("/health")
async def health_check():
    """健康检查"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "version": "1.0.0"
    }

# 认证路由
@app.post("/auth/token", response_model=TokenResponse)
async def login_for_access_token(form_data: LoginForm):
    """获取访问令牌"""
    # 这里应该实现实际的认证逻辑
    # 简化实现，仅作示例
    if form_data.username == "admin" and form_data.password == "admin":
        access_token_expires = timedelta(hours=1)
        access_token = AuthManager.create_access_token(
            data={"sub": form_data.username, "role": "admin"},
            expires_delta=access_token_expires
        )
        return {"access_token": access_token, "token_type": "bearer"}
    else:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误",
            headers={"WWW-Authenticate": "Bearer"},
        )

# 市场数据API
@app.get("/api/v1/markets/tickers", response_model=List[TickerResponse])
async def get_tickers(
    exchange: Optional[str] = None,
    symbol: Optional[str] = None,
    user: dict = Depends(AuthManager.get_current_user)
):
    """获取行情数据"""
    try:
        cache_key = CacheKey(
            prefix="tickers",
            exchange=exchange or "all",
            symbol=symbol or "all",
            data_type="ticker"
        )

        async def query_func():
            # 从交易所管理器获取数据
            tickers = await exchange_manager.get_all_tickers(exchange)
            if symbol:
                tickers = [t for t in tickers if t['symbol'] == symbol]
            return tickers

        result = await cache_manager.get_data(cache_key, query_func)

        if not result.found:
            raise APIError("获取行情数据失败")

        return result.data

    except Exception as e:
        logger.error(f"获取行情数据失败: {e}")
        raise APIError(f"获取行情数据失败: {str(e)}")

@app.get("/api/v1/markets/ohlcv", response_model=List[OHLCVResponse])
async def get_ohlcv(
    exchange: str,
    symbol: str,
    timeframe: str = "1m",
    limit: int = 100,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    user: dict = Depends(AuthManager.get_current_user)
):
    """获取OHLCV数据"""
    try:
        cache_key = CacheKey(
            prefix="ohlcv",
            exchange=exchange,
            symbol=symbol,
            data_type="ohlcv",
            timeframe=timeframe,
            start_time=start_time,
            end_time=end_time
        )

        async def query_func():
            return await exchange_manager.get_ohlcv(
                exchange, symbol, timeframe, limit, start_time, end_time
            )

        result = await cache_manager.get_data(cache_key, query_func)

        if not result.found:
            raise APIError("获取OHLCV数据失败")

        return result.data

    except Exception as e:
        logger.error(f"获取OHLCV数据失败: {e}")
        raise APIError(f"获取OHLCV数据失败: {str(e)}")

@app.get("/api/v1/markets/orderbook", response_model=OrderBookResponse)
async def get_orderbook(
    exchange: str,
    symbol: str,
    limit: int = 100,
    user: dict = Depends(AuthManager.get_current_user)
):
    """获取订单簿数据"""
    try:
        cache_key = CacheKey(
            prefix="orderbook",
            exchange=exchange,
            symbol=symbol,
            data_type="orderbook"
        )

        async def query_func():
            return await exchange_manager.get_orderbook(exchange, symbol, limit)

        result = await cache_manager.get_data(cache_key, query_func)

        if not result.found:
            raise APIError("获取订单簿数据失败")

        return result.data

    except Exception as e:
        logger.error(f"获取订单簿数据失败: {e}")
        raise APIError(f"获取订单簿数据失败: {str(e)}")

@app.get("/api/v1/markets/trades", response_model=List[TradeResponse])
async def get_trades(
    exchange: str,
    symbol: str,
    limit: int = 100,
    user: dict = Depends(AuthManager.get_current_user)
):
    """获取交易数据"""
    try:
        cache_key = CacheKey(
            prefix="trades",
            exchange=exchange,
            symbol=symbol,
            data_type="trade"
        )

        async def query_func():
            return await exchange_manager.get_recent_trades(exchange, symbol, limit)

        result = await cache_manager.get_data(cache_key, query_func)

        if not result.found:
            raise APIError("获取交易数据失败")

        return result.data

    except Exception as e:
        logger.error(f"获取交易数据失败: {e}")
        raise APIError(f"获取交易数据失败: {str(e)}")

# 仓位管理API
@app.get("/api/v1/positions", response_model=List[PositionResponse])
async def get_positions(
    exchange: Optional[str] = None,
    symbol: Optional[str] = None,
    user: dict = Depends(AuthManager.get_current_user)
):
    """获取仓位信息"""
    try:
        positions = await position_manager.get_positions(exchange, symbol)
        return positions

    except Exception as e:
        logger.error(f"获取仓位信息失败: {e}")
        raise APIError(f"获取仓位信息失败: {str(e)}")

@app.get("/api/v1/positions/pnl", response_model=PnLResponse)
async def get_pnl_summary(
    exchange: Optional[str] = None,
    user: dict = Depends(AuthManager.get_current_user)
):
    """获取PnL摘要"""
    try:
        pnl_data = await position_manager.get_pnl_summary(exchange)
        return pnl_data

    except Exception as e:
        logger.error(f"获取PnL摘要失败: {e}")
        raise APIError(f"获取PnL摘要失败: {str(e)}")

# 订单管理API
@app.get("/api/v1/orders", response_model=List[OrderResponse])
async def get_orders(
    exchange: Optional[str] = None,
    symbol: Optional[str] = None,
    status: Optional[str] = None,
    user: dict = Depends(AuthManager.get_current_user)
):
    """获取订单信息"""
    try:
        orders = await order_manager.get_orders(exchange, symbol, status)
        return orders

    except Exception as e:
        logger.error(f"获取订单信息失败: {e}")
        raise APIError(f"获取订单信息失败: {str(e)}")

# 系统管理API
@app.get("/api/v1/system/status", response_model=SystemStatusResponse)
async def get_system_status(user: dict = Depends(AuthManager.get_current_user)):
    """获取系统状态"""
    try:
        cache_stats = await cache_manager.get_cache_stats()
        connection_stats = connection_manager.get_connection_stats()

        return {
            "status": "running",
            "timestamp": datetime.now().isoformat(),
            "cache_stats": cache_stats,
            "connection_stats": connection_stats,
            "version": "1.0.0"
        }

    except Exception as e:
        logger.error(f"获取系统状态失败: {e}")
        raise APIError(f"获取系统状态失败: {str(e)}")

@app.post("/api/v1/system/cache/clear")
async def clear_cache(
    pattern: Optional[str] = None,
    user: dict = Depends(AuthManager.get_current_user)
):
    """清空缓存"""
    try:
        if user.get("role") != "admin":
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="权限不足"
            )

        if pattern:
            await cache_manager.invalidate_pattern(pattern)
        else:
            await cache_manager.clear_all_cache()

        return {"message": "缓存已清空", "pattern": pattern}

    except Exception as e:
        logger.error(f"清空缓存失败: {e}")
        raise APIError(f"清空缓存失败: {str(e)}")

# WebSocket端点
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket端点"""
    client_id = str(uuid.uuid4())

    try:
        await connection_manager.connect(websocket, client_id)

        # 发送欢迎消息
        welcome_message = {
            "type": "welcome",
            "client_id": client_id,
            "timestamp": datetime.now().isoformat(),
            "message": "WebSocket连接建立成功"
        }
        await websocket.send_text(json.dumps(welcome_message))

        # 启动心跳检测
        heartbeat_task = asyncio.create_task(
            send_heartbeat_periodically(client_id)
        )

        try:
            while True:
                # 接收消息
                data = await websocket.receive_text()
                message = json.loads(data)

                # 更新最后心跳时间
                connection_manager.client_metadata[client_id]['last_heartbeat'] = datetime.now()

                # 处理消息
                await handle_websocket_message(client_id, message)

        except WebSocketDisconnect:
            logger.info(f"WebSocket连接断开: {client_id}")
        except Exception as e:
            logger.error(f"WebSocket错误: {e}")
        finally:
            heartbeat_task.cancel()
            await connection_manager.disconnect(client_id)

    except Exception as e:
        logger.error(f"WebSocket连接失败: {e}")
        await websocket.close()

async def handle_websocket_message(client_id: str, message: dict):
    """处理WebSocket消息"""
    try:
        message_type = message.get("type")

        if message_type == "subscribe":
            # 订阅数据
            subscription_type = message.get("subscription_type")
            channel = message.get("channel")

            if subscription_type and channel:
                await connection_manager.subscribe(client_id, subscription_type, channel)

                # 发送订阅确认
                response = {
                    "type": "subscription_confirmed",
                    "subscription_type": subscription_type,
                    "channel": channel,
                    "timestamp": datetime.now().isoformat()
                }
                await connection_manager.send_personal_message(json.dumps(response), client_id)

        elif message_type == "unsubscribe":
            # 取消订阅
            subscription_type = message.get("subscription_type")
            channel = message.get("channel")

            if subscription_type and channel:
                await connection_manager.unsubscribe(client_id, subscription_type, channel)

                # 发送取消订阅确认
                response = {
                    "type": "unsubscription_confirmed",
                    "subscription_type": subscription_type,
                    "channel": channel,
                    "timestamp": datetime.now().isoformat()
                }
                await connection_manager.send_personal_message(json.dumps(response), client_id)

        elif message_type == "heartbeat":
            # 心跳响应
            await connection_manager.send_heartbeat(client_id)

        else:
            # 未知消息类型
            response = {
                "type": "error",
                "message": f"未知的消息类型: {message_type}",
                "timestamp": datetime.now().isoformat()
            }
            await connection_manager.send_personal_message(json.dumps(response), client_id)

    except Exception as e:
        logger.error(f"处理WebSocket消息失败: {e}")
        response = {
            "type": "error",
            "message": f"处理消息失败: {str(e)}",
            "timestamp": datetime.now().isoformat()
        }
        await connection_manager.send_personal_message(json.dumps(response), client_id)

async def send_heartbeat_periodically(client_id: str):
    """定期发送心跳"""
    while True:
        try:
            await asyncio.sleep(connection_manager.heartbeat_interval)
            await connection_manager.send_heartbeat(client_id)
        except Exception as e:
            logger.error(f"发送心跳失败: {e}")
            break

async def heartbeat_monitor():
    """心跳监控"""
    while True:
        try:
            await asyncio.sleep(30)  # 每30秒检查一次
            await connection_manager.check_heartbeats()
        except Exception as e:
            logger.error(f"心跳监控失败: {e}")

# 数据推送函数
async def push_ticker_update(exchange: str, symbol: str, ticker_data: dict):
    """推送行情更新"""
    try:
        message = {
            "type": WebSocketEventType.TICKER_UPDATE.value,
            "exchange": exchange,
            "symbol": symbol,
            "data": ticker_data,
            "timestamp": datetime.now().isoformat()
        }

        await connection_manager.broadcast(
            json.dumps(message),
            SubscriptionType.TICKER.value,
            f"{exchange}_{symbol}"
        )

    except Exception as e:
        logger.error(f"推送行情更新失败: {e}")

async def push_ohlcv_update(exchange: str, symbol: str, timeframe: str, ohlcv_data: dict):
    """推送OHLCV更新"""
    try:
        message = {
            "type": WebSocketEventType.OHLCV_UPDATE.value,
            "exchange": exchange,
            "symbol": symbol,
            "timeframe": timeframe,
            "data": ohlcv_data,
            "timestamp": datetime.now().isoformat()
        }

        await connection_manager.broadcast(
            json.dumps(message),
            SubscriptionType.OHLCV.value,
            f"{exchange}_{symbol}_{timeframe}"
        )

    except Exception as e:
        logger.error(f"推送OHLCV更新失败: {e}")

# 自定义OpenAPI文档
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title="加密货币数据收集API",
        version="1.0.0",
        description="提供加密货币市场数据、仓位信息和订单管理的RESTful API和WebSocket服务",
        routes=app.routes,
    )

    # 添加自定义信息
    openapi_schema["info"]["x-logo"] = {
        "url": "https://example.com/logo.png"
    }

    # 添加服务器信息
    openapi_schema["servers"] = [
        {
            "url": "http://localhost:8000",
            "description": "开发服务器"
        },
        {
            "url": "https://api.example.com",
            "description": "生产服务器"
        }
    ]

    app.openapi_schema = openapi_schema
    return openapi_schema

app.openapi = custom_openapi

# 自定义Swagger UI
@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    """自定义Swagger UI"""
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js",
        swagger_css_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css",
    )

# 启动函数
def main():
    """启动API服务"""
    import uvicorn

    uvicorn.run(
        "src.api.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info",
        workers=1,
        limit_concurrency=1000,
        timeout_keep_alive=30
    )

if __name__ == "__main__":
    main()
```

## 接受标准

### 必须满足的条件
- [ ] 实现完整的RESTful API接口，覆盖所有数据类型
- [ ] 提供高性能的WebSocket实时数据推送服务
- [ ] 实现JWT认证和基于角色的访问控制
- [ ] 提供自动生成的API文档和测试界面
- [ ] 实现请求速率限制和异常处理
- [ ] 支持API监控和性能指标收集
- [ ] 提供WebSocket连接管理和心跳检测
- [ ] 实现数据订阅和推送机制
- [ ] 通过性能测试和安全测试

### 性能要求
- **API响应时间**: < 50ms (P95)
- **WebSocket延迟**: < 10ms (P95)
- **并发连接数**: 支持10,000+并发连接
- **消息吞吐量**: 100,000+ 消息/秒
- **API可用性**: 99.9%
- **内存使用**: < 2GB

### 技术规范
- 使用FastAPI框架
- 实现异步处理架构
- 支持JWT token认证
- 完整的错误处理和日志记录
- 符合REST API设计规范

## 实现步骤

### 第一阶段：基础API架构 (2天)
1. 设计API接口规范
2. 实现基础RESTful API
3. 集成认证和授权系统
4. 添加异常处理和日志记录

### 第二阶段：WebSocket服务 (3天)
1. 实现WebSocket连接管理
2. 开发数据订阅机制
3. 实现实时数据推送
4. 添加心跳检测和连接管理

### 第三阶段：高级功能 (3天)
1. 实现速率限制和缓存
2. 添加API监控和指标
3. 开发文档生成系统
4. 实现数据压缩和优化

### 第四阶段：测试和优化 (2天)
1. 进行功能测试和性能测试
2. 优化API性能和稳定性
3. 完善错误处理和监控
4. 编写技术文档

## 交付物

### 文档
- API接口设计文档
- WebSocket协议文档
- 认证和授权文档
- 部署和运维文档

### 代码
- RESTful API实现
- WebSocket服务实现
- 认证和授权模块
- 监控和指标模块
- 单元测试和集成测试
- 性能测试脚本

### 配置
- API服务配置文件
- 认证配置
- 监控配置
- 部署配置

## 风险和依赖

### 技术风险
- WebSocket连接管理复杂性
- 高并发处理性能瓶颈
- 实时数据推送延迟
- API安全性问题

### 依赖关系
- 依赖于数据收集服务
- 依赖于缓存服务
- 依赖于数据库服务

### 缓解措施
- 实现连接池和负载均衡
- 添加性能监控和自动扩容
- 实现消息队列和重试机制
- 添加安全审计和日志记录

## 验收标准
- API功能完整且符合规范
- WebSocket服务稳定可靠
- 认证和授权系统安全有效
- 系统性能达到要求指标
- 监控和日志功能完善
- 文档齐全且易于理解