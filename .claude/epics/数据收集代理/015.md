---
name: 监控告警系统和仪表板
type: task
epic: 数据收集代理
status: open
priority: 2
created: 2025-09-25T20:20:35Z
estimated: 14 days
assigned: [待分配]
parallelizable: true
dependencies: ["003", "011", "012"]
---

# 任务: 监控告警系统和仪表板

## 任务描述
实现完整的监控告警系统和可视化仪表板，包括Prometheus集成、Grafana仪表板、告警规则配置和多渠道通知机制。通过全方位的系统监控和智能告警，确保数据收集代理的稳定运行和及时故障响应。

## 技术要求

### 核心架构设计

#### Monitoring & Alerting 组件
- **指标收集**: 系统指标、业务指标、性能指标的自动收集
- **告警规则**: 灵活的告警规则配置和阈值管理
- **通知机制**: 多渠道告警通知（邮件、短信、钉钉、Slack等）
- **可视化仪表板**: Grafana仪表板定制和实时数据展示
- **历史分析**: 指标历史数据分析和趋势预测

#### 技术栈
- **监控框架**: Prometheus + Grafana + AlertManager
- **指标库**: Prometheus Client + custom metrics
- **通知服务**: SMTP + Webhook + 企业微信/钉钉API
- **数据存储**: Prometheus TSDB + InfluxDB（可选）
- **日志聚合**: ELK Stack（Elasticsearch + Logstash + Kibana）

### 实现架构

```python
# src/monitoring/monitoring_service.py
import asyncio
import time
import json
import logging
from typing import Dict, List, Optional, Any, Union, Callable
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
import threading
from queue import Queue, Empty
import smtplib
import requests
import httpx
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import jinja2
import yaml
import re
from pathlib import Path

from prometheus_client import (
    Counter, Histogram, Gauge, Summary, CollectorRegistry, push_to_gateway,
    Info, Enum as PrometheusEnum, generate_latest, CONTENT_TYPE_LATEST
)
from prometheus_client.exposition import start_http_server
from prometheus_client.core import GaugeMetricFamily, CounterMetricFamily
from prometheus_client.parser import text_string_to_metric_families

from ..core.config import config
from ..core.logger import get_logger
from ..core.exceptions import MonitoringError, AlertError
from ..managers.exchange_manager import exchange_manager
from ..managers.position_manager import position_manager
from ..managers.order_manager import order_manager
from ..processors.data_processor import data_processor
from ..cache.cache_manager import cache_manager

# 初始化日志
logger = get_logger("monitoring_service")

# 告警级别枚举
class AlertLevel(Enum):
    """告警级别枚举"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"
    EMERGENCY = "emergency"

# 告警状态枚举
class AlertStatus(Enum):
    """告警状态枚举"""
    ACTIVE = "active"
    RESOLVED = "resolved"
    SUPPRESSED = "suppressed"
    ACKNOWLEDGED = "acknowledged"

# 通知渠道枚举
class NotificationChannel(Enum):
    """通知渠道枚举"""
    EMAIL = "email"
    SMS = "sms"
    WEBHOOK = "webhook"
    DINGTALK = "dingtalk"
    SLACK = "slack"
    WECHAT = "wechat"
    TELEGRAM = "telegram"

# 指标类型枚举
class MetricType(Enum):
    """指标类型枚举"""
    COUNTER = "counter"
    GAUGE = "gauge"
    HISTOGRAM = "histogram"
    SUMMARY = "summary"

@dataclass
class AlertRule:
    """告警规则数据类"""
    rule_id: str
    name: str
    description: str
    metric_name: str
    condition: str  # Prometheus表达式
    threshold: float
    duration: timedelta  # 持续时间
    level: AlertLevel
    enabled: bool = True
    notifications: List[NotificationChannel] = field(default_factory=list)
    tags: Dict[str, str] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

@dataclass
class Alert:
    """告警数据类"""
    alert_id: str
    rule_id: str
    name: str
    description: str
    level: AlertLevel
    status: AlertStatus
    value: float
    threshold: float
    triggered_at: datetime
    resolved_at: Optional[datetime] = None
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    notifications_sent: List[str] = field(default_factory=list)

@dataclass
class NotificationTemplate:
    """通知模板数据类"""
    template_id: str
    name: str
    channel: NotificationChannel
    subject_template: str
    body_template: str
    variables: List[str] = field(default_factory=list)
    enabled: bool = True

class MetricsCollector:
    """指标收集器"""

    def __init__(self):
        self.registry = CollectorRegistry()
        self.custom_metrics = {}
        self.system_metrics = {}
        self.business_metrics = {}
        self.collection_interval = config.get("metrics_collection_interval", 15)  # 15秒
        self.collector_active = False

    def create_counter(self, name: str, description: str, labels: List[str] = None) -> Counter:
        """创建Counter指标"""
        try:
            if name not in self.custom_metrics:
                self.custom_metrics[name] = Counter(
                    name, description, labels or [], registry=self.registry
                )
            return self.custom_metrics[name]
        except Exception as e:
            raise MonitoringError(f"创建Counter指标失败: {str(e)}")

    def create_gauge(self, name: str, description: str, labels: List[str] = None) -> Gauge:
        """创建Gauge指标"""
        try:
            if name not in self.custom_metrics:
                self.custom_metrics[name] = Gauge(
                    name, description, labels or [], registry=self.registry
                )
            return self.custom_metrics[name]
        except Exception as e:
            raise MonitoringError(f"创建Gauge指标失败: {str(e)}")

    def create_histogram(self, name: str, description: str, labels: List[str] = None,
                        buckets: List[float] = None) -> Histogram:
        """创建Histogram指标"""
        try:
            if name not in self.custom_metrics:
                self.custom_metrics[name] = Histogram(
                    name, description, labels or [],
                    buckets=buckets or Histogram.DEFAULT_BUCKETS,
                    registry=self.registry
                )
            return self.custom_metrics[name]
        except Exception as e:
            raise MonitoringError(f"创建Histogram指标失败: {str(e)}")

    def create_summary(self, name: str, description: str, labels: List[str] = None) -> Summary:
        """创建Summary指标"""
        try:
            if name not in self.custom_metrics:
                self.custom_metrics[name] = Summary(
                    name, description, labels or [], registry=self.registry
                )
            return self.custom_metrics[name]
        except Exception as e:
            raise MonitoringError(f"创建Summary指标失败: {str(e)}")

    def record_counter(self, name: str, value: float = 1, labels: Dict[str, str] = None):
        """记录Counter指标"""
        try:
            if name in self.custom_metrics:
                metric = self.custom_metrics[name]
                if labels:
                    metric.labels(**labels).inc(value)
                else:
                    metric.inc(value)
        except Exception as e:
            logger.error(f"记录Counter指标失败: {e}")

    def record_gauge(self, name: str, value: float, labels: Dict[str, str] = None):
        """记录Gauge指标"""
        try:
            if name in self.custom_metrics:
                metric = self.custom_metrics[name]
                if labels:
                    metric.labels(**labels).set(value)
                else:
                    metric.set(value)
        except Exception as e:
            logger.error(f"记录Gauge指标失败: {e}")

    def record_histogram(self, name: str, value: float, labels: Dict[str, str] = None):
        """记录Histogram指标"""
        try:
            if name in self.custom_metrics:
                metric = self.custom_metrics[name]
                if labels:
                    metric.labels(**labels).observe(value)
                else:
                    metric.observe(value)
        except Exception as e:
            logger.error(f"记录Histogram指标失败: {e}")

    def record_summary(self, name: str, value: float, labels: Dict[str, str] = None):
        """记录Summary指标"""
        try:
            if name in self.custom_metrics:
                metric = self.custom_metrics[name]
                if labels:
                    metric.labels(**labels).observe(value)
                else:
                    metric.observe(value)
        except Exception as e:
            logger.error(f"记录Summary指标失败: {e}")

    async def collect_system_metrics(self):
        """收集系统指标"""
        try:
            import psutil
            import platform

            # CPU指标
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            self.record_gauge("system_cpu_usage_percent", cpu_percent)
            self.record_gauge("system_cpu_count", cpu_count)

            # 内存指标
            memory = psutil.virtual_memory()
            self.record_gauge("system_memory_usage_percent", memory.percent)
            self.record_gauge("system_memory_total_bytes", memory.total)
            self.record_gauge("system_memory_available_bytes", memory.available)
            self.record_gauge("system_memory_used_bytes", memory.used)

            # 磁盘指标
            disk = psutil.disk_usage('/')
            self.record_gauge("system_disk_usage_percent", disk.percent)
            self.record_gauge("system_disk_total_bytes", disk.total)
            self.record_gauge("system_disk_used_bytes", disk.used)
            self.record_gauge("system_disk_free_bytes", disk.free)

            # 网络指标
            net_io = psutil.net_io_counters()
            self.record_counter("system_network_bytes_sent", net_io.bytes_sent)
            self.record_counter("system_network_bytes_recv", net_io.bytes_recv)

            # 系统信息
            boot_time = datetime.fromtimestamp(psutil.boot_time())
            uptime = datetime.now() - boot_time
            self.record_gauge("system_uptime_seconds", uptime.total_seconds())

        except Exception as e:
            logger.error(f"收集系统指标失败: {e}")

    async def collect_business_metrics(self):
        """收集业务指标"""
        try:
            # 交易所连接指标
            exchange_stats = await exchange_manager.get_connection_stats()
            for exchange_name, stats in exchange_stats.items():
                self.record_gauge(
                    "exchange_connections_total",
                    stats.get("active_connections", 0),
                    {"exchange": exchange_name}
                )
                self.record_gauge(
                    "exchange_request_rate",
                    stats.get("request_rate", 0),
                    {"exchange": exchange_name}
                )

            # 数据收集指标
            collection_stats = await exchange_manager.get_collection_stats()
            self.record_counter(
                "data_collected_total",
                collection_stats.get("total_records", 0)
            )
            self.record_gauge(
                "data_collection_rate",
                collection_stats.get("collection_rate", 0)
            )

            # 仓位指标
            position_stats = await position_manager.get_position_stats()
            self.record_gauge(
                "positions_total",
                position_stats.get("total_positions", 0)
            )
            self.record_gauge(
                "positions_pnl_total",
                position_stats.get("total_pnl", 0)
            )

            # 订单指标
            order_stats = await order_manager.get_order_stats()
            self.record_counter(
                "orders_total",
                order_stats.get("total_orders", 0)
            )
            self.record_gauge(
                "order_execution_rate",
                order_stats.get("execution_rate", 0)
            )

            # 缓存指标
            cache_stats = await cache_manager.get_cache_stats()
            self.record_gauge(
                "cache_hit_rate",
                cache_stats.get("hit_rate", 0)
            )
            self.record_gauge(
                "cache_size_bytes",
                cache_stats.get("memory_usage", 0)
            )

        except Exception as e:
            logger.error(f"收集业务指标失败: {e}")

    async def collect_metrics(self):
        """收集所有指标"""
        try:
            await self.collect_system_metrics()
            await self.collect_business_metrics()

            # 推送到Prometheus网关
            if config.get("prometheus_pushgateway_enabled", False):
                await self.push_metrics_to_gateway()

        except Exception as e:
            logger.error(f"收集指标失败: {e}")

    async def push_metrics_to_gateway(self):
        """推送指标到Prometheus网关"""
        try:
            gateway_url = config.get("prometheus_pushgateway_url")
            if gateway_url:
                push_to_gateway(
                    gateway_url,
                    job="data_collection_agent",
                    registry=self.registry
                )
        except Exception as e:
            logger.error(f"推送指标到网关失败: {e}")

    async def start_collection(self):
        """启动指标收集"""
        self.collector_active = True
        logger.info("指标收集器启动")

        while self.collector_active:
            try:
                await self.collect_metrics()
                await asyncio.sleep(self.collection_interval)
            except Exception as e:
                logger.error(f"指标收集错误: {e}")
                await asyncio.sleep(self.collection_interval)

    async def stop_collection(self):
        """停止指标收集"""
        self.collector_active = False
        logger.info("指标收集器停止")

    def get_metrics(self) -> str:
        """获取指标数据"""
        try:
            return generate_latest(self.registry).decode('utf-8')
        except Exception as e:
            raise MonitoringError(f"获取指标数据失败: {str(e)}")

class AlertManager:
    """告警管理器"""

    def __init__(self):
        self.alert_rules: Dict[str, AlertRule] = {}
        self.active_alerts: Dict[str, Alert] = []
        self.alert_history: List[Alert] = []
        self.notification_manager = NotificationManager()
        self.template_manager = TemplateManager()
        self.check_interval = config.get("alert_check_interval", 30)  # 30秒
        self.alert_suppressions: Dict[str, datetime] = {}
        self.alert_manager_active = False

    def add_alert_rule(self, rule: AlertRule) -> bool:
        """添加告警规则"""
        try:
            self.alert_rules[rule.rule_id] = rule
            logger.info(f"添加告警规则: {rule.name}")
            return True
        except Exception as e:
            logger.error(f"添加告警规则失败: {e}")
            return False

    def remove_alert_rule(self, rule_id: str) -> bool:
        """移除告警规则"""
        try:
            if rule_id in self.alert_rules:
                del self.alert_rules[rule_id]
                logger.info(f"移除告警规则: {rule_id}")
                return True
            return False
        except Exception as e:
            logger.error(f"移除告警规则失败: {e}")
            return False

    def update_alert_rule(self, rule_id: str, **kwargs) -> bool:
        """更新告警规则"""
        try:
            if rule_id in self.alert_rules:
                rule = self.alert_rules[rule_id]
                for key, value in kwargs.items():
                    if hasattr(rule, key):
                        setattr(rule, key, value)
                rule.updated_at = datetime.now()
                logger.info(f"更新告警规则: {rule_id}")
                return True
            return False
        except Exception as e:
            logger.error(f"更新告警规则失败: {e}")
            return False

    async def check_alerts(self):
        """检查告警"""
        try:
            for rule_id, rule in self.alert_rules.items():
                if not rule.enabled:
                    continue

                # 检查是否被抑制
                if rule_id in self.alert_suppressions:
                    if datetime.now() < self.alert_suppressions[rule_id]:
                        continue
                    else:
                        del self.alert_suppressions[rule_id]

                # 查询Prometheus指标
                value = await self._query_prometheus_metric(rule.metric_name)

                if value is not None:
                    # 检查条件
                    if self._evaluate_condition(value, rule.condition, rule.threshold):
                        # 触发告警
                        await self._trigger_alert(rule, value)
                    else:
                        # 检查是否需要解决告警
                        await self._resolve_alert(rule_id)

        except Exception as e:
            logger.error(f"检查告警失败: {e}")

    async def _query_prometheus_metric(self, metric_name: str) -> Optional[float]:
        """查询Prometheus指标"""
        try:
            prometheus_url = config.get("prometheus_url", "http://localhost:9090")
            query_url = f"{prometheus_url}/api/v1/query"

            params = {
                "query": metric_name,
                "time": datetime.now().timestamp()
            }

            async with httpx.AsyncClient() as client:
                response = await client.get(query_url, params=params)
                response.raise_for_status()

                data = response.json()
                if data.get("status") == "success":
                    result = data.get("data", {}).get("result", [])
                    if result:
                        return float(result[0].get("value", [0, 0])[1])

            return None

        except Exception as e:
            logger.error(f"查询Prometheus指标失败: {e}")
            return None

    def _evaluate_condition(self, value: float, condition: str, threshold: float) -> bool:
        """评估条件"""
        try:
            if condition == ">":
                return value > threshold
            elif condition == ">=":
                return value >= threshold
            elif condition == "<":
                return value < threshold
            elif condition == "<=":
                return value <= threshold
            elif condition == "==":
                return value == threshold
            elif condition == "!=":
                return value != threshold
            else:
                return False
        except Exception as e:
            logger.error(f"评估条件失败: {e}")
            return False

    async def _trigger_alert(self, rule: AlertRule, value: float):
        """触发告警"""
        try:
            # 检查是否已有活跃告警
            existing_alert = None
            for alert in self.active_alerts:
                if alert.rule_id == rule.rule_id and alert.status == AlertStatus.ACTIVE:
                    existing_alert = alert
                    break

            if not existing_alert:
                # 创建新告警
                alert_id = f"{rule.rule_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                alert = Alert(
                    alert_id=alert_id,
                    rule_id=rule.rule_id,
                    name=rule.name,
                    description=rule.description,
                    level=rule.level,
                    status=AlertStatus.ACTIVE,
                    value=value,
                    threshold=rule.threshold,
                    triggered_at=datetime.now()
                )

                self.active_alerts.append(alert)
                self.alert_history.append(alert)

                logger.warning(f"触发告警: {alert.name} - {alert.description}")

                # 发送通知
                await self._send_alert_notifications(alert)

        except Exception as e:
            logger.error(f"触发告警失败: {e}")

    async def _resolve_alert(self, rule_id: str):
        """解决告警"""
        try:
            for alert in self.active_alerts:
                if alert.rule_id == rule_id and alert.status == AlertStatus.ACTIVE:
                    alert.status = AlertStatus.RESOLVED
                    alert.resolved_at = datetime.now()

                    logger.info(f"解决告警: {alert.name}")

                    # 发送解决通知
                    await self._send_alert_notifications(alert)

                    break

        except Exception as e:
            logger.error(f"解决告警失败: {e}")

    async def _send_alert_notifications(self, alert: Alert):
        """发送告警通知"""
        try:
            # 获取告警规则
            rule = self.alert_rules.get(alert.rule_id)
            if not rule:
                return

            # 为每个通知渠道发送通知
            for channel in rule.notifications:
                try:
                    await self.notification_manager.send_notification(
                        channel, alert, rule
                    )
                    alert.notifications_sent.append(channel.value)
                except Exception as e:
                    logger.error(f"发送{channel.value}通知失败: {e}")

        except Exception as e:
            logger.error(f"发送告警通知失败: {e}")

    async def start_alert_manager(self):
        """启动告警管理器"""
        self.alert_manager_active = True
        logger.info("告警管理器启动")

        while self.alert_manager_active:
            try:
                await self.check_alerts()
                await asyncio.sleep(self.check_interval)
            except Exception as e:
                logger.error(f"告警管理器错误: {e}")
                await asyncio.sleep(self.check_interval)

    async def stop_alert_manager(self):
        """停止告警管理器"""
        self.alert_manager_active = False
        logger.info("告警管理器停止")

    def get_active_alerts(self) -> List[Alert]:
        """获取活跃告警"""
        return [alert for alert in self.active_alerts if alert.status == AlertStatus.ACTIVE]

    def get_alert_history(self, limit: int = 100) -> List[Alert]:
        """获取告警历史"""
        return self.alert_history[-limit:]

    def acknowledge_alert(self, alert_id: str, acknowledged_by: str) -> bool:
        """确认告警"""
        try:
            for alert in self.active_alerts:
                if alert.alert_id == alert_id:
                    alert.status = AlertStatus.ACKNOWLEDGED
                    alert.acknowledged_at = datetime.now()
                    alert.acknowledged_by = acknowledged_by
                    logger.info(f"确认告警: {alert_id} by {acknowledged_by}")
                    return True
            return False
        except Exception as e:
            logger.error(f"确认告警失败: {e}")
            return False

    def suppress_alert(self, rule_id: str, duration: timedelta) -> bool:
        """抑制告警"""
        try:
            self.alert_suppressions[rule_id] = datetime.now() + duration
            logger.info(f"抑制告警: {rule_id} for {duration}")
            return True
        except Exception as e:
            logger.error(f"抑制告警失败: {e}")
            return False

class NotificationManager:
    """通知管理器"""

    def __init__(self):
        self.email_config = config.get("email", {})
        self.webhook_config = config.get("webhook", {})
        self.dingtalk_config = config.get("dingtalk", {})
        self.slack_config = config.get("slack", {})
        self.template_manager = TemplateManager()

    async def send_notification(self, channel: NotificationChannel, alert: Alert, rule: AlertRule):
        """发送通知"""
        try:
            if channel == NotificationChannel.EMAIL:
                await self._send_email_notification(alert, rule)
            elif channel == NotificationChannel.WEBHOOK:
                await self._send_webhook_notification(alert, rule)
            elif channel == NotificationChannel.DINGTALK:
                await self._send_dingtalk_notification(alert, rule)
            elif channel == NotificationChannel.SLACK:
                await self._send_slack_notification(alert, rule)
            else:
                logger.warning(f"不支持的通知渠道: {channel}")

        except Exception as e:
            logger.error(f"发送{channel.value}通知失败: {e}")

    async def _send_email_notification(self, alert: Alert, rule: AlertRule):
        """发送邮件通知"""
        try:
            if not self.email_config:
                return

            # 获取模板
            template = self.template_manager.get_template("email_alert")
            if not template:
                return

            # 渲染模板
            subject = self.template_manager.render_template(
                template.subject_template,
                {
                    "alert": alert,
                    "rule": rule,
                    "timestamp": datetime.now()
                }
            )

            body = self.template_manager.render_template(
                template.body_template,
                {
                    "alert": alert,
                    "rule": rule,
                    "timestamp": datetime.now()
                }
            )

            # 创建邮件
            msg = MIMEMultipart()
            msg['From'] = self.email_config.get("from")
            msg['To'] = ", ".join(self.email_config.get("to", []))
            msg['Subject'] = subject

            msg.attach(MIMEText(body, 'html'))

            # 发送邮件
            with smtplib.SMTP(
                self.email_config.get("smtp_server"),
                self.email_config.get("smtp_port", 587)
            ) as server:
                if self.email_config.get("use_tls", True):
                    server.starttls()

                if self.email_config.get("username") and self.email_config.get("password"):
                    server.login(
                        self.email_config.get("username"),
                        self.email_config.get("password")
                    )

                server.send_message(msg)

            logger.info(f"发送邮件通知: {alert.name}")

        except Exception as e:
            logger.error(f"发送邮件通知失败: {e}")

    async def _send_webhook_notification(self, alert: Alert, rule: AlertRule):
        """发送Webhook通知"""
        try:
            if not self.webhook_config.get("url"):
                return

            # 构建通知内容
            payload = {
                "alert_id": alert.alert_id,
                "rule_name": rule.name,
                "alert_name": alert.name,
                "description": alert.description,
                "level": alert.level.value,
                "status": alert.status.value,
                "value": alert.value,
                "threshold": alert.threshold,
                "triggered_at": alert.triggered_at.isoformat(),
                "timestamp": datetime.now().isoformat()
            }

            # 发送Webhook
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.webhook_config["url"],
                    json=payload,
                    headers=self.webhook_config.get("headers", {}),
                    timeout=30
                )
                response.raise_for_status()

            logger.info(f"发送Webhook通知: {alert.name}")

        except Exception as e:
            logger.error(f"发送Webhook通知失败: {e}")

    async def _send_dingtalk_notification(self, alert: Alert, rule: AlertRule):
        """发送钉钉通知"""
        try:
            if not self.dingtalk_config.get("webhook_url"):
                return

            # 构建钉钉消息
            message = {
                "msgtype": "markdown",
                "markdown": {
                    "title": f"🚨 {alert.level.value.upper()} - {alert.name}",
                    "text": f"""
## {alert.level.value.upper()} - {alert.name}

**描述**: {alert.description}

**级别**: {alert.level.value}
**状态**: {alert.status.value}
**数值**: {alert.value}
**阈值**: {alert.threshold}

**触发时间**: {alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S')}

---
*来自数据收集代理监控系统*
                    """
                }
            }

            # 发送钉钉消息
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.dingtalk_config["webhook_url"],
                    json=message,
                    timeout=30
                )
                response.raise_for_status()

            logger.info(f"发送钉钉通知: {alert.name}")

        except Exception as e:
            logger.error(f"发送钉钉通知失败: {e}")

    async def _send_slack_notification(self, alert: Alert, rule: AlertRule):
        """发送Slack通知"""
        try:
            if not self.slack_config.get("webhook_url"):
                return

            # 构建Slack消息
            color = {
                AlertLevel.INFO: "good",
                AlertLevel.WARNING: "warning",
                AlertLevel.ERROR: "danger",
                AlertLevel.CRITICAL: "danger",
                AlertLevel.EMERGENCY: "danger"
            }.get(alert.level, "warning")

            message = {
                "attachments": [
                    {
                        "color": color,
                        "title": f"{alert.level.value.upper()} - {alert.name}",
                        "text": alert.description,
                        "fields": [
                            {"title": "级别", "value": alert.level.value, "short": True},
                            {"title": "状态", "value": alert.status.value, "short": True},
                            {"title": "数值", "value": str(alert.value), "short": True},
                            {"title": "阈值", "value": str(alert.threshold), "short": True},
                            {"title": "触发时间", "value": alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S'), "short": False}
                        ],
                        "footer": "数据收集代理监控系统",
                        "ts": int(alert.triggered_at.timestamp())
                    }
                ]
            }

            # 发送Slack消息
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.slack_config["webhook_url"],
                    json=message,
                    timeout=30
                )
                response.raise_for_status()

            logger.info(f"发送Slack通知: {alert.name}")

        except Exception as e:
            logger.error(f"发送Slack通知失败: {e}")

class TemplateManager:
    """模板管理器"""

    def __init__(self):
        self.templates: Dict[str, NotificationTemplate] = {}
        self.jinja_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader("templates"),
            autoescape=True
        )
        self._load_default_templates()

    def _load_default_templates(self):
        """加载默认模板"""
        # 邮件告警模板
        self.templates["email_alert"] = NotificationTemplate(
            template_id="email_alert",
            name="邮件告警模板",
            channel=NotificationChannel.EMAIL,
            subject_template="🚨 {{ alert.level.value.upper() }} - {{ alert.name }}",
            body_template="""
            <html>
            <body>
                <h2>{{ alert.level.value.upper() }} - {{ alert.name }}</h2>
                <p><strong>描述:</strong> {{ alert.description }}</p>
                <p><strong>级别:</strong> {{ alert.level.value }}</p>
                <p><strong>状态:</strong> {{ alert.status.value }}</p>
                <p><strong>数值:</strong> {{ alert.value }}</p>
                <p><strong>阈值:</strong> {{ alert.threshold }}</p>
                <p><strong>触发时间:</strong> {{ alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S') }}</p>
                <hr>
                <p><em>来自数据收集代理监控系统</em></p>
            </body>
            </html>
            """,
            variables=["alert", "rule", "timestamp"]
        )

    def add_template(self, template: NotificationTemplate) -> bool:
        """添加模板"""
        try:
            self.templates[template.template_id] = template
            logger.info(f"添加通知模板: {template.name}")
            return True
        except Exception as e:
            logger.error(f"添加通知模板失败: {e}")
            return False

    def get_template(self, template_id: str) -> Optional[NotificationTemplate]:
        """获取模板"""
        return self.templates.get(template_id)

    def render_template(self, template_content: str, context: Dict[str, Any]) -> str:
        """渲染模板"""
        try:
            template = self.jinja_env.from_string(template_content)
            return template.render(**context)
        except Exception as e:
            logger.error(f"渲染模板失败: {e}")
            return template_content

class DashboardManager:
    """仪表板管理器"""

    def __init__(self):
        self.grafana_config = config.get("grafana", {})
        self.dashboards: Dict[str, Dict[str, Any]] = {}
        self._create_default_dashboards()

    def _create_default_dashboards(self):
        """创建默认仪表板"""
        # 系统监控仪表板
        self.dashboards["system_monitoring"] = {
            "title": "系统监控",
            "description": "系统资源使用情况监控",
            "panels": [
                {
                    "title": "CPU使用率",
                    "type": "graph",
                    "targets": ["system_cpu_usage_percent"],
                    "description": "CPU使用率监控"
                },
                {
                    "title": "内存使用率",
                    "type": "graph",
                    "targets": ["system_memory_usage_percent"],
                    "description": "内存使用率监控"
                },
                {
                    "title": "磁盘使用率",
                    "type": "graph",
                    "targets": ["system_disk_usage_percent"],
                    "description": "磁盘使用率监控"
                }
            ]
        }

        # 业务监控仪表板
        self.dashboards["business_monitoring"] = {
            "title": "业务监控",
            "description": "业务数据收集监控",
            "panels": [
                {
                    "title": "数据收集率",
                    "type": "graph",
                    "targets": ["data_collection_rate"],
                    "description": "数据收集速率监控"
                },
                {
                    "title": "交易所连接数",
                    "type": "graph",
                    "targets": ["exchange_connections_total"],
                    "description": "交易所连接数监控"
                },
                {
                    "title": "缓存命中率",
                    "type": "graph",
                    "targets": ["cache_hit_rate"],
                    "description": "缓存命中率监控"
                }
            ]
        }

        # 告警仪表板
        self.dashboards["alert_dashboard"] = {
            "title": "告警中心",
            "description": "系统告警状态监控",
            "panels": [
                {
                    "title": "活跃告警",
                    "type": "stat",
                    "targets": ["active_alerts_total"],
                    "description": "当前活跃告警数量"
                },
                {
                    "title": "告警历史",
                    "type": "table",
                    "targets": ["alert_history"],
                    "description": "告警历史记录"
                }
            ]
        }

    def create_dashboard(self, dashboard_id: str, title: str, panels: List[Dict[str, Any]]) -> bool:
        """创建仪表板"""
        try:
            self.dashboards[dashboard_id] = {
                "title": title,
                "panels": panels,
                "created_at": datetime.now()
            }
            logger.info(f"创建仪表板: {title}")
            return True
        except Exception as e:
            logger.error(f"创建仪表板失败: {e}")
            return False

    def get_dashboard(self, dashboard_id: str) -> Optional[Dict[str, Any]]:
        """获取仪表板"""
        return self.dashboards.get(dashboard_id)

    def list_dashboards(self) -> List[Dict[str, Any]]:
        """列出所有仪表板"""
        return [
            {"id": dashboard_id, **dashboard}
            for dashboard_id, dashboard in self.dashboards.items()
        ]

    def export_to_grafana(self, dashboard_id: str) -> bool:
        """导出到Grafana"""
        try:
            if not self.grafana_config:
                return False

            dashboard = self.dashboards.get(dashboard_id)
            if not dashboard:
                return False

            # 构建Grafana仪表板JSON
            grafana_dashboard = {
                "dashboard": {
                    "id": None,
                    "title": dashboard["title"],
                    "description": dashboard.get("description", ""),
                    "panels": self._convert_to_grafana_panels(dashboard["panels"]),
                    "time": {
                        "from": "now-1h",
                        "to": "now"
                    },
                    "refresh": "30s"
                },
                "overwrite": True
            }

            # 发送到Grafana
            grafana_url = f"{self.grafana_config['url']}/api/dashboards/db"
            headers = {
                "Authorization": f"Bearer {self.grafana_config['api_key']}",
                "Content-Type": "application/json"
            }

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    grafana_url,
                    json=grafana_dashboard,
                    headers=headers
                )
                response.raise_for_status()

            logger.info(f"导出仪表板到Grafana: {dashboard_id}")
            return True

        except Exception as e:
            logger.error(f"导出仪表板到Grafana失败: {e}")
            return False

    def _convert_to_grafana_panels(self, panels: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """转换为Grafana面板格式"""
        grafana_panels = []

        for i, panel in enumerate(panels):
            grafana_panel = {
                "id": i + 1,
                "title": panel["title"],
                "type": panel.get("type", "graph"),
                "description": panel.get("description", ""),
                "targets": []
            }

            for target in panel.get("targets", []):
                grafana_panel["targets"].append({
                    "expr": target,
                    "legendFormat": target
                })

            grafana_panels.append(grafana_panel)

        return grafana_panels

# 全局实例
metrics_collector = MetricsCollector()
alert_manager = AlertManager()
dashboard_manager = DashboardManager()

# 启动监控服务
async def start_monitoring_service():
    """启动监控服务"""
    logger.info("启动监控服务...")

    # 启动指标收集器
    collector_task = asyncio.create_task(metrics_collector.start_collection())

    # 启动告警管理器
    alert_task = asyncio.create_task(alert_manager.start_alert_manager())

    # 启动Prometheus指标服务器
    prometheus_port = config.get("prometheus_port", 8000)
    start_http_server(prometheus_port)

    logger.info(f"监控服务启动完成，Prometheus端口: {prometheus_port}")

    return collector_task, alert_task

# 初始化函数
async def initialize_monitoring_service():
    """初始化监控服务"""
    logger.info("初始化监控服务...")

    # 加载告警规则
    await load_alert_rules()

    # 启动监控服务
    await start_monitoring_service()

    logger.info("监控服务初始化完成")

async def load_alert_rules():
    """加载告警规则"""
    try:
        # 创建默认告警规则
        default_rules = [
            AlertRule(
                rule_id="cpu_usage_high",
                name="CPU使用率过高",
                description="CPU使用率超过80%",
                metric_name="system_cpu_usage_percent",
                condition=">",
                threshold=80.0,
                duration=timedelta(minutes=5),
                level=AlertLevel.WARNING,
                notifications=[NotificationChannel.EMAIL, NotificationChannel.DINGTALK]
            ),
            AlertRule(
                rule_id="memory_usage_high",
                name="内存使用率过高",
                description="内存使用率超过90%",
                metric_name="system_memory_usage_percent",
                condition=">",
                threshold=90.0,
                duration=timedelta(minutes=5),
                level=AlertLevel.ERROR,
                notifications=[NotificationChannel.EMAIL, NotificationChannel.DINGTALK]
            ),
            AlertRule(
                rule_id="data_collection_rate_low",
                name="数据收集速率过低",
                description="数据收集速率低于预期",
                metric_name="data_collection_rate",
                condition="<",
                threshold=100.0,
                duration=timedelta(minutes=10),
                level=AlertLevel.WARNING,
                notifications=[NotificationChannel.EMAIL]
            )
        ]

        for rule in default_rules:
            alert_manager.add_alert_rule(rule)

        logger.info(f"加载了 {len(default_rules)} 个默认告警规则")

    except Exception as e:
        logger.error(f"加载告警规则失败: {e}")

if __name__ == "__main__":
    # 示例使用
    import asyncio

    async def main():
        await initialize_monitoring_service()

        # 保持运行
        try:
            while True:
                await asyncio.sleep(60)
        except KeyboardInterrupt:
            logger.info("监控服务停止")

    asyncio.run(main())
```

## 接受标准

### 必须满足的条件
- [ ] 实现完整的Prometheus指标收集系统
- [ ] 支持多种告警规则配置和条件评估
- [ ] 提供多渠道告警通知机制
- [ ] 创建Grafana可视化仪表板
- [ ] 实现系统指标和业务指标收集
- [ ] 支持告警确认和抑制功能
- [ ] 提供告警历史记录和统计
- [ ] 实现模板化通知系统
- [ ] 支持AlertManager集成
- [ ] 通过性能测试和安全测试

### 性能要求
- **指标收集延迟**: < 1秒
- **告警响应时间**: < 5秒
- **通知发送延迟**: < 10秒
- **仪表板刷新频率**: 30秒
- **系统资源占用**: < 5% CPU, < 1GB内存
- **并发处理能力**: 支持1000+指标/秒

### 技术规范
- 使用Prometheus作为指标存储
- 实现异步处理架构
- 支持分布式部署
- 完整的错误处理和日志记录
- 符合监控最佳实践

## 实现步骤

### 第一阶段：基础监控架构 (3天)
1. 实现Prometheus指标收集
2. 创建基础系统指标收集
3. 实现业务指标收集
4. 添加指标推送机制

### 第二阶段：告警系统 (4天)
1. 实现告警规则管理
2. 开发条件评估引擎
3. 创建告警触发机制
4. 添加告警历史记录

### 第三阶段：通知系统 (3天)
1. 实现多渠道通知机制
2. 开发模板化通知系统
3. 集成邮件、钉钉、Slack等
4. 添加通知重试机制

### 第四阶段：仪表板和集成 (4天)
1. 创建Grafana仪表板
2. 集成AlertManager
3. 实现告警确认和抑制
4. 完善监控配置和文档

## 交付物

### 文档
- 监控系统架构文档
- 告警规则配置指南
- 通知系统配置文档
- Grafana仪表板使用指南

### 代码
- 指标收集模块
- 告警管理模块
- 通知管理模块
- 仪表板管理模块
- 单元测试和集成测试
- 性能测试脚本

### 配置
- Prometheus配置文件
- Grafana仪表板配置
- 告警规则配置
- 通知渠道配置
- AlertManager配置

## 风险和依赖

### 技术风险
- Prometheus性能瓶颈
- 告警规则复杂性
- 通知渠道可靠性
- 仪表板定制复杂性

### 依赖关系
- 依赖于Prometheus服务器
- 依赖于Grafana服务器
- 依赖于AlertManager
- 依赖于外部通知服务

### 缓解措施
- 实现指标采样和聚合
- 添加告警规则验证
- 实现通知重试机制
- 提供仪表板模板库

## 验收标准
- 监控指标完整且准确
- 告警系统灵敏可靠
- 通知机制稳定及时
- 仪表板展示清晰
- 系统性能达到要求
- 配置灵活易于维护
- 文档齐全且易懂