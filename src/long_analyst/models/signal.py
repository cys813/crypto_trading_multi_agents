"""
Signal models for the Long Analyst Agent.

Defines the structure and types of trading signals generated by the analysis.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Any, Optional, List
import uuid


class SignalType(Enum):
    """Types of trading signals."""
    STRONG_BUY = "strong_buy"
    BUY = "buy"
    MODERATE_BUY = "moderate_buy"
    HOLD = "hold"
    NEUTRAL = "neutral"
    SELL = "sell"
    STRONG_SELL = "strong_sell"


class SignalStrength(Enum):
    """Strength levels for trading signals."""
    VERY_WEAK = 0.1
    WEAK = 0.3
    MODERATE = 0.5
    STRONG = 0.7
    VERY_STRONG = 0.9
    EXTREME = 1.0


class SignalCategory(Enum):
    """Categories of signal sources."""
    TECHNICAL = "technical"
    FUNDAMENTAL = "fundamental"
    SENTIMENT = "sentiment"
    LLM_ENHANCED = "llm_enhanced"
    COMBINED = "combined"


@dataclass
class SignalSource:
    """Source of a trading signal."""
    category: SignalCategory
    name: str
    weight: float = 1.0
    confidence: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Signal:
    """
    Trading signal generated by the Long Analyst Agent.

    This represents a complete trading signal with all necessary information
    for decision making and risk management.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    symbol: str = ""
    signal_type: SignalType = SignalType.NEUTRAL
    strength: SignalStrength = SignalStrength.MODERATE
    timestamp: float = field(default_factory=lambda: datetime.now().timestamp())
    expiry_time: Optional[float] = None
    price_target: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    timeframe: str = "1h"

    # Analysis dimensions
    sources: List[SignalSource] = field(default_factory=list)
    technical_score: float = 0.0
    fundamental_score: float = 0.0
    sentiment_score: float = 0.0
    llm_score: float = 0.0
    combined_score: float = 0.0

    # Risk metrics
    risk_level: float = 0.5  # 0.0 to 1.0
    confidence: float = 0.5  # 0.0 to 1.0
    win_probability: float = 0.5  # 0.0 to 1.0
    expected_return: float = 0.0  # Percentage
    max_drawdown: float = 0.0  # Percentage

    # Metadata
    reasoning: str = ""
    key_indicators: Dict[str, float] = field(default_factory=dict)
    market_conditions: Dict[str, str] = field(default_factory=dict)
    tags: List[str] = field(default_factory=list)

    # Performance tracking
    is_active: bool = True
    was_triggered: bool = False
    outcome: Optional[str] = None  # "profit", "loss", "breakeven"
    actual_return: Optional[float] = None
    holding_period: Optional[float] = None  # In hours

    def __post_init__(self):
        """Validate and initialize signal data."""
        if not self.symbol:
            raise ValueError("Signal symbol cannot be empty")

        if self.expiry_time is None:
            # Default expiry: 24 hours
            self.expiry_time = self.timestamp + (24 * 3600)

        # Validate scores
        for score_name in ["technical_score", "fundamental_score", "sentiment_score", "llm_score", "combined_score"]:
            score = getattr(self, score_name)
            if not (0.0 <= score <= 1.0):
                raise ValueError(f"{score_name} must be between 0.0 and 1.0")

        # Validate risk metrics
        for metric_name in ["risk_level", "confidence", "win_probability"]:
            metric = getattr(self, metric_name)
            if not (0.0 <= metric <= 1.0):
                raise ValueError(f"{metric_name} must be between 0.0 and 1.0")

    @property
    def is_expired(self) -> bool:
        """Check if signal has expired."""
        return datetime.now().timestamp() > self.expiry_time

    @property
    def time_to_expiry(self) -> float:
        """Get time remaining until expiry in seconds."""
        return max(0, self.expiry_time - datetime.now().timestamp())

    @property
    def age_hours(self) -> float:
        """Get signal age in hours."""
        return (datetime.now().timestamp() - self.timestamp) / 3600

    def should_trigger(self, current_price: float) -> bool:
        """
        Determine if signal should be triggered based on current price.

        Args:
            current_price: Current market price

        Returns:
            True if signal should be triggered
        """
        if not self.is_active or self.is_expired:
            return False

        # For buy signals, check if price is at or below target
        if self.signal_type in [SignalType.BUY, SignalType.MODERATE_BUY, SignalType.STRONG_BUY]:
            return current_price <= (self.price_target or float('inf'))

        # For sell signals, check if price is at or above target
        if self.signal_type in [SignalType.SELL, SignalType.STRONG_SELL]:
            return current_price >= (self.price_target or 0)

        return False

    def calculate_risk_reward_ratio(self, current_price: float) -> Optional[float]:
        """
        Calculate risk/reward ratio.

        Args:
            current_price: Current market price

        Returns:
            Risk/reward ratio or None if not calculable
        """
        if not self.stop_loss or not self.take_profit:
            return None

        if self.signal_type in [SignalType.BUY, SignalType.MODERATE_BUY, SignalType.STRONG_BUY]:
            risk = current_price - self.stop_loss
            reward = self.take_profit - current_price
        elif self.signal_type in [SignalType.SELL, SignalType.STRONG_SELL]:
            risk = self.stop_loss - current_price
            reward = current_price - self.take_profit
        else:
            return None

        return reward / risk if risk > 0 else None

    def update_outcome(self, outcome: str, actual_return: float, holding_period: float):
        """
        Update signal outcome after execution.

        Args:
            outcome: "profit", "loss", or "breakeven"
            actual_return: Actual return percentage
            holding_period: Holding period in hours
        """
        self.outcome = outcome
        self.actual_return = actual_return
        self.holding_period = holding_period
        self.is_active = False
        self.was_triggered = True

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for serialization."""
        return {
            "id": self.id,
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "strength": self.strength.value,
            "timestamp": self.timestamp,
            "expiry_time": self.expiry_time,
            "price_target": self.price_target,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "timeframe": self.timeframe,
            "sources": [
                {
                    "category": source.category.value,
                    "name": source.name,
                    "weight": source.weight,
                    "confidence": source.confidence,
                    "metadata": source.metadata
                }
                for source in self.sources
            ],
            "technical_score": self.technical_score,
            "fundamental_score": self.fundamental_score,
            "sentiment_score": self.sentiment_score,
            "llm_score": self.llm_score,
            "combined_score": self.combined_score,
            "risk_level": self.risk_level,
            "confidence": self.confidence,
            "win_probability": self.win_probability,
            "expected_return": self.expected_return,
            "max_drawdown": self.max_drawdown,
            "reasoning": self.reasoning,
            "key_indicators": self.key_indicators,
            "market_conditions": self.market_conditions,
            "tags": self.tags,
            "is_active": self.is_active,
            "was_triggered": self.was_triggered,
            "outcome": self.outcome,
            "actual_return": self.actual_return,
            "holding_period": self.holding_period
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Signal":
        """Create signal from dictionary."""
        sources = [
            SignalSource(
                category=SignalCategory(source_data["category"]),
                name=source_data["name"],
                weight=source_data.get("weight", 1.0),
                confidence=source_data.get("confidence", 0.0),
                metadata=source_data.get("metadata", {})
            )
            for source_data in data.get("sources", [])
        ]

        return cls(
            id=data["id"],
            symbol=data["symbol"],
            signal_type=SignalType(data["signal_type"]),
            strength=SignalStrength(data["strength"]),
            timestamp=data["timestamp"],
            expiry_time=data.get("expiry_time"),
            price_target=data.get("price_target"),
            stop_loss=data.get("stop_loss"),
            take_profit=data.get("take_profit"),
            timeframe=data.get("timeframe", "1h"),
            sources=sources,
            technical_score=data.get("technical_score", 0.0),
            fundamental_score=data.get("fundamental_score", 0.0),
            sentiment_score=data.get("sentiment_score", 0.0),
            llm_score=data.get("llm_score", 0.0),
            combined_score=data.get("combined_score", 0.0),
            risk_level=data.get("risk_level", 0.5),
            confidence=data.get("confidence", 0.5),
            win_probability=data.get("win_probability", 0.5),
            expected_return=data.get("expected_return", 0.0),
            max_drawdown=data.get("max_drawdown", 0.0),
            reasoning=data.get("reasoning", ""),
            key_indicators=data.get("key_indicators", {}),
            market_conditions=data.get("market_conditions", {}),
            tags=data.get("tags", []),
            is_active=data.get("is_active", True),
            was_triggered=data.get("was_triggered", False),
            outcome=data.get("outcome"),
            actual_return=data.get("actual_return"),
            holding_period=data.get("holding_period")
        )

    def __str__(self) -> str:
        """String representation of the signal."""
        return f"Signal({self.symbol} {self.signal_type.value} strength={self.strength.value:.2f})"

    def __repr__(self) -> str:
        """Detailed string representation."""
        return (f"Signal(id={self.id[:8]}..., symbol={self.symbol}, "
                f"type={self.signal_type.value}, strength={self.strength.value:.2f}, "
                f"confidence={self.confidence:.2f})")