---
name: PnL计算和风险评估功能
type: task
epic: 数据收集代理
status: open
priority: 2
created: 2025-09-25T20:20:35Z
estimated: 8 days
assigned: [待分配]
parallelizable: true
dependencies: ["007", "008"]
---

# 任务: PnL计算和风险评估功能

## 任务描述
实现完整的PnL计算体系和风险评估机制，提供实时PnL计算、风险指标、预警机制和统计分析，为交易决策提供全面的风险管理和收益分析支持。

## 技术要求

### 核心架构设计

#### PnL & Risk Management 组件
- **实时PnL计算**: 准确计算未实现盈亏、已实现盈亏和总盈亏
- **风险指标计算**: 计算各种风险指标（VaR、最大回撤、夏普比率等）
- **预警机制**: 基于风险阈值的自动预警和通知
- **统计分析**: 提供历史PnL分析和风险统计
- **报告生成**: 自动生成PnL和风险报告

#### 技术栈
- **核心库**: Python 3.8+ + AsyncIO
- **计算**: NumPy + Pandas + SciPy (统计计算)
- **数据库**: PostgreSQL + Redis (数据存储和缓存)
- **可视化**: Matplotlib + Plotly (可选，用于报告)
- **监控**: Prometheus指标收集

### 实现架构

```python
# src/risk/pnl_calculator.py
import asyncio
import time
from typing import Dict, List, Optional, Any, Callable, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
import numpy as np
import pandas as pd
from scipy import stats
import logging
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_
import json

from ..core.config import config
from ..core.logger import get_logger
from ..core.metrics import metrics
from ..core.exceptions import PnlError, RiskError
from ..managers.position_manager import position_manager, PositionInfo
from ..managers.order_manager import order_manager, OrderInfo
from ..storage.postgresql import get_db_session
from ..storage.redis import redis_client
from ..models.pnl import PnlRecord, RiskMetric, RiskAlert

class RiskLevel(Enum):
    """风险等级枚举"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class AlertType(Enum):
    """告警类型枚举"""
    DRAWDOWN = "drawdown"
    CONCENTRATION = "concentration"
    LEVERAGE = "leverage"
    VOLATILITY = "volatility"
    LIQUIDATION = "liquidation"
    PERFORMANCE = "performance"

@dataclass
class PnlBreakdown:
    """PnL分解"""
    total_unrealized_pnl: Decimal
    total_realized_pnl: Decimal
    total_pnl: Decimal
    daily_pnl: Decimal
    weekly_pnl: Decimal
    monthly_pnl: Decimal
    pnl_by_exchange: Dict[str, Decimal]
    pnl_by_symbol: Dict[str, Decimal]
    pnl_by_strategy: Dict[str, Decimal]
    performance_metrics: Dict[str, float]

@dataclass
class RiskMetrics:
    """风险指标"""
    portfolio_value: Decimal
    total_exposure: Decimal
    net_exposure: Decimal
    max_drawdown: float
    current_drawdown: float
    sharpe_ratio: float
    sortino_ratio: float
    beta: float
    alpha: float
    volatility_daily: float
    volatility_weekly: float
    value_at_risk_95: float  # 95% VaR
    value_at_risk_99: float  # 99% VaR
    expected_shortfall: float
    concentration_risk: float
    leverage_ratio: float
    liquidity_risk: float
    risk_score: float

@dataclass
class RiskAlert:
    """风险告警"""
    id: str
    alert_type: AlertType
    risk_level: RiskLevel
    title: str
    message: str
    triggered_at: datetime
    resolved_at: Optional[datetime] = None
    metadata: Dict[str, Any] = None

class PnlRiskCalculator:
    """PnL和风险计算器"""

    def __init__(self):
        self.logger = get_logger("pnl_risk_calculator")
        self.calculation_interval = 60  # 60秒计算一次
        self.cache_ttl = 300  # 缓存5分钟
        self.risk_thresholds = {
            'max_drawdown': 0.15,  # 15%最大回撤
            'daily_loss': 0.05,    # 5%日损失
            'leverage_ratio': 3.0,  # 3倍杠杆
            'concentration': 0.3,   # 30%集中度
            'var_95': 0.1          # 10% VaR
        }
        self._running = False
        self._calculation_task = None
        self.pnl_cache: Optional[PnlBreakdown] = None
        self.risk_cache: Optional[RiskMetrics] = None
        self.alerts_cache: List[RiskAlert] = []

    async def initialize(self):
        """初始化PnL和风险计算器"""
        try:
            # 加载历史数据
            await self._load_historical_data()

            # 启动计算任务
            self._running = True
            self._calculation_task = asyncio.create_task(self._calculation_loop())

            # 启动告警监控任务
            asyncio.create_task(self._alert_monitoring_loop())

            self.logger.info("PnL Risk Calculator 初始化完成")

        except Exception as e:
            self.logger.error(f"PnL Risk Calculator 初始化失败: {e}")
            raise

    async def _load_historical_data(self):
        """加载历史数据"""
        try:
            # 加载过去30天的PnL记录
            async with get_db_session() as session:
                start_date = datetime.now() - timedelta(days=30)
                result = await session.execute(
                    select(PnlRecord).where(
                        PnlRecord.created_at >= start_date
                    ).order_by(PnlRecord.created_at)
                )

                # 存储历史数据用于计算
                self.pnl_history = [
                    {
                        'date': record.created_at,
                        'total_pnl': record.total_pnl,
                        'portfolio_value': record.portfolio_value,
                        'daily_return': record.daily_return
                    }
                    for record in result.scalars().all()
                ]

        except Exception as e:
            self.logger.error(f"加载历史数据失败: {e}")
            self.pnl_history = []

    async def _calculation_loop(self):
        """计算循环"""
        while self._running:
            try:
                # 计算PnL
                await self._calculate_pnl()

                # 计算风险指标
                await self._calculate_risk_metrics()

                # 记录指标
                if self.pnl_cache and self.risk_cache:
                    metrics.record_pnl_metrics(
                        total_pnl=float(self.pnl_cache.total_pnl),
                        daily_pnl=float(self.pnl_cache.daily_pnl),
                        risk_score=self.risk_cache.risk_score
                    )

                await asyncio.sleep(self.calculation_interval)

            except Exception as e:
                self.logger.error(f"PnL和风险计算失败: {e}")
                await asyncio.sleep(10)  # 错误后等待10秒再重试

    async def _calculate_pnl(self):
        """计算PnL"""
        try:
            # 获取所有仓位
            positions = await position_manager.get_positions()

            if not positions:
                self.pnl_cache = None
                return

            # 计算总PnL
            total_unrealized_pnl = sum(pos.unrealized_pnl for pos in positions)
            total_realized_pnl = sum(pos.realized_pnl for pos in positions)
            total_pnl = total_unrealized_pnl + total_realized_pnl

            # 计算按交易所分组的PnL
            pnl_by_exchange = {}
            pnl_by_symbol = {}

            for pos in positions:
                # 按交易所分组
                if pos.exchange not in pnl_by_exchange:
                    pnl_by_exchange[pos.exchange] = Decimal('0')
                pnl_by_exchange[pos.exchange] += pos.unrealized_pnl + pos.realized_pnl

                # 按交易对分组
                if pos.symbol not in pnl_by_symbol:
                    pnl_by_symbol[pos.symbol] = Decimal('0')
                pnl_by_symbol[pos.symbol] += pos.unrealized_pnl + pos.realized_pnl

            # 计算时间段PnL
            daily_pnl, weekly_pnl, monthly_pnl = await self._calculate_period_pnl()

            # 计算性能指标
            performance_metrics = await self._calculate_performance_metrics()

            # 创建PnL分解对象
            self.pnl_cache = PnlBreakdown(
                total_unrealized_pnl=total_unrealized_pnl,
                total_realized_pnl=total_realized_pnl,
                total_pnl=total_pnl,
                daily_pnl=daily_pnl,
                weekly_pnl=weekly_pnl,
                monthly_pnl=monthly_pnl,
                pnl_by_exchange=pnl_by_exchange,
                pnl_by_symbol=pnl_by_symbol,
                pnl_by_strategy={},  # 稍后实现
                performance_metrics=performance_metrics
            )

            # 保存到数据库
            await self._save_pnl_record()

            # 缓存到Redis
            await redis_client.setex(
                "pnl_breakdown",
                self.cache_ttl,
                self.pnl_cache.model_dump_json()
            )

        except Exception as e:
            self.logger.error(f"计算PnL失败: {e}")

    async def _calculate_period_pnl(self) -> Tuple[Decimal, Decimal, Decimal]:
        """计算时间段PnL"""
        try:
            now = datetime.now()
            daily_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
            weekly_start = daily_start - timedelta(days=now.weekday())
            monthly_start = daily_start.replace(day=1)

            # 从历史数据中计算
            daily_pnl = Decimal('0')
            weekly_pnl = Decimal('0')
            monthly_pnl = Decimal('0')

            for record in self.pnl_history:
                if record['date'] >= daily_start:
                    daily_pnl += Decimal(str(record.get('daily_return', 0)))
                if record['date'] >= weekly_start:
                    weekly_pnl += Decimal(str(record.get('daily_return', 0)))
                if record['date'] >= monthly_start:
                    monthly_pnl += Decimal(str(record.get('daily_return', 0)))

            return daily_pnl, weekly_pnl, monthly_pnl

        except Exception as e:
            self.logger.error(f"计算时间段PnL失败: {e}")
            return Decimal('0'), Decimal('0'), Decimal('0')

    async def _calculate_performance_metrics(self) -> Dict[str, float]:
        """计算性能指标"""
        try:
            if not self.pnl_history:
                return {}

            # 提取收益率序列
            returns = [float(record.get('daily_return', 0)) for record in self.pnl_history]

            if len(returns) < 2:
                return {}

            returns_array = np.array(returns)

            # 计算年化收益率
            annual_return = np.mean(returns) * 252

            # 计算年化波动率
            annual_volatility = np.std(returns) * np.sqrt(252)

            # 计算夏普比率（假设无风险利率为2%）
            risk_free_rate = 0.02
            sharpe_ratio = (annual_return - risk_free_rate) / annual_volatility if annual_volatility > 0 else 0

            # 计算索提诺比率
            downside_returns = returns_array[returns_array < 0]
            downside_volatility = np.std(downside_returns) * np.sqrt(252) if len(downside_returns) > 0 else annual_volatility
            sortino_ratio = (annual_return - risk_free_rate) / downside_volatility if downside_volatility > 0 else 0

            # 计算最大回撤
            cumulative_returns = np.cumprod(1 + returns_array)
            running_max = np.maximum.accumulate(cumulative_returns)
            drawdowns = (cumulative_returns - running_max) / running_max
            max_drawdown = np.min(drawdowns)

            # 计算胜率
            win_rate = np.mean(returns_array > 0) if len(returns_array) > 0 else 0

            # 计算盈亏比
            winning_trades = returns_array[returns_array > 0]
            losing_trades = returns_array[returns_array < 0]
            profit_factor = np.mean(winning_trades) / abs(np.mean(losing_trades)) if len(losing_trades) > 0 and len(winning_trades) > 0 else 0

            return {
                'annual_return': annual_return,
                'annual_volatility': annual_volatility,
                'sharpe_ratio': sharpe_ratio,
                'sortino_ratio': sortino_ratio,
                'max_drawdown': max_drawdown,
                'win_rate': win_rate,
                'profit_factor': profit_factor,
                'total_trades': len(returns)
            }

        except Exception as e:
            self.logger.error(f"计算性能指标失败: {e}")
            return {}

    async def _save_pnl_record(self):
        """保存PnL记录到数据库"""
        try:
            if not self.pnl_cache:
                return

            async with get_db_session() as session:
                # 获取当前总资产价值
                portfolio_value = await self._calculate_portfolio_value()

                # 计算日收益率
                daily_return = 0.0
                if self.pnl_history:
                    yesterday_pnl = self.pnl_history[-1].get('total_pnl', 0)
                    today_pnl = float(self.pnl_cache.total_pnl)
                    yesterday_portfolio = self.pnl_history[-1].get('portfolio_value', 1)
                    if yesterday_portfolio > 0:
                        daily_return = (today_pnl - yesterday_pnl) / yesterday_portfolio

                # 创建PnL记录
                pnl_record = PnlRecord(
                    portfolio_value=float(portfolio_value),
                    total_pnl=float(self.pnl_cache.total_pnl),
                    unrealized_pnl=float(self.pnl_cache.total_unrealized_pnl),
                    realized_pnl=float(self.pnl_cache.total_realized_pnl),
                    daily_pnl=float(self.pnl_cache.daily_pnl),
                    daily_return=daily_return,
                    created_at=datetime.now()
                )

                session.add(pnl_record)
                await session.commit()

                # 更新历史数据
                self.pnl_history.append({
                    'date': pnl_record.created_at,
                    'total_pnl': pnl_record.total_pnl,
                    'portfolio_value': pnl_record.portfolio_value,
                    'daily_return': pnl_record.daily_return
                })

                # 保持历史数据在合理范围内
                if len(self.pnl_history) > 365:  # 保留1年数据
                    self.pnl_history = self.pnl_history[-365:]

        except Exception as e:
            self.logger.error(f"保存PnL记录失败: {e}")

    async def _calculate_portfolio_value(self) -> Decimal:
        """计算投资组合价值"""
        try:
            # 获取所有仓位
            positions = await position_manager.get_positions()

            # 计算总价值
            total_value = Decimal('0')
            for pos in positions:
                position_value = pos.amount * pos.mark_price
                total_value += position_value + pos.unrealized_pnl + pos.realized_pnl

            return total_value if total_value > 0 else Decimal('1')  # 避免除零

        except Exception as e:
            self.logger.error(f"计算投资组合价值失败: {e}")
            return Decimal('1')

    async def _calculate_risk_metrics(self):
        """计算风险指标"""
        try:
            # 获取所有仓位
            positions = await position_manager.get_positions()

            if not positions:
                self.risk_cache = None
                return

            # 计算基本指标
            portfolio_value = await self._calculate_portfolio_value()
            total_exposure = sum(pos.amount * pos.mark_price for pos in positions)
            net_exposure = sum(pos.amount * pos.mark_price * (1 if pos.side == 'long' else -1) for pos in positions)

            # 计算回撤
            max_drawdown, current_drawdown = await self._calculate_drawdowns()

            # 计算波动率
            volatility_daily, volatility_weekly = await self._calculate_volatility()

            # 计算VaR和Expected Shortfall
            var_95, var_99, expected_shortfall = await self._calculate_var()

            # 计算集中度风险
            concentration_risk = await self._calculate_concentration_risk(positions, portfolio_value)

            # 计算杠杆率
            leverage_ratio = await self._calculate_leverage_ratio(positions, portfolio_value)

            # 计算流动性风险
            liquidity_risk = await self._calculate_liquidity_risk(positions)

            # 计算风险评分
            risk_score = await self._calculate_risk_score({
                'max_drawdown': current_drawdown,
                'concentration': concentration_risk,
                'leverage': leverage_ratio,
                'var_95': var_95,
                'volatility': volatility_daily
            })

            # 计算其他指标
            sharpe_ratio = self.pnl_cache.performance_metrics.get('sharpe_ratio', 0) if self.pnl_cache else 0
            sortino_ratio = self.pnl_cache.performance_metrics.get('sortino_ratio', 0) if self.pnl_cache else 0

            # 创建风险指标对象
            self.risk_cache = RiskMetrics(
                portfolio_value=portfolio_value,
                total_exposure=total_exposure,
                net_exposure=net_exposure,
                max_drawdown=max_drawdown,
                current_drawdown=current_drawdown,
                sharpe_ratio=sharpe_ratio,
                sortino_ratio=sortino_ratio,
                beta=0.0,  # 需要基准数据
                alpha=0.0,  # 需要基准数据
                volatility_daily=volatility_daily,
                volatility_weekly=volatility_weekly,
                value_at_risk_95=var_95,
                value_at_risk_99=var_99,
                expected_shortfall=expected_shortfall,
                concentration_risk=concentration_risk,
                leverage_ratio=leverage_ratio,
                liquidity_risk=liquidity_risk,
                risk_score=risk_score
            )

            # 保存到数据库
            await self._save_risk_metrics()

            # 缓存到Redis
            await redis_client.setex(
                "risk_metrics",
                self.cache_ttl,
                self.risk_cache.model_dump_json()
            )

        except Exception as e:
            self.logger.error(f"计算风险指标失败: {e}")

    async def _calculate_drawdowns(self) -> Tuple[float, float]:
        """计算回撤"""
        try:
            if not self.pnl_history:
                return 0.0, 0.0

            # 计算累计收益曲线
            portfolio_values = [float(record.get('portfolio_value', 1)) for record in self.pnl_history]
            cumulative_returns = np.array(portfolio_values) / portfolio_values[0]

            # 计算最大回撤
            running_max = np.maximum.accumulate(cumulative_returns)
            drawdowns = (cumulative_returns - running_max) / running_max
            max_drawdown = np.min(drawdowns)

            # 计算当前回撤
            current_drawdown = drawdowns[-1] if len(drawdowns) > 0 else 0.0

            return max_drawdown, current_drawdown

        except Exception as e:
            self.logger.error(f"计算回撤失败: {e}")
            return 0.0, 0.0

    async def _calculate_volatility(self) -> Tuple[float, float]:
        """计算波动率"""
        try:
            if not self.pnl_history:
                return 0.0, 0.0

            # 提取日收益率
            returns = [float(record.get('daily_return', 0)) for record in self.pnl_history]

            if len(returns) < 2:
                return 0.0, 0.0

            returns_array = np.array(returns)

            # 日波动率
            daily_volatility = np.std(returns_array)

            # 周波动率（假设5个交易日）
            weekly_returns = []
            for i in range(0, len(returns_array), 5):
                week_return = np.prod(1 + returns_array[i:i+5]) - 1
                weekly_returns.append(week_return)

            weekly_volatility = np.std(weekly_returns) if len(weekly_returns) > 1 else daily_volatility * np.sqrt(5)

            return daily_volatility, weekly_volatility

        except Exception as e:
            self.logger.error(f"计算波动率失败: {e}")
            return 0.0, 0.0

    async def _calculate_var(self) -> Tuple[float, float, float]:
        """计算VaR和Expected Shortfall"""
        try:
            if not self.pnl_history:
                return 0.0, 0.0, 0.0

            # 提取日收益率
            returns = [float(record.get('daily_return', 0)) for record in self.pnl_history]

            if len(returns) < 30:  # 需要足够的数据
                return 0.0, 0.0, 0.0

            returns_array = np.array(returns)

            # 使用历史模拟法计算VaR
            var_95 = np.percentile(returns_array, 5)
            var_99 = np.percentile(returns_array, 1)

            # 计算Expected Shortfall
            tail_losses = returns_array[returns_array <= var_95]
            expected_shortfall = np.mean(tail_losses) if len(tail_losses) > 0 else var_95

            return var_95, var_99, expected_shortfall

        except Exception as e:
            self.logger.error(f"计算VaR失败: {e}")
            return 0.0, 0.0, 0.0

    async def _calculate_concentration_risk(self, positions: List[PositionInfo], portfolio_value: Decimal) -> float:
        """计算集中度风险"""
        try:
            if portfolio_value <= 0:
                return 0.0

            # 计算每个仓位的占比
            position_values = []
            for pos in positions:
                position_value = pos.amount * pos.mark_price
                percentage = float(position_value / portfolio_value)
                position_values.append(percentage)

            # 计算赫芬达尔指数
            herfindahl_index = sum(p ** 2 for p in position_values)

            # 归一化到0-1范围
            max_concentration = max(position_values) if position_values else 0
            concentration_score = (herfindahl_index + max_concentration) / 2

            return min(concentration_score, 1.0)

        except Exception as e:
            self.logger.error(f"计算集中度风险失败: {e}")
            return 0.0

    async def _calculate_leverage_ratio(self, positions: List[PositionInfo], portfolio_value: Decimal) -> float:
        """计算杠杆率"""
        try:
            if portfolio_value <= 0:
                return 0.0

            # 计算总敞口
            total_exposure = sum(pos.amount * pos.mark_price for pos in positions)

            # 计算加权平均杠杆率
            weighted_leverage = 0.0
            total_value = 0.0

            for pos in positions:
                position_value = float(pos.amount * pos.mark_price)
                leverage_contribution = position_value * pos.leverage
                weighted_leverage += leverage_contribution
                total_value += position_value

            avg_leverage = weighted_leverage / total_value if total_value > 0 else 0.0

            # 计算净杠杆率
            net_exposure = sum(pos.amount * pos.mark_price * (1 if pos.side == 'long' else -1) for pos in positions)
            net_leverage = float(net_exposure / portfolio_value)

            # 综合杠杆率
            combined_leverage = (avg_leverage + abs(net_leverage)) / 2

            return combined_leverage

        except Exception as e:
            self.logger.error(f"计算杠杆率失败: {e}")
            return 0.0

    async def _calculate_liquidity_risk(self, positions: List[PositionInfo]) -> float:
        """计算流动性风险"""
        try:
            liquidity_score = 0.0

            for pos in positions:
                position_value = float(pos.amount * pos.mark_price)

                # 基于交易量估算流动性（简化版）
                # 实际应该从市场数据中获取交易量信息
                estimated_daily_volume = position_value * 10  # 假设日交易量为仓位的10倍

                # 计算仓位占日交易量的比例
                volume_ratio = position_value / estimated_daily_volume if estimated_daily_volume > 0 else 0

                # 流动性风险评分
                if volume_ratio > 0.1:  # 占比超过10%
                    liquidity_score += volume_ratio

            # 归一化到0-1范围
            return min(liquidity_score, 1.0)

        except Exception as e:
            self.logger.error(f"计算流动性风险失败: {e}")
            return 0.0

    async def _calculate_risk_score(self, risk_factors: Dict[str, float]) -> float:
        """计算综合风险评分"""
        try:
            weights = {
                'max_drawdown': 0.25,
                'concentration': 0.20,
                'leverage': 0.20,
                'var_95': 0.15,
                'volatility': 0.20
            }

            risk_score = 0.0

            for factor, value in risk_factors.items():
                weight = weights.get(factor, 0)
                normalized_value = min(abs(value), 1.0)  # 标准化到0-1
                risk_score += normalized_value * weight

            return min(risk_score, 1.0)

        except Exception as e:
            self.logger.error(f"计算风险评分失败: {e}")
            return 0.0

    async def _save_risk_metrics(self):
        """保存风险指标到数据库"""
        try:
            if not self.risk_cache:
                return

            async with get_db_session() as session:
                risk_metric = RiskMetric(
                    portfolio_value=float(self.risk_cache.portfolio_value),
                    max_drawdown=self.risk_cache.max_drawdown,
                    current_drawdown=self.risk_cache.current_drawdown,
                    sharpe_ratio=self.risk_cache.sharpe_ratio,
                    volatility_daily=self.risk_cache.volatility_daily,
                    value_at_risk_95=self.risk_cache.value_at_risk_95,
                    concentration_risk=self.risk_cache.concentration_risk,
                    leverage_ratio=self.risk_cache.leverage_ratio,
                    risk_score=self.risk_cache.risk_score,
                    created_at=datetime.now()
                )

                session.add(risk_metric)
                await session.commit()

        except Exception as e:
            self.logger.error(f"保存风险指标失败: {e}")

    async def _alert_monitoring_loop(self):
        """告警监控循环"""
        while self._running:
            try:
                await self._check_risk_alerts()
                await asyncio.sleep(30)  # 30秒检查一次
            except Exception as e:
                self.logger.error(f"风险告警监控失败: {e}")
                await asyncio.sleep(10)

    async def _check_risk_alerts(self):
        """检查风险告警"""
        try:
            if not self.risk_cache:
                return

            alerts = []

            # 检查回撤告警
            if self.risk_cache.current_drawdown < -self.risk_thresholds['max_drawdown']:
                alert = RiskAlert(
                    id=f"drawdown_{int(time.time())}",
                    alert_type=AlertType.DRAWDOWN,
                    risk_level=RiskLevel.CRITICAL if self.risk_cache.current_drawdown < -self.risk_thresholds['max_drawdown'] * 1.5 else RiskLevel.HIGH,
                    title="最大回撤告警",
                    message=f"当前回撤{self.risk_cache.current_drawdown:.2%}超过阈值{self.risk_thresholds['max_drawdown']:.2%}",
                    triggered_at=datetime.now(),
                    metadata={'current_drawdown': self.risk_cache.current_drawdown, 'threshold': self.risk_thresholds['max_drawdown']}
                )
                alerts.append(alert)

            # 检查集中度告警
            if self.risk_cache.concentration_risk > self.risk_thresholds['concentration']:
                alert = RiskAlert(
                    id=f"concentration_{int(time.time())}",
                    alert_type=AlertType.CONCENTRATION,
                    risk_level=RiskLevel.HIGH,
                    title="集中度风险告警",
                    message=f"集中度风险{self.risk_cache.concentration_risk:.2%}超过阈值{self.risk_thresholds['concentration']:.2%}",
                    triggered_at=datetime.now(),
                    metadata={'concentration_risk': self.risk_cache.concentration_risk, 'threshold': self.risk_thresholds['concentration']}
                )
                alerts.append(alert)

            # 检查杠杆率告警
            if self.risk_cache.leverage_ratio > self.risk_thresholds['leverage_ratio']:
                alert = RiskAlert(
                    id=f"leverage_{int(time.time())}",
                    alert_type=AlertType.LEVERAGE,
                    risk_level=RiskLevel.HIGH,
                    title="杠杆率告警",
                    message=f"杠杆率{self.risk_cache.leverage_ratio:.2f}倍超过阈值{self.risk_thresholds['leverage_ratio']:.1f}倍",
                    triggered_at=datetime.now(),
                    metadata={'leverage_ratio': self.risk_cache.leverage_ratio, 'threshold': self.risk_thresholds['leverage_ratio']}
                )
                alerts.append(alert)

            # 检查VaR告警
            if abs(self.risk_cache.value_at_risk_95) > self.risk_thresholds['var_95']:
                alert = RiskAlert(
                    id=f"var_{int(time.time())}",
                    alert_type=AlertType.VOLATILITY,
                    risk_level=RiskLevel.MEDIUM,
                    title="VaR风险告警",
                    message=f"95% VaR{self.risk_cache.value_at_risk_95:.2%}超过阈值{self.risk_thresholds['var_95']:.2%}",
                    triggered_at=datetime.now(),
                    metadata={'var_95': self.risk_cache.value_at_risk_95, 'threshold': self.risk_thresholds['var_95']}
                )
                alerts.append(alert)

            # 处理告警
            for alert in alerts:
                await self._process_risk_alert(alert)

        except Exception as e:
            self.logger.error(f"检查风险告警失败: {e}")

    async def _process_risk_alert(self, alert: RiskAlert):
        """处理风险告警"""
        try:
            # 检查是否已经存在相同的告警
            existing_alerts = [a for a in self.alerts_cache
                             if a.alert_type == alert.alert_type and a.resolved_at is None]

            if existing_alerts:
                # 更新现有告警的触发时间
                existing_alerts[0].triggered_at = alert.triggered_at
            else:
                # 添加新告警
                self.alerts_cache.append(alert)

                # 保存到数据库
                async with get_db_session() as session:
                    risk_alert = RiskAlert(
                        alert_type=alert.alert_type.value,
                        risk_level=alert.risk_level.value,
                        title=alert.title,
                        message=alert.message,
                        triggered_at=alert.triggered_at,
                        metadata=alert.metadata or {}
                    )

                    session.add(risk_alert)
                    await session.commit()

                # 记录指标
                metrics.record_risk_alert(
                    alert_type=alert.alert_type.value,
                    risk_level=alert.risk_level.value
                )

                self.logger.warning(f"风险告警: {alert.title} - {alert.message}")

        except Exception as e:
            self.logger.error(f"处理风险告警失败: {e}")

    async def get_pnl_breakdown(self) -> Optional[PnlBreakdown]:
        """获取PnL分解"""
        return self.pnl_cache

    async def get_risk_metrics(self) -> Optional[RiskMetrics]:
        """获取风险指标"""
        return self.risk_cache

    async def get_risk_alerts(self, resolved: bool = None, hours: int = 24) -> List[RiskAlert]:
        """获取风险告警"""
        try:
            now = datetime.now()
            filtered_alerts = []

            for alert in self.alerts_cache:
                # 时间过滤
                if (now - alert.triggered_at).total_seconds() > hours * 3600:
                    continue

                # 状态过滤
                if resolved is not None:
                    if resolved and alert.resolved_at is None:
                        continue
                    if not resolved and alert.resolved_at is not None:
                        continue

                filtered_alerts.append(alert)

            return sorted(filtered_alerts, key=lambda x: x.triggered_at, reverse=True)

        except Exception as e:
            self.logger.error(f"获取风险告警失败: {e}")
            return []

    async def get_risk_report(self, days: int = 7) -> Dict[str, Any]:
        """获取风险报告"""
        try:
            # 获取历史风险指标
            async with get_db_session() as session:
                start_date = datetime.now() - timedelta(days=days)
                result = await session.execute(
                    select(RiskMetric).where(
                        RiskMetric.created_at >= start_date
                    ).order_by(RiskMetric.created_at)
                )

                risk_history = [
                    {
                        'date': record.created_at,
                        'risk_score': record.risk_score,
                        'max_drawdown': record.max_drawdown,
                        'sharpe_ratio': record.sharpe_ratio,
                        'volatility': record.volatility_daily,
                        'leverage_ratio': record.leverage_ratio
                    }
                    for record in result.scalars().all()
                ]

            # 获取当前状态
            current_pnl = self.pnl_cache
            current_risk = self.risk_cache
            current_alerts = await self.get_risk_alerts(resolved=False, hours=24)

            # 生成报告
            report = {
                'report_period': f"{days} days",
                'generated_at': datetime.now().isoformat(),
                'current_status': {
                    'pnl': asdict(current_pnl) if current_pnl else None,
                    'risk': asdict(current_risk) if current_risk else None,
                    'active_alerts': len(current_alerts)
                },
                'risk_history': risk_history,
                'summary': {
                    'avg_risk_score': np.mean([r['risk_score'] for r in risk_history]) if risk_history else 0,
                    'max_drawdown_period': min([r['max_drawdown'] for r in risk_history]) if risk_history else 0,
                    'total_alerts': len(current_alerts),
                    'high_risk_alerts': len([a for a in current_alerts if a.risk_level in [RiskLevel.HIGH, RiskLevel.CRITICAL]])
                }
            }

            return report

        except Exception as e:
            self.logger.error(f"获取风险报告失败: {e}")
            return {}

    async def close(self):
        """关闭PnL和风险计算器"""
        self._running = False

        if self._calculation_task:
            self._calculation_task.cancel()
            try:
                await self._calculation_task
            except asyncio.CancelledError:
                pass

        self.pnl_cache = None
        self.risk_cache = None
        self.alerts_cache.clear()
        self.logger.info("PnL Risk Calculator 已关闭")

# 全局PnL和风险计算器实例
pnl_risk_calculator = PnlRiskCalculator()
```

## 接受标准

### 必须满足的条件
- [ ] 实现实时PnL计算，包括未实现盈亏、已实现盈亏和总盈亏
- [ ] 提供全面的风险指标计算（VaR、最大回撤、夏普比率等）
- [ ] 实现基于风险阈值的自动预警机制
- [ ] 支持历史PnL分析和风险统计
- [ ] 提供多维度的风险报告生成
- [ ] 实现高性能的缓存策略
- [ ] 支持风险评分和风险评估
- [ ] 提供完整的监控和指标收集
- [ ] 通过性能测试和准确性验证

### 性能要求
- **计算延迟**: PnL和风险计算延迟 < 60秒
- **查询性能**: 缓存查询响应时间 < 10ms
- **计算准确度**: PnL计算准确度 > 99.9%
- **告警响应**: 风险告警响应时间 < 30秒
- **并发处理**: 支持1000+并发查询请求

### 技术规范
- 使用高性能数值计算库
- 实现数据一致性保证机制
- 支持配置热更新
- 完整的错误处理和异常管理
- 符合数据安全和隐私要求

## 实现步骤

### 第一阶段：基础架构 (2天)
1. 设计PnL和风险计算核心架构
2. 创建数据模型和数据库表
3. 实现基础PnL计算功能
4. 开发缓存和性能优化

### 第二阶段：风险指标 (3天)
1. 实现各种风险指标计算算法
2. 开发VaR和Expected Shortfall计算
3. 实现回撤和波动率分析
4. 添加风险评分机制

### 第三阶段：预警机制 (2天)
1. 实现风险阈值监控
2. 开发告警生成和通知
3. 实现告警处理和恢复
4. 添加告警历史记录

### 第四阶段：报告和测试 (1天)
1. 实现风险报告生成
2. 进行功能测试和性能测试
3. 验证计算准确性
4. 完善文档和配置

## 交付物

### 文档
- PnL和风险计算设计文档
- 风险指标算法文档
- 预警机制文档
- API接口文档

### 代码
- PnL计算器核心实现
- 风险指标计算器
- 预警管理器
- 报告生成器
- 缓存管理器
- 单元测试和集成测试

### 配置
- 风险阈值配置
- 计算参数配置
- 告警规则配置
- 性能监控配置

## 风险和依赖

### 技术风险
- 复杂的风险指标计算可能存在精度问题
- 历史数据不足可能影响计算准确性
- 预警算法可能存在误报和漏报

### 依赖关系
- 依赖于Position Manager的仓位数据
- 依赖于Order Manager的订单数据
- 依赖于数据库性能和可用性

### 缓解措施
- 实现多种计算方法的交叉验证
- 添加数据质量检查和验证
- 实现自适应阈值调整机制

## 验收标准
- PnL计算准确可靠
- 风险指标计算精确
- 预警机制有效及时
- 系统性能满足要求
- 报告生成完整准确
- 监控指标全面详细