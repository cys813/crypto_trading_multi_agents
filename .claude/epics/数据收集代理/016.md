---
name: 集成测试和性能测试
type: task
epic: 数据收集代理
status: open
priority: 2
created: 2025-09-25T20:20:35Z
estimated: 16 days
assigned: [待分配]
parallelizable: true
dependencies: ["001", "002", "003", "004", "005", "006", "007", "008", "009", "010", "011", "012", "013", "014", "015"]
---

# 任务: 集成测试和性能测试

## 任务描述
实现完整的测试套件，包括集成测试、性能测试、负载测试、安全测试和端到端测试。通过全面的测试覆盖和质量保证，确保数据收集代理系统的稳定性、可靠性和性能达标，为生产部署提供充分的质量保障。

## 技术要求

### 核心架构设计

#### Testing Framework 组件
- **单元测试**: 针对各个模块的单元测试覆盖
- **集成测试**: 模块间接口和交互的集成测试
- **性能测试**: 系统性能指标和基准测试
- **负载测试**: 高并发和大数据量负载测试
- **安全测试**: 安全漏洞和权限验证测试
- **端到端测试**: 完整业务流程的端到端测试

#### 技术栈
- **测试框架**: pytest + pytest-asyncio + pytest-cov
- **性能测试**: locust + JMeter + Prometheus
- **Mock工具**: unittest.mock + pytest-mock
- **测试数据库**: Testcontainers + PostgreSQL/Redis
- **CI/CD**: GitHub Actions + Docker

### 实现架构

```python
# src/tests/test_framework.py
import asyncio
import time
import json
import logging
from typing import Dict, List, Optional, Any, Union, Callable, AsyncGenerator
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
import tempfile
import os
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import statistics
import psutil
import subprocess
import docker
from pathlib import Path

import pytest
import pytest_asyncio
import pytest_cov
from pytest_mock import MockerFixture
from locust import HttpUser, task, between, events
from locust.env import Environment
from locust.stats import stats_printer
from locust.log import setup_logging
import httpx
import aiohttp
import async_timeout
from prometheus_client import CollectorRegistry, generate_latest
from testcontainers.postgres import PostgresContainer
from testcontainers.redis import RedisContainer
from testcontainers.core.container import DockerContainer
from testcontainers.core.waiting_utils import wait_for_logs

from ..core.config import config
from ..core.logger import get_logger
from ..core.exceptions import TestError, PerformanceError
from ..managers.exchange_manager import exchange_manager
from ..managers.position_manager import position_manager
from ..managers.order_manager import order_manager
from ..processors.data_processor import data_processor
from ..cache.cache_manager import cache_manager
from ..services.export_service import ExportService
from ..services.monitoring_service import MonitoringService
from ..api.main import app

# 初始化日志
logger = get_logger("test_framework")

# 测试环境枚举
class TestEnvironment(Enum):
    """测试环境枚举"""
    DEVELOPMENT = "development"
    STAGING = "staging"
    PRODUCTION = "production"

# 测试类型枚举
class TestType(Enum):
    """测试类型枚举"""
    UNIT = "unit"
    INTEGRATION = "integration"
    PERFORMANCE = "performance"
    LOAD = "load"
    SECURITY = "security"
    E2E = "e2e"

# 测试状态枚举
class TestStatus(Enum):
    """测试状态枚举"""
    PASSED = "passed"
    FAILED = "failed"
    SKIPPED = "skipped"
    ERROR = "error"
    TIMEOUT = "timeout"

@dataclass
class TestResult:
    """测试结果数据类"""
    test_id: str
    test_name: str
    test_type: TestType
    status: TestStatus
    duration: float
    timestamp: datetime
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    assertions: List[Dict[str, Any]] = field(default_factory=list)

@dataclass
class PerformanceMetrics:
    """性能指标数据类"""
    metric_name: str
    value: float
    unit: str
    timestamp: datetime
    threshold: Optional[float] = None
    is_passing: bool = True

@dataclass
class LoadTestConfig:
    """负载测试配置"""
    test_id: str
    name: str
    users: int
    spawn_rate: float
    duration: int
    target_host: str
    test_type: str = "http"
    scenarios: List[Dict[str, Any]] = field(default_factory=list)

class TestDatabaseManager:
    """测试数据库管理器"""

    def __init__(self):
        self.postgres_container = None
        self.redis_container = None
        self.test_containers = {}

    async def setup_test_database(self):
        """设置测试数据库"""
        try:
            # 启动PostgreSQL测试容器
            self.postgres_container = PostgresContainer(
                "postgres:15",
                port=5432,
                username="testuser",
                password="testpass",
                dbname="testdb"
            )
            self.postgres_container.start()

            # 启动Redis测试容器
            self.redis_container = RedisContainer("redis:7-alpine")
            self.redis_container.start()

            # 更新测试配置
            config.update({
                "database": {
                    "host": self.postgres_container.get_container_host_ip(),
                    "port": self.postgres_container.get_exposed_port(5432),
                    "username": "testuser",
                    "password": "testpass",
                    "database": "testdb"
                },
                "redis": {
                    "host": self.redis_container.get_container_host_ip(),
                    "port": self.redis_container.get_exposed_port(6379)
                }
            })

            logger.info("测试数据库设置完成")
            return True

        except Exception as e:
            logger.error(f"设置测试数据库失败: {e}")
            return False

    async def teardown_test_database(self):
        """清理测试数据库"""
        try:
            if self.postgres_container:
                self.postgres_container.stop()
            if self.redis_container:
                self.redis_container.stop()

            # 清理其他容器
            for container in self.test_containers.values():
                container.stop()

            logger.info("测试数据库清理完成")
            return True

        except Exception as e:
            logger.error(f"清理测试数据库失败: {e}")
            return False

    async def reset_database(self):
        """重置数据库状态"""
        try:
            # 执行数据库清理脚本
            if self.postgres_container:
                exec_result = self.postgres_container.exec(
                    ["psql", "-U", "testuser", "-d", "testdb", "-c", "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"]
                )
                if exec_result.exit_code != 0:
                    logger.error(f"重置PostgreSQL失败: {exec_result.stderr.decode()}")

            # 清空Redis
            if self.redis_container:
                exec_result = self.redis_container.exec(["redis-cli", "FLUSHALL"])
                if exec_result.exit_code != 0:
                    logger.error(f"清空Redis失败: {exec_result.stderr.decode()}")

            logger.info("数据库重置完成")
            return True

        except Exception as e:
            logger.error(f"重置数据库失败: {e}")
            return False

class MockExchangeManager:
    """模拟交易所管理器"""

    def __init__(self):
        self.mock_data = self._generate_mock_data()
        self.response_delays = []

    def _generate_mock_data(self):
        """生成模拟数据"""
        return {
            "tickers": [
                {
                    "symbol": "BTC/USDT",
                    "price": 45000.0,
                    "timestamp": datetime.now().isoformat(),
                    "volume": 1000.0
                },
                {
                    "symbol": "ETH/USDT",
                    "price": 3200.0,
                    "timestamp": datetime.now().isoformat(),
                    "volume": 500.0
                }
            ],
            "ohlcv": [
                {
                    "symbol": "BTC/USDT",
                    "timeframe": "1m",
                    "timestamp": datetime.now().isoformat(),
                    "open": 44900.0,
                    "high": 45100.0,
                    "low": 44800.0,
                    "close": 45000.0,
                    "volume": 1000.0
                }
            ],
            "orderbook": {
                "symbol": "BTC/USDT",
                "bids": [[44900.0, 1.5], [44800.0, 2.0]],
                "asks": [[45100.0, 1.2], [45200.0, 1.8]],
                "timestamp": datetime.now().isoformat()
            },
            "trades": [
                {
                    "symbol": "BTC/USDT",
                    "price": 45000.0,
                    "amount": 0.1,
                    "timestamp": datetime.now().isoformat(),
                    "side": "buy"
                }
            ]
        }

    async def get_ticker(self, exchange: str, symbol: str):
        """获取模拟行情数据"""
        await asyncio.sleep(0.1)  # 模拟网络延迟
        for ticker in self.mock_data["tickers"]:
            if ticker["symbol"] == symbol:
                return ticker
        return None

    async def get_ohlcv(self, exchange: str, symbol: str, timeframe: str = "1m", limit: int = 100):
        """获取模拟OHLCV数据"""
        await asyncio.sleep(0.1)
        return self.mock_data["ohlcv"][:limit]

    async def get_orderbook(self, exchange: str, symbol: str, limit: int = 100):
        """获取模拟订单簿数据"""
        await asyncio.sleep(0.1)
        return self.mock_data["orderbook"]

    async def get_recent_trades(self, exchange: str, symbol: str, limit: int = 100):
        """获取模拟交易数据"""
        await asyncio.sleep(0.1)
        return self.mock_data["trades"][:limit]

class MockDataManager:
    """模拟数据管理器"""

    def __init__(self):
        self.positions = [
            {
                "exchange": "binance",
                "symbol": "BTC/USDT",
                "side": "long",
                "size": 0.1,
                "entry_price": 44000.0,
                "current_price": 45000.0,
                "pnl": 100.0,
                "timestamp": datetime.now().isoformat()
            }
        ]
        self.orders = [
            {
                "exchange": "binance",
                "symbol": "BTC/USDT",
                "side": "buy",
                "type": "limit",
                "price": 44900.0,
                "amount": 0.1,
                "status": "filled",
                "timestamp": datetime.now().isoformat()
            }
        ]

    async def get_positions(self, exchange: str = None, symbol: str = None):
        """获取模拟仓位数据"""
        await asyncio.sleep(0.05)
        positions = self.positions
        if exchange:
            positions = [p for p in positions if p["exchange"] == exchange]
        if symbol:
            positions = [p for p in positions if p["symbol"] == symbol]
        return positions

    async def get_orders(self, exchange: str = None, symbol: str = None, status: str = None):
        """获取模拟订单数据"""
        await asyncio.sleep(0.05)
        orders = self.orders
        if exchange:
            orders = [o for o in orders if o["exchange"] == exchange]
        if symbol:
            orders = [o for o in orders if o["symbol"] == symbol]
        if status:
            orders = [o for o in orders if o["status"] == status]
        return orders

class PerformanceTester:
    """性能测试器"""

    def __init__(self):
        self.test_results: List[TestResult] = []
        self.performance_metrics: List[PerformanceMetrics] = []
        self.thresholds = {
            "api_response_time": 1.0,  # 1秒
            "data_collection_rate": 1000,  # 1000条/秒
            "memory_usage": 1024 * 1024 * 1024,  # 1GB
            "cpu_usage": 80.0,  # 80%
            "error_rate": 0.01  # 1%
        }

    async def test_api_performance(self, base_url: str, test_duration: int = 60):
        """测试API性能"""
        try:
            logger.info(f"开始API性能测试，持续时间: {test_duration}秒")

            start_time = time.time()
            request_times = []
            error_count = 0
            total_requests = 0

            async with httpx.AsyncClient() as client:
                while time.time() - start_time < test_duration:
                    try:
                        # 测试不同的API端点
                        endpoints = [
                            "/api/v1/markets/tickers",
                            "/api/v1/markets/ohlcv?exchange=binance&symbol=BTC/USDT",
                            "/api/v1/positions",
                            "/api/v1/orders",
                            "/health"
                        ]

                        for endpoint in endpoints:
                            request_start = time.time()
                            response = await client.get(f"{base_url}{endpoint}")
                            request_time = time.time() - request_start
                            request_times.append(request_time)
                            total_requests += 1

                            if response.status_code >= 400:
                                error_count += 1

                    except Exception as e:
                        error_count += 1
                        total_requests += 1

                    await asyncio.sleep(0.1)  # 控制请求频率

            # 计算性能指标
            avg_response_time = statistics.mean(request_times) if request_times else 0
            max_response_time = max(request_times) if request_times else 0
            min_response_time = min(request_times) if request_times else 0
            p95_response_time = statistics.quantiles(request_times, n=20)[18] if len(request_times) >= 20 else avg_response_time
            error_rate = error_count / total_requests if total_requests > 0 else 0
            requests_per_second = total_requests / test_duration

            # 记录性能指标
            metrics = [
                PerformanceMetrics("avg_response_time", avg_response_time, "seconds", datetime.now(), self.thresholds["api_response_time"]),
                PerformanceMetrics("max_response_time", max_response_time, "seconds", datetime.now()),
                PerformanceMetrics("p95_response_time", p95_response_time, "seconds", datetime.now(), self.thresholds["api_response_time"]),
                PerformanceMetrics("error_rate", error_rate, "ratio", datetime.now(), self.thresholds["error_rate"]),
                PerformanceMetrics("requests_per_second", requests_per_second, "rps", datetime.now())
            ]

            for metric in metrics:
                if metric.threshold:
                    metric.is_passing = metric.value <= metric.threshold
                self.performance_metrics.append(metric)

            # 创建测试结果
            test_result = TestResult(
                test_id=f"api_performance_{int(start_time)}",
                test_name="API性能测试",
                test_type=TestType.PERFORMANCE,
                status=TestStatus.PASSED if all(m.is_passing for m in metrics if m.threshold) else TestStatus.FAILED,
                duration=test_duration,
                timestamp=datetime.now(),
                metadata={
                    "avg_response_time": avg_response_time,
                    "p95_response_time": p95_response_time,
                    "error_rate": error_rate,
                    "requests_per_second": requests_per_second,
                    "total_requests": total_requests
                }
            )

            self.test_results.append(test_result)

            logger.info(f"API性能测试完成 - 平均响应时间: {avg_response_time:.3f}s, P95: {p95_response_time:.3f}s, 错误率: {error_rate:.2%}")
            return test_result

        except Exception as e:
            logger.error(f"API性能测试失败: {e}")
            return TestResult(
                test_id=f"api_performance_{int(time.time())}",
                test_name="API性能测试",
                test_type=TestType.PERFORMANCE,
                status=TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                error_message=str(e)
            )

    async def test_data_collection_performance(self, duration: int = 60):
        """测试数据收集性能"""
        try:
            logger.info(f"开始数据收集性能测试，持续时间: {duration}秒")

            start_time = time.time()
            collected_records = 0
            collection_times = []

            mock_exchange = MockExchangeManager()

            while time.time() - start_time < duration:
                try:
                    # 模拟数据收集
                    collection_start = time.time()

                    # 收集不同类型的数据
                    ticker = await mock_exchange.get_ticker("binance", "BTC/USDT")
                    ohlcv = await mock_exchange.get_ohlcv("binance", "BTC/USDT")
                    orderbook = await mock_exchange.get_orderbook("binance", "BTC/USDT")
                    trades = await mock_exchange.get_recent_trades("binance", "BTC/USDT")

                    collection_time = time.time() - collection_start
                    collection_times.append(collection_time)

                    if ticker:
                        collected_records += 1
                    if ohlcv:
                        collected_records += len(ohlcv)
                    if orderbook:
                        collected_records += len(orderbook.get("bids", [])) + len(orderbook.get("asks", []))
                    if trades:
                        collected_records += len(trades)

                except Exception as e:
                    logger.error(f"数据收集错误: {e}")

                await asyncio.sleep(0.1)

            # 计算性能指标
            avg_collection_time = statistics.mean(collection_times) if collection_times else 0
            collection_rate = collected_records / duration
            max_collection_time = max(collection_times) if collection_times else 0

            # 记录性能指标
            metrics = [
                PerformanceMetrics("avg_collection_time", avg_collection_time, "seconds", datetime.now()),
                PerformanceMetrics("collection_rate", collection_rate, "records/second", datetime.now(), self.thresholds["data_collection_rate"]),
                PerformanceMetrics("max_collection_time", max_collection_time, "seconds", datetime.now())
            ]

            for metric in metrics:
                if metric.threshold:
                    metric.is_passing = metric.value >= metric.threshold if "rate" in metric.metric_name else metric.value <= metric.threshold
                self.performance_metrics.append(metric)

            # 创建测试结果
            test_result = TestResult(
                test_id=f"data_collection_performance_{int(start_time)}",
                test_name="数据收集性能测试",
                test_type=TestType.PERFORMANCE,
                status=TestStatus.PASSED if all(m.is_passing for m in metrics if m.threshold) else TestStatus.FAILED,
                duration=duration,
                timestamp=datetime.now(),
                metadata={
                    "avg_collection_time": avg_collection_time,
                    "collection_rate": collection_rate,
                    "total_records": collected_records,
                    "max_collection_time": max_collection_time
                }
            )

            self.test_results.append(test_result)

            logger.info(f"数据收集性能测试完成 - 收集速率: {collection_rate:.1f}记录/秒, 平均耗时: {avg_collection_time:.3f}s")
            return test_result

        except Exception as e:
            logger.error(f"数据收集性能测试失败: {e}")
            return TestResult(
                test_id=f"data_collection_performance_{int(time.time())}",
                test_name="数据收集性能测试",
                test_type=TestType.PERFORMANCE,
                status=TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                error_message=str(e)
            )

    async def test_system_resource_usage(self, duration: int = 60):
        """测试系统资源使用"""
        try:
            logger.info(f"开始系统资源使用测试，持续时间: {duration}秒")

            start_time = time.time()
            cpu_samples = []
            memory_samples = []
            process = psutil.Process()

            while time.time() - start_time < duration:
                try:
                    # 获取CPU使用率
                    cpu_percent = process.cpu_percent()
                    cpu_samples.append(cpu_percent)

                    # 获取内存使用
                    memory_info = process.memory_info()
                    memory_samples.append(memory_info.rss)

                    await asyncio.sleep(1)

                except Exception as e:
                    logger.error(f"资源监控错误: {e}")

            # 计算性能指标
            avg_cpu_usage = statistics.mean(cpu_samples) if cpu_samples else 0
            max_cpu_usage = max(cpu_samples) if cpu_samples else 0
            avg_memory_usage = statistics.mean(memory_samples) if memory_samples else 0
            max_memory_usage = max(memory_samples) if memory_samples else 0

            # 记录性能指标
            metrics = [
                PerformanceMetrics("avg_cpu_usage", avg_cpu_usage, "percent", datetime.now(), self.thresholds["cpu_usage"]),
                PerformanceMetrics("max_cpu_usage", max_cpu_usage, "percent", datetime.now()),
                PerformanceMetrics("avg_memory_usage", avg_memory_usage, "bytes", datetime.now(), self.thresholds["memory_usage"]),
                PerformanceMetrics("max_memory_usage", max_memory_usage, "bytes", datetime.now())
            ]

            for metric in metrics:
                if metric.threshold:
                    metric.is_passing = metric.value <= metric.threshold
                self.performance_metrics.append(metric)

            # 创建测试结果
            test_result = TestResult(
                test_id=f"system_resource_usage_{int(start_time)}",
                test_name="系统资源使用测试",
                test_type=TestType.PERFORMANCE,
                status=TestStatus.PASSED if all(m.is_passing for m in metrics if m.threshold) else TestStatus.FAILED,
                duration=duration,
                timestamp=datetime.now(),
                metadata={
                    "avg_cpu_usage": avg_cpu_usage,
                    "max_cpu_usage": max_cpu_usage,
                    "avg_memory_usage": avg_memory_usage,
                    "max_memory_usage": max_memory_usage
                }
            )

            self.test_results.append(test_result)

            logger.info(f"系统资源使用测试完成 - 平均CPU: {avg_cpu_usage:.1f}%, 平均内存: {avg_memory_usage/1024/1024:.1f}MB")
            return test_result

        except Exception as e:
            logger.error(f"系统资源使用测试失败: {e}")
            return TestResult(
                test_id=f"system_resource_usage_{int(time.time())}",
                test_name="系统资源使用测试",
                test_type=TestType.PERFORMANCE,
                status=TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                error_message=str(e)
            )

class LoadTester:
    """负载测试器"""

    def __init__(self):
        self.load_test_results: List[TestResult] = []
        self.environments: Dict[str, Environment] = {}

    async def run_load_test(self, config: LoadTestConfig):
        """运行负载测试"""
        try:
            logger.info(f"开始负载测试: {config.name}")

            # 创建Locust环境
            env = Environment(user_classes=[self._create_user_class(config)])
            self.environments[config.test_id] = env

            # 启动测试
            stats_writer = events.StatsWriter()
            env.events.add_listener(stats_writer)

            # 运行测试
            await asyncio.get_event_loop().run_in_executor(
                None,
                lambda: env.create_local_runner().start(
                    user_count=config.users,
                    spawn_rate=config.spawn_rate,
                    time_limit=config.duration
                )
            )

            # 收集结果
            stats = env.runner.stats

            test_result = TestResult(
                test_id=config.test_id,
                test_name=config.name,
                test_type=TestType.LOAD,
                status=TestStatus.PASSED if stats.total_rps > 0 else TestStatus.FAILED,
                duration=config.duration,
                timestamp=datetime.now(),
                metadata={
                    "total_requests": stats.total_num_requests,
                    "requests_per_second": stats.total_rps,
                    "failure_rate": stats.total_fail_ratio,
                    "avg_response_time": stats.avg_response_time,
                    "max_response_time": stats.max_response_time,
                    "min_response_time": stats.min_response_time
                }
            )

            self.load_test_results.append(test_result)

            logger.info(f"负载测试完成: {config.name} - RPS: {stats.total_rps:.1f}, 失败率: {stats.total_fail_ratio:.2%}")
            return test_result

        except Exception as e:
            logger.error(f"负载测试失败: {e}")
            return TestResult(
                test_id=config.test_id,
                test_name=config.name,
                test_type=TestType.LOAD,
                status=TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                error_message=str(e)
            )

    def _create_user_class(self, config: LoadTestConfig):
        """创建Locust用户类"""
        class ApiUser(HttpUser):
            wait_time = between(1, 3)

            @task
            def test_api_endpoints(self):
                scenarios = config.scenarios or [
                    {"endpoint": "/api/v1/markets/tickers", "method": "GET"},
                    {"endpoint": "/api/v1/markets/ohlcv", "method": "GET"},
                    {"endpoint": "/api/v1/positions", "method": "GET"},
                    {"endpoint": "/health", "method": "GET"}
                ]

                for scenario in scenarios:
                    if scenario["method"] == "GET":
                        response = self.client.get(scenario["endpoint"])
                    elif scenario["method"] == "POST":
                        response = self.client.post(scenario["endpoint"])

        return ApiUser

class SecurityTester:
    """安全测试器"""

    def __init__(self):
        self.security_results: List[TestResult] = []
        self.vulnerabilities_found = []

    async def test_authentication_security(self, base_url: str):
        """测试认证安全"""
        try:
            logger.info("开始认证安全测试")

            vulnerabilities = []

            # 测试未认证访问
            async with httpx.AsyncClient() as client:
                protected_endpoints = [
                    "/api/v1/markets/tickers",
                    "/api/v1/positions",
                    "/api/v1/orders"
                ]

                for endpoint in protected_endpoints:
                    response = await client.get(f"{base_url}{endpoint}")
                    if response.status_code == 200:
                        vulnerabilities.append({
                            "type": "未认证访问",
                            "endpoint": endpoint,
                            "severity": "HIGH"
                        })

            # 测试弱密码
            weak_passwords = ["admin", "123456", "password", "test"]
            for password in weak_passwords:
                try:
                    response = await self._try_login(base_url, "admin", password)
                    if response.status_code == 200:
                        vulnerabilities.append({
                            "type": "弱密码",
                            "username": "admin",
                            "password": password,
                            "severity": "MEDIUM"
                        })
                except Exception:
                    pass

            # 测试SQL注入
            sql_payloads = ["' OR '1'='1", "' UNION SELECT 1--", "'; DROP TABLE users--"]
            for payload in sql_payloads:
                try:
                    response = await self._test_sql_injection(base_url, payload)
                    if "error" not in response.text.lower():
                        vulnerabilities.append({
                            "type": "SQL注入",
                            "payload": payload,
                            "severity": "HIGH"
                        })
                except Exception:
                    pass

            test_result = TestResult(
                test_id=f"auth_security_{int(time.time())}",
                test_name="认证安全测试",
                test_type=TestType.SECURITY,
                status=TestStatus.FAILED if vulnerabilities else TestStatus.PASSED,
                duration=0,
                timestamp=datetime.now(),
                metadata={
                    "vulnerabilities_found": len(vulnerabilities),
                    "vulnerabilities": vulnerabilities
                }
            )

            self.security_results.append(test_result)
            self.vulnerabilities_found.extend(vulnerabilities)

            logger.info(f"认证安全测试完成，发现 {len(vulnerabilities)} 个漏洞")
            return test_result

        except Exception as e:
            logger.error(f"认证安全测试失败: {e}")
            return TestResult(
                test_id=f"auth_security_{int(time.time())}",
                test_name="认证安全测试",
                test_type=TestType.SECURITY,
                status=TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                error_message=str(e)
            )

    async def _try_login(self, base_url: str, username: str, password: str):
        """尝试登录"""
        async with httpx.AsyncClient() as client:
            data = {"username": username, "password": password}
            response = await client.post(f"{base_url}/auth/token", data=data)
            return response

    async def _test_sql_injection(self, base_url: str, payload: str):
        """测试SQL注入"""
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{base_url}/api/v1/test?param={payload}")
            return response

class IntegrationTestRunner:
    """集成测试运行器"""

    def __init__(self):
        self.test_results: List[TestResult] = []
        self.db_manager = TestDatabaseManager()

    async def setup_test_environment(self):
        """设置测试环境"""
        return await self.db_manager.setup_test_database()

    async def teardown_test_environment(self):
        """清理测试环境"""
        return await self.db_manager.teardown_test_database()

    async def run_exchange_integration_tests(self):
        """运行交易所集成测试"""
        try:
            logger.info("开始交易所集成测试")

            # 使用模拟交易所进行测试
            mock_exchange = MockExchangeManager()

            test_cases = [
                ("获取行情数据", mock_exchange.get_ticker, "binance", "BTC/USDT"),
                ("获取OHLCV数据", mock_exchange.get_ohlcv, "binance", "BTC/USDT"),
                ("获取订单簿数据", mock_exchange.get_orderbook, "binance", "BTC/USDT"),
                ("获取交易数据", mock_exchange.get_recent_trades, "binance", "BTC/USDT")
            ]

            passed_tests = 0
            total_tests = len(test_cases)

            for test_name, test_func, *args in test_cases:
                try:
                    result = await test_func(*args)
                    if result is not None:
                        passed_tests += 1
                        logger.info(f"✓ {test_name}: 通过")
                    else:
                        logger.warning(f"✗ {test_name}: 失败 - 返回None")
                except Exception as e:
                    logger.error(f"✗ {test_name}: 失败 - {str(e)}")

            test_result = TestResult(
                test_id=f"exchange_integration_{int(time.time())}",
                test_name="交易所集成测试",
                test_type=TestType.INTEGRATION,
                status=TestStatus.PASSED if passed_tests == total_tests else TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                metadata={
                    "passed_tests": passed_tests,
                    "total_tests": total_tests,
                    "success_rate": passed_tests / total_tests if total_tests > 0 else 0
                }
            )

            self.test_results.append(test_result)

            logger.info(f"交易所集成测试完成 - 通过率: {passed_tests}/{total_tests}")
            return test_result

        except Exception as e:
            logger.error(f"交易所集成测试失败: {e}")
            return TestResult(
                test_id=f"exchange_integration_{int(time.time())}",
                test_name="交易所集成测试",
                test_type=TestType.INTEGRATION,
                status=TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                error_message=str(e)
            )

    async def run_data_pipeline_tests(self):
        """运行数据管道测试"""
        try:
            logger.info("开始数据管道测试")

            mock_exchange = MockExchangeManager()
            mock_data_manager = MockDataManager()

            # 测试数据收集到存储的完整流程
            test_cases = [
                ("行情数据收集流程", self._test_ticker_pipeline, mock_exchange),
                ("OHLCV数据收集流程", self._test_ohlcv_pipeline, mock_exchange),
                ("仓位数据流程", self._test_position_pipeline, mock_data_manager),
                ("订单数据流程", self._test_order_pipeline, mock_data_manager)
            ]

            passed_tests = 0
            total_tests = len(test_cases)

            for test_name, test_func, *args in test_cases:
                try:
                    success = await test_func(*args)
                    if success:
                        passed_tests += 1
                        logger.info(f"✓ {test_name}: 通过")
                    else:
                        logger.warning(f"✗ {test_name}: 失败")
                except Exception as e:
                    logger.error(f"✗ {test_name}: 失败 - {str(e)}")

            test_result = TestResult(
                test_id=f"data_pipeline_{int(time.time())}",
                test_name="数据管道测试",
                test_type=TestType.INTEGRATION,
                status=TestStatus.PASSED if passed_tests == total_tests else TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                metadata={
                    "passed_tests": passed_tests,
                    "total_tests": total_tests,
                    "success_rate": passed_tests / total_tests if total_tests > 0 else 0
                }
            )

            self.test_results.append(test_result)

            logger.info(f"数据管道测试完成 - 通过率: {passed_tests}/{total_tests}")
            return test_result

        except Exception as e:
            logger.error(f"数据管道测试失败: {e}")
            return TestResult(
                test_id=f"data_pipeline_{int(time.time())}",
                test_name="数据管道测试",
                test_type=TestType.INTEGRATION,
                status=TestStatus.FAILED,
                duration=0,
                timestamp=datetime.now(),
                error_message=str(e)
            )

    async def _test_ticker_pipeline(self, mock_exchange):
        """测试行情数据管道"""
        ticker = await mock_exchange.get_ticker("binance", "BTC/USDT")
        return ticker is not None and "symbol" in ticker and "price" in ticker

    async def _test_ohlcv_pipeline(self, mock_exchange):
        """测试OHLCV数据管道"""
        ohlcv = await mock_exchange.get_ohlcv("binance", "BTC/USDT")
        return ohlcv is not None and len(ohlcv) > 0

    async def _test_position_pipeline(self, mock_data_manager):
        """测试仓位数据管道"""
        positions = await mock_data_manager.get_positions()
        return positions is not None and len(positions) > 0

    async def _test_order_pipeline(self, mock_data_manager):
        """测试订单数据管道"""
        orders = await mock_data_manager.get_orders()
        return orders is not None and len(orders) > 0

class TestReportGenerator:
    """测试报告生成器"""

    def __init__(self):
        self.output_dir = Path("test_reports")
        self.output_dir.mkdir(exist_ok=True)

    def generate_comprehensive_report(self, test_results: List[TestResult]) -> str:
        """生成综合测试报告"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_path = self.output_dir / f"comprehensive_test_report_{timestamp}.html"

            # 统计数据
            total_tests = len(test_results)
            passed_tests = len([r for r in test_results if r.status == TestStatus.PASSED])
            failed_tests = len([r for r in test_results if r.status == TestStatus.FAILED])
            skipped_tests = len([r for r in test_results if r.status == TestStatus.SKIPPED])
            error_tests = len([r for r in test_results if r.status == TestStatus.ERROR])

            # 按类型分组
            tests_by_type = {}
            for result in test_results:
                test_type = result.test_type.value
                if test_type not in tests_by_type:
                    tests_by_type[test_type] = []
                tests_by_type[test_type].append(result)

            # 生成HTML报告
            html_content = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <title>综合测试报告</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 20px; }}
                    .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
                    .summary {{ display: flex; justify-content: space-around; margin: 20px 0; }}
                    .summary-item {{ text-align: center; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }}
                    .passed {{ background-color: #d4edda; }}
                    .failed {{ background-color: #f8d7da; }}
                    .skipped {{ background-color: #fff3cd; }}
                    .error {{ background-color: #f8d7da; }}
                    .test-section {{ margin: 20px 0; }}
                    .test-item {{ margin: 10px 0; padding: 10px; border: 1px solid #ddd; border-radius: 3px; }}
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>数据收集代理综合测试报告</h1>
                    <p>生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                </div>

                <div class="summary">
                    <div class="summary-item">
                        <h3>总测试数</h3>
                        <p>{total_tests}</p>
                    </div>
                    <div class="summary-item passed">
                        <h3>通过</h3>
                        <p>{passed_tests}</p>
                    </div>
                    <div class="summary-item failed">
                        <h3>失败</h3>
                        <p>{failed_tests}</p>
                    </div>
                    <div class="summary-item skipped">
                        <h3>跳过</h3>
                        <p>{skipped_tests}</p>
                    </div>
                    <div class="summary-item error">
                        <h3>错误</h3>
                        <p>{error_tests}</p>
                    </div>
                </div>

                <h2>测试详情</h2>
            """

            for test_type, results in tests_by_type.items():
                html_content += f"""
                <div class="test-section">
                    <h3>{test_type.upper()} 测试</h3>
                """
                for result in results:
                    status_class = result.status.value.lower()
                    html_content += f"""
                    <div class="test-item {status_class}">
                        <h4>{result.test_name}</h4>
                        <p>状态: {result.status.value}</p>
                        <p>持续时间: {result.duration:.2f}秒</p>
                        <p>时间: {result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}</p>
                        {f'<p>错误: {result.error_message}</p>' if result.error_message else ''}
                    </div>
                    """
                html_content += "</div>"

            html_content += """
            </body>
            </html>
            """

            # 写入文件
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write(html_content)

            logger.info(f"测试报告生成完成: {report_path}")
            return str(report_path)

        except Exception as e:
            logger.error(f"生成测试报告失败: {e}")
            return None

# 全局实例
performance_tester = PerformanceTester()
load_tester = LoadTester()
security_tester = SecurityTester()
integration_test_runner = IntegrationTestRunner()
report_generator = TestReportGenerator()

# Pytest fixtures
@pytest.fixture(scope="session")
def event_loop():
    """创建事件循环"""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()

@pytest_asyncio.fixture(scope="session")
async def test_db():
    """测试数据库fixture"""
    db_manager = TestDatabaseManager()
    await db_manager.setup_test_database()
    yield db_manager
    await db_manager.teardown_test_database()

@pytest_asyncio.fixture(scope="session")
async def mock_exchange():
    """模拟交易所fixture"""
    return MockExchangeManager()

@pytest_asyncio.fixture(scope="session")
async def mock_data_manager():
    """模拟数据管理器fixture"""
    return MockDataManager()

# 测试函数
@pytest.mark.asyncio
async def test_exchange_ticker(mock_exchange):
    """测试交易所行情获取"""
    ticker = await mock_exchange.get_ticker("binance", "BTC/USDT")
    assert ticker is not None
    assert "symbol" in ticker
    assert "price" in ticker

@pytest.mark.asyncio
async def test_exchange_ohlcv(mock_exchange):
    """测试交易所OHLCV获取"""
    ohlcv = await mock_exchange.get_ohlcv("binance", "BTC/USDT")
    assert ohlcv is not None
    assert len(ohlcv) > 0

@pytest.mark.asyncio
async def test_data_manager_positions(mock_data_manager):
    """测试仓位数据管理"""
    positions = await mock_data_manager.get_positions()
    assert positions is not None
    assert len(positions) > 0

@pytest.mark.asyncio
async def test_api_performance():
    """测试API性能"""
    # 这里应该有实际的API端点测试
    assert True

# 主测试运行器
async def run_comprehensive_tests():
    """运行综合测试"""
    logger.info("开始运行综合测试套件")

    all_test_results = []

    try:
        # 1. 设置测试环境
        await integration_test_runner.setup_test_environment()

        # 2. 运行集成测试
        exchange_result = await integration_test_runner.run_exchange_integration_tests()
        all_test_results.append(exchange_result)

        pipeline_result = await integration_test_runner.run_data_pipeline_tests()
        all_test_results.append(pipeline_result)

        # 3. 运行性能测试
        api_perf_result = await performance_tester.test_api_performance("http://localhost:8000")
        all_test_results.append(api_perf_result)

        data_perf_result = await performance_tester.test_data_collection_performance()
        all_test_results.append(data_perf_result)

        resource_result = await performance_tester.test_system_resource_usage()
        all_test_results.append(resource_result)

        # 4. 运行安全测试
        security_result = await security_tester.test_authentication_security("http://localhost:8000")
        all_test_results.append(security_result)

        # 5. 生成测试报告
        report_path = report_generator.generate_comprehensive_report(all_test_results)

        # 6. 清理测试环境
        await integration_test_runner.teardown_test_environment()

        logger.info("综合测试套件运行完成")
        return all_test_results, report_path

    except Exception as e:
        logger.error(f"综合测试套件运行失败: {e}")
        return all_test_results, None

if __name__ == "__main__":
    # 运行测试
    asyncio.run(run_comprehensive_tests())
```

## 接受标准

### 必须满足的条件
- [ ] 实现完整的单元测试覆盖 (>90%覆盖率)
- [ ] 提供全面的集成测试套件
- [ ] 实现性能测试和基准测试
- [ ] 支持负载测试和压力测试
- [ ] 包含安全测试和漏洞检测
- [ ] 提供端到端业务流程测试
- [ ] 实现自动化测试报告生成
- [ ] 支持CI/CD集成
- [ ] 提供测试数据库管理功能
- [ ] 通过所有测试类型和性能要求

### 性能要求
- **API响应时间**: < 1秒 (P95)
- **数据收集速率**: > 1000条/秒
- **并发用户数**: 支持1000+并发用户
- **系统资源占用**: CPU < 80%, 内存 < 1GB
- **错误率**: < 1%
- **测试覆盖率**: > 90%

### 技术规范
- 使用pytest和pytest-asyncio框架
- 实现异步测试支持
- 支持Docker容器化测试
- 完整的Mock和Stub机制
- 符合测试驱动开发(TDD)最佳实践

## 实现步骤

### 第一阶段：测试框架搭建 (3天)
1. 设置pytest测试框架
2. 实现测试数据库管理
3. 创建Mock和Stub机制
4. 搭建持续集成环境

### 第二阶段：单元测试 (3天)
1. 实现核心模块单元测试
2. 添加数据处理测试
3. 创建缓存和存储测试
4. 实现配置和日志测试

### 第三阶段：集成测试 (3天)
1. 实现交易所集成测试
2. 创建数据管道测试
3. 添加API服务测试
4. 实现数据库集成测试

### 第四阶段：性能和安全测试 (4天)
1. 实现性能测试套件
2. 创建负载测试脚本
3. 开发安全测试模块
4. 添加端到端测试

### 第五阶段：报告和CI/CD (3天)
1. 实现测试报告生成
2. 集成CI/CD流程
3. 完善测试文档
4. 进行测试优化

## 交付物

### 文档
- 测试策略和计划文档
- 测试用例设计文档
- 性能测试报告模板
- 安全测试指南

### 代码
- 单元测试代码
- 集成测试代码
- 性能测试脚本
- 安全测试工具
- 测试框架代码
- Mock和Stub实现

### 配置
- pytest配置文件
- 测试环境配置
- CI/CD配置文件
- 测试数据库配置
- 性能测试配置

## 风险和依赖

### 技术风险
- 测试环境稳定性问题
- Mock数据真实性不足
- 性能测试环境差异
- 安全测试工具局限性

### 依赖关系
- 依赖于开发环境
- 依赖于测试数据库
- 依赖于外部服务Mock
- 依赖于CI/CD工具

### 缓解措施
- 实现环境隔离和容器化
- 基于真实数据生成Mock
- 标准化测试环境配置
- 使用多种安全测试工具

## 验收标准
- 测试覆盖率 > 90%
- 所有测试用例通过
- 性能指标达到要求
- 安全漏洞修复完成
- 自动化测试流程稳定
- 测试报告完整准确
- CI/CD集成正常工作