---
name: ç›‘æ§å‘Šè­¦ç³»ç»Ÿå’Œä»ªè¡¨æ¿
type: task
epic: æ•°æ®æ”¶é›†ä»£ç†
status: open
priority: 2
created: 2025-09-25T20:20:35Z
estimated: 14 days
assigned: [å¾…åˆ†é…]
parallelizable: true
dependencies: ["003", "011", "012"]
---

# ä»»åŠ¡: ç›‘æ§å‘Šè­¦ç³»ç»Ÿå’Œä»ªè¡¨æ¿

## ä»»åŠ¡æè¿°
å®ç°å®Œæ•´çš„ç›‘æ§å‘Šè­¦ç³»ç»Ÿå’Œå¯è§†åŒ–ä»ªè¡¨æ¿ï¼ŒåŒ…æ‹¬Prometheusé›†æˆã€Grafanaä»ªè¡¨æ¿ã€å‘Šè­¦è§„åˆ™é…ç½®å’Œå¤šæ¸ é“é€šçŸ¥æœºåˆ¶ã€‚é€šè¿‡å…¨æ–¹ä½çš„ç³»ç»Ÿç›‘æ§å’Œæ™ºèƒ½å‘Šè­¦ï¼Œç¡®ä¿æ•°æ®æ”¶é›†ä»£ç†çš„ç¨³å®šè¿è¡Œå’ŒåŠæ—¶æ•…éšœå“åº”ã€‚

## æŠ€æœ¯è¦æ±‚

### æ ¸å¿ƒæ¶æ„è®¾è®¡

#### Monitoring & Alerting ç»„ä»¶
- **æŒ‡æ ‡æ”¶é›†**: ç³»ç»ŸæŒ‡æ ‡ã€ä¸šåŠ¡æŒ‡æ ‡ã€æ€§èƒ½æŒ‡æ ‡çš„è‡ªåŠ¨æ”¶é›†
- **å‘Šè­¦è§„åˆ™**: çµæ´»çš„å‘Šè­¦è§„åˆ™é…ç½®å’Œé˜ˆå€¼ç®¡ç†
- **é€šçŸ¥æœºåˆ¶**: å¤šæ¸ é“å‘Šè­¦é€šçŸ¥ï¼ˆé‚®ä»¶ã€çŸ­ä¿¡ã€é’‰é’‰ã€Slackç­‰ï¼‰
- **å¯è§†åŒ–ä»ªè¡¨æ¿**: Grafanaä»ªè¡¨æ¿å®šåˆ¶å’Œå®æ—¶æ•°æ®å±•ç¤º
- **å†å²åˆ†æ**: æŒ‡æ ‡å†å²æ•°æ®åˆ†æå’Œè¶‹åŠ¿é¢„æµ‹

#### æŠ€æœ¯æ ˆ
- **ç›‘æ§æ¡†æ¶**: Prometheus + Grafana + AlertManager
- **æŒ‡æ ‡åº“**: Prometheus Client + custom metrics
- **é€šçŸ¥æœåŠ¡**: SMTP + Webhook + ä¼ä¸šå¾®ä¿¡/é’‰é’‰API
- **æ•°æ®å­˜å‚¨**: Prometheus TSDB + InfluxDBï¼ˆå¯é€‰ï¼‰
- **æ—¥å¿—èšåˆ**: ELK Stackï¼ˆElasticsearch + Logstash + Kibanaï¼‰

### å®ç°æ¶æ„

```python
# src/monitoring/monitoring_service.py
import asyncio
import time
import json
import logging
from typing import Dict, List, Optional, Any, Union, Callable
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
import threading
from queue import Queue, Empty
import smtplib
import requests
import httpx
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import jinja2
import yaml
import re
from pathlib import Path

from prometheus_client import (
    Counter, Histogram, Gauge, Summary, CollectorRegistry, push_to_gateway,
    Info, Enum as PrometheusEnum, generate_latest, CONTENT_TYPE_LATEST
)
from prometheus_client.exposition import start_http_server
from prometheus_client.core import GaugeMetricFamily, CounterMetricFamily
from prometheus_client.parser import text_string_to_metric_families

from ..core.config import config
from ..core.logger import get_logger
from ..core.exceptions import MonitoringError, AlertError
from ..managers.exchange_manager import exchange_manager
from ..managers.position_manager import position_manager
from ..managers.order_manager import order_manager
from ..processors.data_processor import data_processor
from ..cache.cache_manager import cache_manager

# åˆå§‹åŒ–æ—¥å¿—
logger = get_logger("monitoring_service")

# å‘Šè­¦çº§åˆ«æšä¸¾
class AlertLevel(Enum):
    """å‘Šè­¦çº§åˆ«æšä¸¾"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"
    EMERGENCY = "emergency"

# å‘Šè­¦çŠ¶æ€æšä¸¾
class AlertStatus(Enum):
    """å‘Šè­¦çŠ¶æ€æšä¸¾"""
    ACTIVE = "active"
    RESOLVED = "resolved"
    SUPPRESSED = "suppressed"
    ACKNOWLEDGED = "acknowledged"

# é€šçŸ¥æ¸ é“æšä¸¾
class NotificationChannel(Enum):
    """é€šçŸ¥æ¸ é“æšä¸¾"""
    EMAIL = "email"
    SMS = "sms"
    WEBHOOK = "webhook"
    DINGTALK = "dingtalk"
    SLACK = "slack"
    WECHAT = "wechat"
    TELEGRAM = "telegram"

# æŒ‡æ ‡ç±»å‹æšä¸¾
class MetricType(Enum):
    """æŒ‡æ ‡ç±»å‹æšä¸¾"""
    COUNTER = "counter"
    GAUGE = "gauge"
    HISTOGRAM = "histogram"
    SUMMARY = "summary"

@dataclass
class AlertRule:
    """å‘Šè­¦è§„åˆ™æ•°æ®ç±»"""
    rule_id: str
    name: str
    description: str
    metric_name: str
    condition: str  # Prometheusè¡¨è¾¾å¼
    threshold: float
    duration: timedelta  # æŒç»­æ—¶é—´
    level: AlertLevel
    enabled: bool = True
    notifications: List[NotificationChannel] = field(default_factory=list)
    tags: Dict[str, str] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

@dataclass
class Alert:
    """å‘Šè­¦æ•°æ®ç±»"""
    alert_id: str
    rule_id: str
    name: str
    description: str
    level: AlertLevel
    status: AlertStatus
    value: float
    threshold: float
    triggered_at: datetime
    resolved_at: Optional[datetime] = None
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    notifications_sent: List[str] = field(default_factory=list)

@dataclass
class NotificationTemplate:
    """é€šçŸ¥æ¨¡æ¿æ•°æ®ç±»"""
    template_id: str
    name: str
    channel: NotificationChannel
    subject_template: str
    body_template: str
    variables: List[str] = field(default_factory=list)
    enabled: bool = True

class MetricsCollector:
    """æŒ‡æ ‡æ”¶é›†å™¨"""

    def __init__(self):
        self.registry = CollectorRegistry()
        self.custom_metrics = {}
        self.system_metrics = {}
        self.business_metrics = {}
        self.collection_interval = config.get("metrics_collection_interval", 15)  # 15ç§’
        self.collector_active = False

    def create_counter(self, name: str, description: str, labels: List[str] = None) -> Counter:
        """åˆ›å»ºCounteræŒ‡æ ‡"""
        try:
            if name not in self.custom_metrics:
                self.custom_metrics[name] = Counter(
                    name, description, labels or [], registry=self.registry
                )
            return self.custom_metrics[name]
        except Exception as e:
            raise MonitoringError(f"åˆ›å»ºCounteræŒ‡æ ‡å¤±è´¥: {str(e)}")

    def create_gauge(self, name: str, description: str, labels: List[str] = None) -> Gauge:
        """åˆ›å»ºGaugeæŒ‡æ ‡"""
        try:
            if name not in self.custom_metrics:
                self.custom_metrics[name] = Gauge(
                    name, description, labels or [], registry=self.registry
                )
            return self.custom_metrics[name]
        except Exception as e:
            raise MonitoringError(f"åˆ›å»ºGaugeæŒ‡æ ‡å¤±è´¥: {str(e)}")

    def create_histogram(self, name: str, description: str, labels: List[str] = None,
                        buckets: List[float] = None) -> Histogram:
        """åˆ›å»ºHistogramæŒ‡æ ‡"""
        try:
            if name not in self.custom_metrics:
                self.custom_metrics[name] = Histogram(
                    name, description, labels or [],
                    buckets=buckets or Histogram.DEFAULT_BUCKETS,
                    registry=self.registry
                )
            return self.custom_metrics[name]
        except Exception as e:
            raise MonitoringError(f"åˆ›å»ºHistogramæŒ‡æ ‡å¤±è´¥: {str(e)}")

    def create_summary(self, name: str, description: str, labels: List[str] = None) -> Summary:
        """åˆ›å»ºSummaryæŒ‡æ ‡"""
        try:
            if name not in self.custom_metrics:
                self.custom_metrics[name] = Summary(
                    name, description, labels or [], registry=self.registry
                )
            return self.custom_metrics[name]
        except Exception as e:
            raise MonitoringError(f"åˆ›å»ºSummaryæŒ‡æ ‡å¤±è´¥: {str(e)}")

    def record_counter(self, name: str, value: float = 1, labels: Dict[str, str] = None):
        """è®°å½•CounteræŒ‡æ ‡"""
        try:
            if name in self.custom_metrics:
                metric = self.custom_metrics[name]
                if labels:
                    metric.labels(**labels).inc(value)
                else:
                    metric.inc(value)
        except Exception as e:
            logger.error(f"è®°å½•CounteræŒ‡æ ‡å¤±è´¥: {e}")

    def record_gauge(self, name: str, value: float, labels: Dict[str, str] = None):
        """è®°å½•GaugeæŒ‡æ ‡"""
        try:
            if name in self.custom_metrics:
                metric = self.custom_metrics[name]
                if labels:
                    metric.labels(**labels).set(value)
                else:
                    metric.set(value)
        except Exception as e:
            logger.error(f"è®°å½•GaugeæŒ‡æ ‡å¤±è´¥: {e}")

    def record_histogram(self, name: str, value: float, labels: Dict[str, str] = None):
        """è®°å½•HistogramæŒ‡æ ‡"""
        try:
            if name in self.custom_metrics:
                metric = self.custom_metrics[name]
                if labels:
                    metric.labels(**labels).observe(value)
                else:
                    metric.observe(value)
        except Exception as e:
            logger.error(f"è®°å½•HistogramæŒ‡æ ‡å¤±è´¥: {e}")

    def record_summary(self, name: str, value: float, labels: Dict[str, str] = None):
        """è®°å½•SummaryæŒ‡æ ‡"""
        try:
            if name in self.custom_metrics:
                metric = self.custom_metrics[name]
                if labels:
                    metric.labels(**labels).observe(value)
                else:
                    metric.observe(value)
        except Exception as e:
            logger.error(f"è®°å½•SummaryæŒ‡æ ‡å¤±è´¥: {e}")

    async def collect_system_metrics(self):
        """æ”¶é›†ç³»ç»ŸæŒ‡æ ‡"""
        try:
            import psutil
            import platform

            # CPUæŒ‡æ ‡
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            self.record_gauge("system_cpu_usage_percent", cpu_percent)
            self.record_gauge("system_cpu_count", cpu_count)

            # å†…å­˜æŒ‡æ ‡
            memory = psutil.virtual_memory()
            self.record_gauge("system_memory_usage_percent", memory.percent)
            self.record_gauge("system_memory_total_bytes", memory.total)
            self.record_gauge("system_memory_available_bytes", memory.available)
            self.record_gauge("system_memory_used_bytes", memory.used)

            # ç£ç›˜æŒ‡æ ‡
            disk = psutil.disk_usage('/')
            self.record_gauge("system_disk_usage_percent", disk.percent)
            self.record_gauge("system_disk_total_bytes", disk.total)
            self.record_gauge("system_disk_used_bytes", disk.used)
            self.record_gauge("system_disk_free_bytes", disk.free)

            # ç½‘ç»œæŒ‡æ ‡
            net_io = psutil.net_io_counters()
            self.record_counter("system_network_bytes_sent", net_io.bytes_sent)
            self.record_counter("system_network_bytes_recv", net_io.bytes_recv)

            # ç³»ç»Ÿä¿¡æ¯
            boot_time = datetime.fromtimestamp(psutil.boot_time())
            uptime = datetime.now() - boot_time
            self.record_gauge("system_uptime_seconds", uptime.total_seconds())

        except Exception as e:
            logger.error(f"æ”¶é›†ç³»ç»ŸæŒ‡æ ‡å¤±è´¥: {e}")

    async def collect_business_metrics(self):
        """æ”¶é›†ä¸šåŠ¡æŒ‡æ ‡"""
        try:
            # äº¤æ˜“æ‰€è¿æ¥æŒ‡æ ‡
            exchange_stats = await exchange_manager.get_connection_stats()
            for exchange_name, stats in exchange_stats.items():
                self.record_gauge(
                    "exchange_connections_total",
                    stats.get("active_connections", 0),
                    {"exchange": exchange_name}
                )
                self.record_gauge(
                    "exchange_request_rate",
                    stats.get("request_rate", 0),
                    {"exchange": exchange_name}
                )

            # æ•°æ®æ”¶é›†æŒ‡æ ‡
            collection_stats = await exchange_manager.get_collection_stats()
            self.record_counter(
                "data_collected_total",
                collection_stats.get("total_records", 0)
            )
            self.record_gauge(
                "data_collection_rate",
                collection_stats.get("collection_rate", 0)
            )

            # ä»“ä½æŒ‡æ ‡
            position_stats = await position_manager.get_position_stats()
            self.record_gauge(
                "positions_total",
                position_stats.get("total_positions", 0)
            )
            self.record_gauge(
                "positions_pnl_total",
                position_stats.get("total_pnl", 0)
            )

            # è®¢å•æŒ‡æ ‡
            order_stats = await order_manager.get_order_stats()
            self.record_counter(
                "orders_total",
                order_stats.get("total_orders", 0)
            )
            self.record_gauge(
                "order_execution_rate",
                order_stats.get("execution_rate", 0)
            )

            # ç¼“å­˜æŒ‡æ ‡
            cache_stats = await cache_manager.get_cache_stats()
            self.record_gauge(
                "cache_hit_rate",
                cache_stats.get("hit_rate", 0)
            )
            self.record_gauge(
                "cache_size_bytes",
                cache_stats.get("memory_usage", 0)
            )

        except Exception as e:
            logger.error(f"æ”¶é›†ä¸šåŠ¡æŒ‡æ ‡å¤±è´¥: {e}")

    async def collect_metrics(self):
        """æ”¶é›†æ‰€æœ‰æŒ‡æ ‡"""
        try:
            await self.collect_system_metrics()
            await self.collect_business_metrics()

            # æ¨é€åˆ°Prometheusç½‘å…³
            if config.get("prometheus_pushgateway_enabled", False):
                await self.push_metrics_to_gateway()

        except Exception as e:
            logger.error(f"æ”¶é›†æŒ‡æ ‡å¤±è´¥: {e}")

    async def push_metrics_to_gateway(self):
        """æ¨é€æŒ‡æ ‡åˆ°Prometheusç½‘å…³"""
        try:
            gateway_url = config.get("prometheus_pushgateway_url")
            if gateway_url:
                push_to_gateway(
                    gateway_url,
                    job="data_collection_agent",
                    registry=self.registry
                )
        except Exception as e:
            logger.error(f"æ¨é€æŒ‡æ ‡åˆ°ç½‘å…³å¤±è´¥: {e}")

    async def start_collection(self):
        """å¯åŠ¨æŒ‡æ ‡æ”¶é›†"""
        self.collector_active = True
        logger.info("æŒ‡æ ‡æ”¶é›†å™¨å¯åŠ¨")

        while self.collector_active:
            try:
                await self.collect_metrics()
                await asyncio.sleep(self.collection_interval)
            except Exception as e:
                logger.error(f"æŒ‡æ ‡æ”¶é›†é”™è¯¯: {e}")
                await asyncio.sleep(self.collection_interval)

    async def stop_collection(self):
        """åœæ­¢æŒ‡æ ‡æ”¶é›†"""
        self.collector_active = False
        logger.info("æŒ‡æ ‡æ”¶é›†å™¨åœæ­¢")

    def get_metrics(self) -> str:
        """è·å–æŒ‡æ ‡æ•°æ®"""
        try:
            return generate_latest(self.registry).decode('utf-8')
        except Exception as e:
            raise MonitoringError(f"è·å–æŒ‡æ ‡æ•°æ®å¤±è´¥: {str(e)}")

class AlertManager:
    """å‘Šè­¦ç®¡ç†å™¨"""

    def __init__(self):
        self.alert_rules: Dict[str, AlertRule] = {}
        self.active_alerts: Dict[str, Alert] = []
        self.alert_history: List[Alert] = []
        self.notification_manager = NotificationManager()
        self.template_manager = TemplateManager()
        self.check_interval = config.get("alert_check_interval", 30)  # 30ç§’
        self.alert_suppressions: Dict[str, datetime] = {}
        self.alert_manager_active = False

    def add_alert_rule(self, rule: AlertRule) -> bool:
        """æ·»åŠ å‘Šè­¦è§„åˆ™"""
        try:
            self.alert_rules[rule.rule_id] = rule
            logger.info(f"æ·»åŠ å‘Šè­¦è§„åˆ™: {rule.name}")
            return True
        except Exception as e:
            logger.error(f"æ·»åŠ å‘Šè­¦è§„åˆ™å¤±è´¥: {e}")
            return False

    def remove_alert_rule(self, rule_id: str) -> bool:
        """ç§»é™¤å‘Šè­¦è§„åˆ™"""
        try:
            if rule_id in self.alert_rules:
                del self.alert_rules[rule_id]
                logger.info(f"ç§»é™¤å‘Šè­¦è§„åˆ™: {rule_id}")
                return True
            return False
        except Exception as e:
            logger.error(f"ç§»é™¤å‘Šè­¦è§„åˆ™å¤±è´¥: {e}")
            return False

    def update_alert_rule(self, rule_id: str, **kwargs) -> bool:
        """æ›´æ–°å‘Šè­¦è§„åˆ™"""
        try:
            if rule_id in self.alert_rules:
                rule = self.alert_rules[rule_id]
                for key, value in kwargs.items():
                    if hasattr(rule, key):
                        setattr(rule, key, value)
                rule.updated_at = datetime.now()
                logger.info(f"æ›´æ–°å‘Šè­¦è§„åˆ™: {rule_id}")
                return True
            return False
        except Exception as e:
            logger.error(f"æ›´æ–°å‘Šè­¦è§„åˆ™å¤±è´¥: {e}")
            return False

    async def check_alerts(self):
        """æ£€æŸ¥å‘Šè­¦"""
        try:
            for rule_id, rule in self.alert_rules.items():
                if not rule.enabled:
                    continue

                # æ£€æŸ¥æ˜¯å¦è¢«æŠ‘åˆ¶
                if rule_id in self.alert_suppressions:
                    if datetime.now() < self.alert_suppressions[rule_id]:
                        continue
                    else:
                        del self.alert_suppressions[rule_id]

                # æŸ¥è¯¢PrometheusæŒ‡æ ‡
                value = await self._query_prometheus_metric(rule.metric_name)

                if value is not None:
                    # æ£€æŸ¥æ¡ä»¶
                    if self._evaluate_condition(value, rule.condition, rule.threshold):
                        # è§¦å‘å‘Šè­¦
                        await self._trigger_alert(rule, value)
                    else:
                        # æ£€æŸ¥æ˜¯å¦éœ€è¦è§£å†³å‘Šè­¦
                        await self._resolve_alert(rule_id)

        except Exception as e:
            logger.error(f"æ£€æŸ¥å‘Šè­¦å¤±è´¥: {e}")

    async def _query_prometheus_metric(self, metric_name: str) -> Optional[float]:
        """æŸ¥è¯¢PrometheusæŒ‡æ ‡"""
        try:
            prometheus_url = config.get("prometheus_url", "http://localhost:9090")
            query_url = f"{prometheus_url}/api/v1/query"

            params = {
                "query": metric_name,
                "time": datetime.now().timestamp()
            }

            async with httpx.AsyncClient() as client:
                response = await client.get(query_url, params=params)
                response.raise_for_status()

                data = response.json()
                if data.get("status") == "success":
                    result = data.get("data", {}).get("result", [])
                    if result:
                        return float(result[0].get("value", [0, 0])[1])

            return None

        except Exception as e:
            logger.error(f"æŸ¥è¯¢PrometheusæŒ‡æ ‡å¤±è´¥: {e}")
            return None

    def _evaluate_condition(self, value: float, condition: str, threshold: float) -> bool:
        """è¯„ä¼°æ¡ä»¶"""
        try:
            if condition == ">":
                return value > threshold
            elif condition == ">=":
                return value >= threshold
            elif condition == "<":
                return value < threshold
            elif condition == "<=":
                return value <= threshold
            elif condition == "==":
                return value == threshold
            elif condition == "!=":
                return value != threshold
            else:
                return False
        except Exception as e:
            logger.error(f"è¯„ä¼°æ¡ä»¶å¤±è´¥: {e}")
            return False

    async def _trigger_alert(self, rule: AlertRule, value: float):
        """è§¦å‘å‘Šè­¦"""
        try:
            # æ£€æŸ¥æ˜¯å¦å·²æœ‰æ´»è·ƒå‘Šè­¦
            existing_alert = None
            for alert in self.active_alerts:
                if alert.rule_id == rule.rule_id and alert.status == AlertStatus.ACTIVE:
                    existing_alert = alert
                    break

            if not existing_alert:
                # åˆ›å»ºæ–°å‘Šè­¦
                alert_id = f"{rule.rule_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                alert = Alert(
                    alert_id=alert_id,
                    rule_id=rule.rule_id,
                    name=rule.name,
                    description=rule.description,
                    level=rule.level,
                    status=AlertStatus.ACTIVE,
                    value=value,
                    threshold=rule.threshold,
                    triggered_at=datetime.now()
                )

                self.active_alerts.append(alert)
                self.alert_history.append(alert)

                logger.warning(f"è§¦å‘å‘Šè­¦: {alert.name} - {alert.description}")

                # å‘é€é€šçŸ¥
                await self._send_alert_notifications(alert)

        except Exception as e:
            logger.error(f"è§¦å‘å‘Šè­¦å¤±è´¥: {e}")

    async def _resolve_alert(self, rule_id: str):
        """è§£å†³å‘Šè­¦"""
        try:
            for alert in self.active_alerts:
                if alert.rule_id == rule_id and alert.status == AlertStatus.ACTIVE:
                    alert.status = AlertStatus.RESOLVED
                    alert.resolved_at = datetime.now()

                    logger.info(f"è§£å†³å‘Šè­¦: {alert.name}")

                    # å‘é€è§£å†³é€šçŸ¥
                    await self._send_alert_notifications(alert)

                    break

        except Exception as e:
            logger.error(f"è§£å†³å‘Šè­¦å¤±è´¥: {e}")

    async def _send_alert_notifications(self, alert: Alert):
        """å‘é€å‘Šè­¦é€šçŸ¥"""
        try:
            # è·å–å‘Šè­¦è§„åˆ™
            rule = self.alert_rules.get(alert.rule_id)
            if not rule:
                return

            # ä¸ºæ¯ä¸ªé€šçŸ¥æ¸ é“å‘é€é€šçŸ¥
            for channel in rule.notifications:
                try:
                    await self.notification_manager.send_notification(
                        channel, alert, rule
                    )
                    alert.notifications_sent.append(channel.value)
                except Exception as e:
                    logger.error(f"å‘é€{channel.value}é€šçŸ¥å¤±è´¥: {e}")

        except Exception as e:
            logger.error(f"å‘é€å‘Šè­¦é€šçŸ¥å¤±è´¥: {e}")

    async def start_alert_manager(self):
        """å¯åŠ¨å‘Šè­¦ç®¡ç†å™¨"""
        self.alert_manager_active = True
        logger.info("å‘Šè­¦ç®¡ç†å™¨å¯åŠ¨")

        while self.alert_manager_active:
            try:
                await self.check_alerts()
                await asyncio.sleep(self.check_interval)
            except Exception as e:
                logger.error(f"å‘Šè­¦ç®¡ç†å™¨é”™è¯¯: {e}")
                await asyncio.sleep(self.check_interval)

    async def stop_alert_manager(self):
        """åœæ­¢å‘Šè­¦ç®¡ç†å™¨"""
        self.alert_manager_active = False
        logger.info("å‘Šè­¦ç®¡ç†å™¨åœæ­¢")

    def get_active_alerts(self) -> List[Alert]:
        """è·å–æ´»è·ƒå‘Šè­¦"""
        return [alert for alert in self.active_alerts if alert.status == AlertStatus.ACTIVE]

    def get_alert_history(self, limit: int = 100) -> List[Alert]:
        """è·å–å‘Šè­¦å†å²"""
        return self.alert_history[-limit:]

    def acknowledge_alert(self, alert_id: str, acknowledged_by: str) -> bool:
        """ç¡®è®¤å‘Šè­¦"""
        try:
            for alert in self.active_alerts:
                if alert.alert_id == alert_id:
                    alert.status = AlertStatus.ACKNOWLEDGED
                    alert.acknowledged_at = datetime.now()
                    alert.acknowledged_by = acknowledged_by
                    logger.info(f"ç¡®è®¤å‘Šè­¦: {alert_id} by {acknowledged_by}")
                    return True
            return False
        except Exception as e:
            logger.error(f"ç¡®è®¤å‘Šè­¦å¤±è´¥: {e}")
            return False

    def suppress_alert(self, rule_id: str, duration: timedelta) -> bool:
        """æŠ‘åˆ¶å‘Šè­¦"""
        try:
            self.alert_suppressions[rule_id] = datetime.now() + duration
            logger.info(f"æŠ‘åˆ¶å‘Šè­¦: {rule_id} for {duration}")
            return True
        except Exception as e:
            logger.error(f"æŠ‘åˆ¶å‘Šè­¦å¤±è´¥: {e}")
            return False

class NotificationManager:
    """é€šçŸ¥ç®¡ç†å™¨"""

    def __init__(self):
        self.email_config = config.get("email", {})
        self.webhook_config = config.get("webhook", {})
        self.dingtalk_config = config.get("dingtalk", {})
        self.slack_config = config.get("slack", {})
        self.template_manager = TemplateManager()

    async def send_notification(self, channel: NotificationChannel, alert: Alert, rule: AlertRule):
        """å‘é€é€šçŸ¥"""
        try:
            if channel == NotificationChannel.EMAIL:
                await self._send_email_notification(alert, rule)
            elif channel == NotificationChannel.WEBHOOK:
                await self._send_webhook_notification(alert, rule)
            elif channel == NotificationChannel.DINGTALK:
                await self._send_dingtalk_notification(alert, rule)
            elif channel == NotificationChannel.SLACK:
                await self._send_slack_notification(alert, rule)
            else:
                logger.warning(f"ä¸æ”¯æŒçš„é€šçŸ¥æ¸ é“: {channel}")

        except Exception as e:
            logger.error(f"å‘é€{channel.value}é€šçŸ¥å¤±è´¥: {e}")

    async def _send_email_notification(self, alert: Alert, rule: AlertRule):
        """å‘é€é‚®ä»¶é€šçŸ¥"""
        try:
            if not self.email_config:
                return

            # è·å–æ¨¡æ¿
            template = self.template_manager.get_template("email_alert")
            if not template:
                return

            # æ¸²æŸ“æ¨¡æ¿
            subject = self.template_manager.render_template(
                template.subject_template,
                {
                    "alert": alert,
                    "rule": rule,
                    "timestamp": datetime.now()
                }
            )

            body = self.template_manager.render_template(
                template.body_template,
                {
                    "alert": alert,
                    "rule": rule,
                    "timestamp": datetime.now()
                }
            )

            # åˆ›å»ºé‚®ä»¶
            msg = MIMEMultipart()
            msg['From'] = self.email_config.get("from")
            msg['To'] = ", ".join(self.email_config.get("to", []))
            msg['Subject'] = subject

            msg.attach(MIMEText(body, 'html'))

            # å‘é€é‚®ä»¶
            with smtplib.SMTP(
                self.email_config.get("smtp_server"),
                self.email_config.get("smtp_port", 587)
            ) as server:
                if self.email_config.get("use_tls", True):
                    server.starttls()

                if self.email_config.get("username") and self.email_config.get("password"):
                    server.login(
                        self.email_config.get("username"),
                        self.email_config.get("password")
                    )

                server.send_message(msg)

            logger.info(f"å‘é€é‚®ä»¶é€šçŸ¥: {alert.name}")

        except Exception as e:
            logger.error(f"å‘é€é‚®ä»¶é€šçŸ¥å¤±è´¥: {e}")

    async def _send_webhook_notification(self, alert: Alert, rule: AlertRule):
        """å‘é€Webhooké€šçŸ¥"""
        try:
            if not self.webhook_config.get("url"):
                return

            # æ„å»ºé€šçŸ¥å†…å®¹
            payload = {
                "alert_id": alert.alert_id,
                "rule_name": rule.name,
                "alert_name": alert.name,
                "description": alert.description,
                "level": alert.level.value,
                "status": alert.status.value,
                "value": alert.value,
                "threshold": alert.threshold,
                "triggered_at": alert.triggered_at.isoformat(),
                "timestamp": datetime.now().isoformat()
            }

            # å‘é€Webhook
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.webhook_config["url"],
                    json=payload,
                    headers=self.webhook_config.get("headers", {}),
                    timeout=30
                )
                response.raise_for_status()

            logger.info(f"å‘é€Webhooké€šçŸ¥: {alert.name}")

        except Exception as e:
            logger.error(f"å‘é€Webhooké€šçŸ¥å¤±è´¥: {e}")

    async def _send_dingtalk_notification(self, alert: Alert, rule: AlertRule):
        """å‘é€é’‰é’‰é€šçŸ¥"""
        try:
            if not self.dingtalk_config.get("webhook_url"):
                return

            # æ„å»ºé’‰é’‰æ¶ˆæ¯
            message = {
                "msgtype": "markdown",
                "markdown": {
                    "title": f"ğŸš¨ {alert.level.value.upper()} - {alert.name}",
                    "text": f"""
## {alert.level.value.upper()} - {alert.name}

**æè¿°**: {alert.description}

**çº§åˆ«**: {alert.level.value}
**çŠ¶æ€**: {alert.status.value}
**æ•°å€¼**: {alert.value}
**é˜ˆå€¼**: {alert.threshold}

**è§¦å‘æ—¶é—´**: {alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S')}

---
*æ¥è‡ªæ•°æ®æ”¶é›†ä»£ç†ç›‘æ§ç³»ç»Ÿ*
                    """
                }
            }

            # å‘é€é’‰é’‰æ¶ˆæ¯
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.dingtalk_config["webhook_url"],
                    json=message,
                    timeout=30
                )
                response.raise_for_status()

            logger.info(f"å‘é€é’‰é’‰é€šçŸ¥: {alert.name}")

        except Exception as e:
            logger.error(f"å‘é€é’‰é’‰é€šçŸ¥å¤±è´¥: {e}")

    async def _send_slack_notification(self, alert: Alert, rule: AlertRule):
        """å‘é€Slacké€šçŸ¥"""
        try:
            if not self.slack_config.get("webhook_url"):
                return

            # æ„å»ºSlackæ¶ˆæ¯
            color = {
                AlertLevel.INFO: "good",
                AlertLevel.WARNING: "warning",
                AlertLevel.ERROR: "danger",
                AlertLevel.CRITICAL: "danger",
                AlertLevel.EMERGENCY: "danger"
            }.get(alert.level, "warning")

            message = {
                "attachments": [
                    {
                        "color": color,
                        "title": f"{alert.level.value.upper()} - {alert.name}",
                        "text": alert.description,
                        "fields": [
                            {"title": "çº§åˆ«", "value": alert.level.value, "short": True},
                            {"title": "çŠ¶æ€", "value": alert.status.value, "short": True},
                            {"title": "æ•°å€¼", "value": str(alert.value), "short": True},
                            {"title": "é˜ˆå€¼", "value": str(alert.threshold), "short": True},
                            {"title": "è§¦å‘æ—¶é—´", "value": alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S'), "short": False}
                        ],
                        "footer": "æ•°æ®æ”¶é›†ä»£ç†ç›‘æ§ç³»ç»Ÿ",
                        "ts": int(alert.triggered_at.timestamp())
                    }
                ]
            }

            # å‘é€Slackæ¶ˆæ¯
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.slack_config["webhook_url"],
                    json=message,
                    timeout=30
                )
                response.raise_for_status()

            logger.info(f"å‘é€Slacké€šçŸ¥: {alert.name}")

        except Exception as e:
            logger.error(f"å‘é€Slacké€šçŸ¥å¤±è´¥: {e}")

class TemplateManager:
    """æ¨¡æ¿ç®¡ç†å™¨"""

    def __init__(self):
        self.templates: Dict[str, NotificationTemplate] = {}
        self.jinja_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader("templates"),
            autoescape=True
        )
        self._load_default_templates()

    def _load_default_templates(self):
        """åŠ è½½é»˜è®¤æ¨¡æ¿"""
        # é‚®ä»¶å‘Šè­¦æ¨¡æ¿
        self.templates["email_alert"] = NotificationTemplate(
            template_id="email_alert",
            name="é‚®ä»¶å‘Šè­¦æ¨¡æ¿",
            channel=NotificationChannel.EMAIL,
            subject_template="ğŸš¨ {{ alert.level.value.upper() }} - {{ alert.name }}",
            body_template="""
            <html>
            <body>
                <h2>{{ alert.level.value.upper() }} - {{ alert.name }}</h2>
                <p><strong>æè¿°:</strong> {{ alert.description }}</p>
                <p><strong>çº§åˆ«:</strong> {{ alert.level.value }}</p>
                <p><strong>çŠ¶æ€:</strong> {{ alert.status.value }}</p>
                <p><strong>æ•°å€¼:</strong> {{ alert.value }}</p>
                <p><strong>é˜ˆå€¼:</strong> {{ alert.threshold }}</p>
                <p><strong>è§¦å‘æ—¶é—´:</strong> {{ alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S') }}</p>
                <hr>
                <p><em>æ¥è‡ªæ•°æ®æ”¶é›†ä»£ç†ç›‘æ§ç³»ç»Ÿ</em></p>
            </body>
            </html>
            """,
            variables=["alert", "rule", "timestamp"]
        )

    def add_template(self, template: NotificationTemplate) -> bool:
        """æ·»åŠ æ¨¡æ¿"""
        try:
            self.templates[template.template_id] = template
            logger.info(f"æ·»åŠ é€šçŸ¥æ¨¡æ¿: {template.name}")
            return True
        except Exception as e:
            logger.error(f"æ·»åŠ é€šçŸ¥æ¨¡æ¿å¤±è´¥: {e}")
            return False

    def get_template(self, template_id: str) -> Optional[NotificationTemplate]:
        """è·å–æ¨¡æ¿"""
        return self.templates.get(template_id)

    def render_template(self, template_content: str, context: Dict[str, Any]) -> str:
        """æ¸²æŸ“æ¨¡æ¿"""
        try:
            template = self.jinja_env.from_string(template_content)
            return template.render(**context)
        except Exception as e:
            logger.error(f"æ¸²æŸ“æ¨¡æ¿å¤±è´¥: {e}")
            return template_content

class DashboardManager:
    """ä»ªè¡¨æ¿ç®¡ç†å™¨"""

    def __init__(self):
        self.grafana_config = config.get("grafana", {})
        self.dashboards: Dict[str, Dict[str, Any]] = {}
        self._create_default_dashboards()

    def _create_default_dashboards(self):
        """åˆ›å»ºé»˜è®¤ä»ªè¡¨æ¿"""
        # ç³»ç»Ÿç›‘æ§ä»ªè¡¨æ¿
        self.dashboards["system_monitoring"] = {
            "title": "ç³»ç»Ÿç›‘æ§",
            "description": "ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µç›‘æ§",
            "panels": [
                {
                    "title": "CPUä½¿ç”¨ç‡",
                    "type": "graph",
                    "targets": ["system_cpu_usage_percent"],
                    "description": "CPUä½¿ç”¨ç‡ç›‘æ§"
                },
                {
                    "title": "å†…å­˜ä½¿ç”¨ç‡",
                    "type": "graph",
                    "targets": ["system_memory_usage_percent"],
                    "description": "å†…å­˜ä½¿ç”¨ç‡ç›‘æ§"
                },
                {
                    "title": "ç£ç›˜ä½¿ç”¨ç‡",
                    "type": "graph",
                    "targets": ["system_disk_usage_percent"],
                    "description": "ç£ç›˜ä½¿ç”¨ç‡ç›‘æ§"
                }
            ]
        }

        # ä¸šåŠ¡ç›‘æ§ä»ªè¡¨æ¿
        self.dashboards["business_monitoring"] = {
            "title": "ä¸šåŠ¡ç›‘æ§",
            "description": "ä¸šåŠ¡æ•°æ®æ”¶é›†ç›‘æ§",
            "panels": [
                {
                    "title": "æ•°æ®æ”¶é›†ç‡",
                    "type": "graph",
                    "targets": ["data_collection_rate"],
                    "description": "æ•°æ®æ”¶é›†é€Ÿç‡ç›‘æ§"
                },
                {
                    "title": "äº¤æ˜“æ‰€è¿æ¥æ•°",
                    "type": "graph",
                    "targets": ["exchange_connections_total"],
                    "description": "äº¤æ˜“æ‰€è¿æ¥æ•°ç›‘æ§"
                },
                {
                    "title": "ç¼“å­˜å‘½ä¸­ç‡",
                    "type": "graph",
                    "targets": ["cache_hit_rate"],
                    "description": "ç¼“å­˜å‘½ä¸­ç‡ç›‘æ§"
                }
            ]
        }

        # å‘Šè­¦ä»ªè¡¨æ¿
        self.dashboards["alert_dashboard"] = {
            "title": "å‘Šè­¦ä¸­å¿ƒ",
            "description": "ç³»ç»Ÿå‘Šè­¦çŠ¶æ€ç›‘æ§",
            "panels": [
                {
                    "title": "æ´»è·ƒå‘Šè­¦",
                    "type": "stat",
                    "targets": ["active_alerts_total"],
                    "description": "å½“å‰æ´»è·ƒå‘Šè­¦æ•°é‡"
                },
                {
                    "title": "å‘Šè­¦å†å²",
                    "type": "table",
                    "targets": ["alert_history"],
                    "description": "å‘Šè­¦å†å²è®°å½•"
                }
            ]
        }

    def create_dashboard(self, dashboard_id: str, title: str, panels: List[Dict[str, Any]]) -> bool:
        """åˆ›å»ºä»ªè¡¨æ¿"""
        try:
            self.dashboards[dashboard_id] = {
                "title": title,
                "panels": panels,
                "created_at": datetime.now()
            }
            logger.info(f"åˆ›å»ºä»ªè¡¨æ¿: {title}")
            return True
        except Exception as e:
            logger.error(f"åˆ›å»ºä»ªè¡¨æ¿å¤±è´¥: {e}")
            return False

    def get_dashboard(self, dashboard_id: str) -> Optional[Dict[str, Any]]:
        """è·å–ä»ªè¡¨æ¿"""
        return self.dashboards.get(dashboard_id)

    def list_dashboards(self) -> List[Dict[str, Any]]:
        """åˆ—å‡ºæ‰€æœ‰ä»ªè¡¨æ¿"""
        return [
            {"id": dashboard_id, **dashboard}
            for dashboard_id, dashboard in self.dashboards.items()
        ]

    def export_to_grafana(self, dashboard_id: str) -> bool:
        """å¯¼å‡ºåˆ°Grafana"""
        try:
            if not self.grafana_config:
                return False

            dashboard = self.dashboards.get(dashboard_id)
            if not dashboard:
                return False

            # æ„å»ºGrafanaä»ªè¡¨æ¿JSON
            grafana_dashboard = {
                "dashboard": {
                    "id": None,
                    "title": dashboard["title"],
                    "description": dashboard.get("description", ""),
                    "panels": self._convert_to_grafana_panels(dashboard["panels"]),
                    "time": {
                        "from": "now-1h",
                        "to": "now"
                    },
                    "refresh": "30s"
                },
                "overwrite": True
            }

            # å‘é€åˆ°Grafana
            grafana_url = f"{self.grafana_config['url']}/api/dashboards/db"
            headers = {
                "Authorization": f"Bearer {self.grafana_config['api_key']}",
                "Content-Type": "application/json"
            }

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    grafana_url,
                    json=grafana_dashboard,
                    headers=headers
                )
                response.raise_for_status()

            logger.info(f"å¯¼å‡ºä»ªè¡¨æ¿åˆ°Grafana: {dashboard_id}")
            return True

        except Exception as e:
            logger.error(f"å¯¼å‡ºä»ªè¡¨æ¿åˆ°Grafanaå¤±è´¥: {e}")
            return False

    def _convert_to_grafana_panels(self, panels: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """è½¬æ¢ä¸ºGrafanaé¢æ¿æ ¼å¼"""
        grafana_panels = []

        for i, panel in enumerate(panels):
            grafana_panel = {
                "id": i + 1,
                "title": panel["title"],
                "type": panel.get("type", "graph"),
                "description": panel.get("description", ""),
                "targets": []
            }

            for target in panel.get("targets", []):
                grafana_panel["targets"].append({
                    "expr": target,
                    "legendFormat": target
                })

            grafana_panels.append(grafana_panel)

        return grafana_panels

# å…¨å±€å®ä¾‹
metrics_collector = MetricsCollector()
alert_manager = AlertManager()
dashboard_manager = DashboardManager()

# å¯åŠ¨ç›‘æ§æœåŠ¡
async def start_monitoring_service():
    """å¯åŠ¨ç›‘æ§æœåŠ¡"""
    logger.info("å¯åŠ¨ç›‘æ§æœåŠ¡...")

    # å¯åŠ¨æŒ‡æ ‡æ”¶é›†å™¨
    collector_task = asyncio.create_task(metrics_collector.start_collection())

    # å¯åŠ¨å‘Šè­¦ç®¡ç†å™¨
    alert_task = asyncio.create_task(alert_manager.start_alert_manager())

    # å¯åŠ¨PrometheusæŒ‡æ ‡æœåŠ¡å™¨
    prometheus_port = config.get("prometheus_port", 8000)
    start_http_server(prometheus_port)

    logger.info(f"ç›‘æ§æœåŠ¡å¯åŠ¨å®Œæˆï¼ŒPrometheusç«¯å£: {prometheus_port}")

    return collector_task, alert_task

# åˆå§‹åŒ–å‡½æ•°
async def initialize_monitoring_service():
    """åˆå§‹åŒ–ç›‘æ§æœåŠ¡"""
    logger.info("åˆå§‹åŒ–ç›‘æ§æœåŠ¡...")

    # åŠ è½½å‘Šè­¦è§„åˆ™
    await load_alert_rules()

    # å¯åŠ¨ç›‘æ§æœåŠ¡
    await start_monitoring_service()

    logger.info("ç›‘æ§æœåŠ¡åˆå§‹åŒ–å®Œæˆ")

async def load_alert_rules():
    """åŠ è½½å‘Šè­¦è§„åˆ™"""
    try:
        # åˆ›å»ºé»˜è®¤å‘Šè­¦è§„åˆ™
        default_rules = [
            AlertRule(
                rule_id="cpu_usage_high",
                name="CPUä½¿ç”¨ç‡è¿‡é«˜",
                description="CPUä½¿ç”¨ç‡è¶…è¿‡80%",
                metric_name="system_cpu_usage_percent",
                condition=">",
                threshold=80.0,
                duration=timedelta(minutes=5),
                level=AlertLevel.WARNING,
                notifications=[NotificationChannel.EMAIL, NotificationChannel.DINGTALK]
            ),
            AlertRule(
                rule_id="memory_usage_high",
                name="å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜",
                description="å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡90%",
                metric_name="system_memory_usage_percent",
                condition=">",
                threshold=90.0,
                duration=timedelta(minutes=5),
                level=AlertLevel.ERROR,
                notifications=[NotificationChannel.EMAIL, NotificationChannel.DINGTALK]
            ),
            AlertRule(
                rule_id="data_collection_rate_low",
                name="æ•°æ®æ”¶é›†é€Ÿç‡è¿‡ä½",
                description="æ•°æ®æ”¶é›†é€Ÿç‡ä½äºé¢„æœŸ",
                metric_name="data_collection_rate",
                condition="<",
                threshold=100.0,
                duration=timedelta(minutes=10),
                level=AlertLevel.WARNING,
                notifications=[NotificationChannel.EMAIL]
            )
        ]

        for rule in default_rules:
            alert_manager.add_alert_rule(rule)

        logger.info(f"åŠ è½½äº† {len(default_rules)} ä¸ªé»˜è®¤å‘Šè­¦è§„åˆ™")

    except Exception as e:
        logger.error(f"åŠ è½½å‘Šè­¦è§„åˆ™å¤±è´¥: {e}")

if __name__ == "__main__":
    # ç¤ºä¾‹ä½¿ç”¨
    import asyncio

    async def main():
        await initialize_monitoring_service()

        # ä¿æŒè¿è¡Œ
        try:
            while True:
                await asyncio.sleep(60)
        except KeyboardInterrupt:
            logger.info("ç›‘æ§æœåŠ¡åœæ­¢")

    asyncio.run(main())
```

## æ¥å—æ ‡å‡†

### å¿…é¡»æ»¡è¶³çš„æ¡ä»¶
- [ ] å®ç°å®Œæ•´çš„PrometheusæŒ‡æ ‡æ”¶é›†ç³»ç»Ÿ
- [ ] æ”¯æŒå¤šç§å‘Šè­¦è§„åˆ™é…ç½®å’Œæ¡ä»¶è¯„ä¼°
- [ ] æä¾›å¤šæ¸ é“å‘Šè­¦é€šçŸ¥æœºåˆ¶
- [ ] åˆ›å»ºGrafanaå¯è§†åŒ–ä»ªè¡¨æ¿
- [ ] å®ç°ç³»ç»ŸæŒ‡æ ‡å’Œä¸šåŠ¡æŒ‡æ ‡æ”¶é›†
- [ ] æ”¯æŒå‘Šè­¦ç¡®è®¤å’ŒæŠ‘åˆ¶åŠŸèƒ½
- [ ] æä¾›å‘Šè­¦å†å²è®°å½•å’Œç»Ÿè®¡
- [ ] å®ç°æ¨¡æ¿åŒ–é€šçŸ¥ç³»ç»Ÿ
- [ ] æ”¯æŒAlertManageré›†æˆ
- [ ] é€šè¿‡æ€§èƒ½æµ‹è¯•å’Œå®‰å…¨æµ‹è¯•

### æ€§èƒ½è¦æ±‚
- **æŒ‡æ ‡æ”¶é›†å»¶è¿Ÿ**: < 1ç§’
- **å‘Šè­¦å“åº”æ—¶é—´**: < 5ç§’
- **é€šçŸ¥å‘é€å»¶è¿Ÿ**: < 10ç§’
- **ä»ªè¡¨æ¿åˆ·æ–°é¢‘ç‡**: 30ç§’
- **ç³»ç»Ÿèµ„æºå ç”¨**: < 5% CPU, < 1GBå†…å­˜
- **å¹¶å‘å¤„ç†èƒ½åŠ›**: æ”¯æŒ1000+æŒ‡æ ‡/ç§’

### æŠ€æœ¯è§„èŒƒ
- ä½¿ç”¨Prometheusä½œä¸ºæŒ‡æ ‡å­˜å‚¨
- å®ç°å¼‚æ­¥å¤„ç†æ¶æ„
- æ”¯æŒåˆ†å¸ƒå¼éƒ¨ç½²
- å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- ç¬¦åˆç›‘æ§æœ€ä½³å®è·µ

## å®ç°æ­¥éª¤

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ç›‘æ§æ¶æ„ (3å¤©)
1. å®ç°PrometheusæŒ‡æ ‡æ”¶é›†
2. åˆ›å»ºåŸºç¡€ç³»ç»ŸæŒ‡æ ‡æ”¶é›†
3. å®ç°ä¸šåŠ¡æŒ‡æ ‡æ”¶é›†
4. æ·»åŠ æŒ‡æ ‡æ¨é€æœºåˆ¶

### ç¬¬äºŒé˜¶æ®µï¼šå‘Šè­¦ç³»ç»Ÿ (4å¤©)
1. å®ç°å‘Šè­¦è§„åˆ™ç®¡ç†
2. å¼€å‘æ¡ä»¶è¯„ä¼°å¼•æ“
3. åˆ›å»ºå‘Šè­¦è§¦å‘æœºåˆ¶
4. æ·»åŠ å‘Šè­¦å†å²è®°å½•

### ç¬¬ä¸‰é˜¶æ®µï¼šé€šçŸ¥ç³»ç»Ÿ (3å¤©)
1. å®ç°å¤šæ¸ é“é€šçŸ¥æœºåˆ¶
2. å¼€å‘æ¨¡æ¿åŒ–é€šçŸ¥ç³»ç»Ÿ
3. é›†æˆé‚®ä»¶ã€é’‰é’‰ã€Slackç­‰
4. æ·»åŠ é€šçŸ¥é‡è¯•æœºåˆ¶

### ç¬¬å››é˜¶æ®µï¼šä»ªè¡¨æ¿å’Œé›†æˆ (4å¤©)
1. åˆ›å»ºGrafanaä»ªè¡¨æ¿
2. é›†æˆAlertManager
3. å®ç°å‘Šè­¦ç¡®è®¤å’ŒæŠ‘åˆ¶
4. å®Œå–„ç›‘æ§é…ç½®å’Œæ–‡æ¡£

## äº¤ä»˜ç‰©

### æ–‡æ¡£
- ç›‘æ§ç³»ç»Ÿæ¶æ„æ–‡æ¡£
- å‘Šè­¦è§„åˆ™é…ç½®æŒ‡å—
- é€šçŸ¥ç³»ç»Ÿé…ç½®æ–‡æ¡£
- Grafanaä»ªè¡¨æ¿ä½¿ç”¨æŒ‡å—

### ä»£ç 
- æŒ‡æ ‡æ”¶é›†æ¨¡å—
- å‘Šè­¦ç®¡ç†æ¨¡å—
- é€šçŸ¥ç®¡ç†æ¨¡å—
- ä»ªè¡¨æ¿ç®¡ç†æ¨¡å—
- å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- æ€§èƒ½æµ‹è¯•è„šæœ¬

### é…ç½®
- Prometheusé…ç½®æ–‡ä»¶
- Grafanaä»ªè¡¨æ¿é…ç½®
- å‘Šè­¦è§„åˆ™é…ç½®
- é€šçŸ¥æ¸ é“é…ç½®
- AlertManageré…ç½®

## é£é™©å’Œä¾èµ–

### æŠ€æœ¯é£é™©
- Prometheusæ€§èƒ½ç“¶é¢ˆ
- å‘Šè­¦è§„åˆ™å¤æ‚æ€§
- é€šçŸ¥æ¸ é“å¯é æ€§
- ä»ªè¡¨æ¿å®šåˆ¶å¤æ‚æ€§

### ä¾èµ–å…³ç³»
- ä¾èµ–äºPrometheusæœåŠ¡å™¨
- ä¾èµ–äºGrafanaæœåŠ¡å™¨
- ä¾èµ–äºAlertManager
- ä¾èµ–äºå¤–éƒ¨é€šçŸ¥æœåŠ¡

### ç¼“è§£æªæ–½
- å®ç°æŒ‡æ ‡é‡‡æ ·å’Œèšåˆ
- æ·»åŠ å‘Šè­¦è§„åˆ™éªŒè¯
- å®ç°é€šçŸ¥é‡è¯•æœºåˆ¶
- æä¾›ä»ªè¡¨æ¿æ¨¡æ¿åº“

## éªŒæ”¶æ ‡å‡†
- ç›‘æ§æŒ‡æ ‡å®Œæ•´ä¸”å‡†ç¡®
- å‘Šè­¦ç³»ç»Ÿçµæ•å¯é 
- é€šçŸ¥æœºåˆ¶ç¨³å®šåŠæ—¶
- ä»ªè¡¨æ¿å±•ç¤ºæ¸…æ™°
- ç³»ç»Ÿæ€§èƒ½è¾¾åˆ°è¦æ±‚
- é…ç½®çµæ´»æ˜“äºç»´æŠ¤
- æ–‡æ¡£é½å…¨ä¸”æ˜“æ‡‚