---
name: Exchange Manager - 多交易所连接管理
type: task
epic: 数据收集代理
status: open
priority: 2
created: 2025-09-25T20:20:35Z
estimated: 8 days
assigned: [待分配]
parallelizable: true
dependencies: ["001", "002"]
---

# 任务: Exchange Manager - 多交易所连接管理

## 任务描述
实现基于CCXT库的多交易所统一连接管理器，提供连接池管理、负载均衡、故障转移和API速率限制管理功能，为整个数据收集系统提供稳定、高效的交易所连接服务。

## 技术要求

### 核心架构设计

#### Exchange Manager 组件
- **连接管理**: 管理与多个交易所的连接生命周期
- **连接池**: 实现连接复用和资源管理
- **负载均衡**: 智能分配请求到最优交易所实例
- **故障转移**: 自动检测和恢复失败的连接
- **速率限制**: 智能管理和遵守各交易所的API限制

#### 技术栈
- **核心库**: CCXT 4.0+
- **并发处理**: AsyncIO + asyncio
- **连接管理**: 自定义连接池实现
- **监控**: Prometheus指标收集
- **缓存**: Redis连接状态缓存

### 实现架构

```python
# src/exchanges/manager.py
import asyncio
import ccxt
import time
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass
from enum import Enum
import logging
import aiohttp
from ..core.config import config
from ..core.logger import get_logger
from ..core.metrics import metrics
from ..core.exceptions import ExchangeError, RateLimitError, NetworkError

class ExchangeStatus(Enum):
    """交易所状态枚举"""
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    OFFLINE = "offline"
    MAINTENANCE = "maintenance"

class ConnectionStrategy(Enum):
    """连接策略枚举"""
    ROUND_ROBIN = "round_robin"
    LEAST_LATENCY = "least_latency"
    WEIGHTED_ROUND_ROBIN = "weighted_round_robin"
    FAILOVER = "failover"

@dataclass
class ExchangeConnection:
    """交易所连接信息"""
    exchange_id: str
    exchange: ccxt.Exchange
    status: ExchangeStatus
    last_ping: float
    latency: float
    error_count: int
    success_count: int
    rate_limits: Dict[str, Any]
    session: aiohttp.ClientSession
    weight: int = 100

class ExchangeManager:
    """交易所管理器"""

    def __init__(self):
        self.connections: Dict[str, ExchangeConnection] = {}
        self.connection_strategy = ConnectionStrategy.WEIGHTED_ROUND_ROBIN
        self.current_index = 0
        self.logger = get_logger("exchange_manager")
        self.health_check_interval = 30  # 30秒健康检查
        self.max_retries = 3
        self.retry_delay = 1
        self.timeout = 10
        self._running = False
        self._health_check_task = None

    async def initialize(self):
        """初始化交易所管理器"""
        try:
            # 从配置加载交易所配置
            exchange_configs = config.get('exchanges', {})

            for exchange_name, exchange_config in exchange_configs.items():
                if not exchange_config.get('enabled', True):
                    continue

                await self._add_exchange(exchange_name, exchange_config)

            # 启动健康检查
            self._running = True
            self._health_check_task = asyncio.create_task(self._health_check_loop())

            self.logger.info(f"Exchange Manager 初始化完成，共加载 {len(self.connections)} 个交易所")

        except Exception as e:
            self.logger.error(f"Exchange Manager 初始化失败: {e}")
            raise

    async def _add_exchange(self, exchange_name: str, exchange_config: Dict[str, Any]):
        """添加交易所连接"""
        try:
            # 创建CCXT实例
            exchange_class = getattr(ccxt, exchange_name)
            exchange = exchange_class({
                'apiKey': exchange_config.get('api_key'),
                'secret': exchange_config.get('api_secret'),
                'password': exchange_config.get('passphrase'),
                'sandbox': exchange_config.get('sandbox', False),
                'enableRateLimit': True,
                'timeout': self.timeout * 1000,  # CCXT使用毫秒
                'verbose': False,
                'options': {
                    'defaultType': 'spot',  # 默认现货交易
                }
            })

            # 创建异步会话
            session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=self.timeout),
                connector=aiohttp.TCPConnector(
                    limit=100,
                    limit_per_host=30,
                    ttl_dns_cache=300,
                    use_dns_cache=True,
                )
            )

            # 创建连接对象
            connection = ExchangeConnection(
                exchange_id=exchange_name,
                exchange=exchange,
                status=ExchangeStatus.HEALTHY,
                last_ping=time.time(),
                latency=0,
                error_count=0,
                success_count=0,
                rate_limits=exchange.rate_limits or {},
                session=session,
                weight=exchange_config.get('weight', 100)
            )

            self.connections[exchange_name] = connection
            self.logger.info(f"交易所 {exchange_name} 连接已创建")

        except Exception as e:
            self.logger.error(f"创建交易所 {exchange_name} 连接失败: {e}")
            raise

    async def execute_request(self, method: str, *args, **kwargs) -> Any:
        """执行交易所请求"""
        exchanges = await self._get_available_exchanges()

        if not exchanges:
            raise ExchangeError("没有可用的交易所连接")

        last_error = None

        for attempt in range(self.max_retries):
            for exchange in exchanges:
                try:
                    # 检查速率限制
                    await self._check_rate_limit(exchange.exchange_id, method)

                    # 执行请求
                    start_time = time.time()
                    result = await self._execute_exchange_request(exchange, method, *args, **kwargs)
                    latency = (time.time() - start_time) * 1000

                    # 更新统计信息
                    exchange.success_count += 1
                    exchange.latency = exchange.latency * 0.8 + latency * 0.2  # 平滑移动平均
                    exchange.last_ping = time.time()

                    # 记录指标
                    metrics.record_data_collection(
                        exchange=exchange.exchange_id,
                        data_type=method,
                        status="success"
                    )

                    return result

                except RateLimitError as e:
                    self.logger.warning(f"交易所 {exchange.exchange_id} 速率限制: {e}")
                    exchange.error_count += 1
                    last_error = e
                    await self._handle_rate_limit(exchange.exchange_id)
                    continue

                except NetworkError as e:
                    self.logger.warning(f"交易所 {exchange.exchange_id} 网络错误: {e}")
                    exchange.error_count += 1
                    last_error = e
                    continue

                except Exception as e:
                    self.logger.error(f"交易所 {exchange.exchange_id} 请求失败: {e}")
                    exchange.error_count += 1
                    last_error = e
                    continue

            # 重试延迟
            if attempt < self.max_retries - 1:
                await asyncio.sleep(self.retry_delay * (2 ** attempt))

        raise last_error or ExchangeError("所有交易所请求失败")

    async def _execute_exchange_request(self, connection: ExchangeConnection, method: str, *args, **kwargs) -> Any:
        """执行具体的交易所请求"""
        exchange_method = getattr(connection.exchange, method)

        if asyncio.iscoroutinefunction(exchange_method):
            return await exchange_method(*args, **kwargs)
        else:
            # 同步方法在线程池中执行
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(None, exchange_method, *args, **kwargs)

    async def _get_available_exchanges(self) -> List[ExchangeConnection]:
        """获取可用的交易所连接列表"""
        available = []

        for connection in self.connections.values():
            if connection.status == ExchangeStatus.HEALTHY:
                available.append(connection)
            elif connection.status == ExchangeStatus.DEGRADED:
                # 降级状态也有50%概率使用
                if len(available) == 0 or (connection.error_count / (connection.success_count + 1)) < 0.1:
                    available.append(connection)

        # 根据策略排序
        return self._sort_exchanges_by_strategy(available)

    def _sort_exchanges_by_strategy(self, exchanges: List[ExchangeConnection]) -> List[ExchangeConnection]:
        """根据连接策略排序交易所"""
        if self.connection_strategy == ConnectionStrategy.LEAST_LATENCY:
            return sorted(exchanges, key=lambda x: x.latency)
        elif self.connection_strategy == ConnectionStrategy.WEIGHTED_ROUND_ROBIN:
            return sorted(exchanges, key=lambda x: x.weight, reverse=True)
        elif self.connection_strategy == ConnectionStrategy.ROUND_ROBIN:
            # 简单的轮询实现
            self.current_index = (self.current_index + 1) % len(exchanges) if exchanges else 0
            return exchanges[self.current_index:] + exchanges[:self.current_index]
        else:
            return exchanges

    async def _check_rate_limit(self, exchange_id: str, method: str):
        """检查速率限制"""
        connection = self.connections.get(exchange_id)
        if not connection:
            return

        # 获取当前速率限制状态
        rate_limit_key = f"rate_limit:{exchange_id}:{method}"
        current_time = time.time()

        # 这里应该从Redis或其他缓存中获取速率限制状态
        # 简化实现，实际应该使用更复杂的速率限制算法
        pass

    async def _handle_rate_limit(self, exchange_id: str):
        """处理速率限制"""
        connection = self.connections.get(exchange_id)
        if connection:
            # 短期内降低该交易所的权重
            connection.weight = max(10, connection.weight // 2)
            # 标记为降级状态
            connection.status = ExchangeStatus.DEGRADED

    async def _health_check_loop(self):
        """健康检查循环"""
        while self._running:
            try:
                await self._perform_health_checks()
                await asyncio.sleep(self.health_check_interval)
            except Exception as e:
                self.logger.error(f"健康检查失败: {e}")
                await asyncio.sleep(5)  # 错误后等待5秒再重试

    async def _perform_health_checks(self):
        """执行健康检查"""
        tasks = []

        for connection in self.connections.values():
            task = asyncio.create_task(self._check_exchange_health(connection))
            tasks.append(task)

        await asyncio.gather(*tasks, return_exceptions=True)

    async def _check_exchange_health(self, connection: ExchangeConnection):
        """检查单个交易所健康状态"""
        try:
            # 使用ping或获取服务器时间作为健康检查
            start_time = time.time()

            if hasattr(connection.exchange, 'ping'):
                await self._execute_exchange_request(connection, 'ping')
            else:
                await self._execute_exchange_request(connection, 'fetch_time')

            latency = (time.time() - start_time) * 1000

            # 更新连接状态
            connection.latency = latency
            connection.last_ping = time.time()

            # 根据延迟和错误率确定状态
            error_rate = connection.error_count / (connection.success_count + connection.error_count + 1)

            if latency > 5000 or error_rate > 0.5:
                connection.status = ExchangeStatus.DEGRADED
            elif latency > 10000 or error_rate > 0.8:
                connection.status = ExchangeStatus.OFFLINE
            else:
                connection.status = ExchangeStatus.HEALTHY
                # 逐渐恢复权重
                connection.weight = min(100, connection.weight + 5)

        except Exception as e:
            self.logger.error(f"交易所 {connection.exchange_id} 健康检查失败: {e}")
            connection.error_count += 1
            connection.status = ExchangeStatus.OFFLINE

    async def get_exchange_status(self, exchange_id: str = None) -> Dict[str, Any]:
        """获取交易所状态"""
        if exchange_id:
            connection = self.connections.get(exchange_id)
            if connection:
                return {
                    "exchange_id": connection.exchange_id,
                    "status": connection.status.value,
                    "latency": connection.latency,
                    "success_count": connection.success_count,
                    "error_count": connection.error_count,
                    "last_ping": connection.last_ping,
                    "weight": connection.weight
                }
            return {}

        return {
            exchange_id: {
                "status": conn.status.value,
                "latency": conn.latency,
                "success_count": conn.success_count,
                "error_count": conn.error_count,
                "last_ping": conn.last_ping,
                "weight": conn.weight
            }
            for exchange_id, conn in self.connections.items()
        }

    async def close(self):
        """关闭所有连接"""
        self._running = False

        if self._health_check_task:
            self._health_check_task.cancel()
            try:
                await self._health_check_task
            except asyncio.CancelledError:
                pass

        # 关闭所有连接
        for connection in self.connections.values():
            try:
                await connection.session.close()
                if hasattr(connection.exchange, 'close'):
                    await self._execute_exchange_request(connection, 'close')
            except Exception as e:
                self.logger.error(f"关闭交易所 {connection.exchange_id} 连接失败: {e}")

        self.connections.clear()
        self.logger.info("Exchange Manager 已关闭")

# 全局交易所管理器实例
exchange_manager = ExchangeManager()
```

### 速率限制管理器

```python
# src/exchanges/rate_limiter.py
import time
import asyncio
from typing import Dict, List, Tuple
from dataclasses import dataclass
from collections import defaultdict, deque
import redis.asyncio as redis
from ..core.config import config
from ..core.logger import get_logger

@dataclass
class RateLimitInfo:
    """速率限制信息"""
    limit: int
    window: int  # 时间窗口（秒）
    remaining: int
    reset_time: float
    requests: deque  # 请求时间戳队列

class RateLimiter:
    """速率限制管理器"""

    def __init__(self, redis_client: redis.Redis = None):
        self.redis_client = redis_client
        self.logger = get_logger("rate_limiter")
        self.local_limits: Dict[str, RateLimitInfo] = defaultdict(lambda: None)
        self.use_redis = redis_client is not None

    async def acquire_permit(self, exchange_id: str, method: str) -> bool:
        """获取请求许可"""
        key = f"{exchange_id}:{method}"

        # 优先使用Redis进行分布式限制
        if self.use_redis:
            return await self._acquire_redis_permit(key)
        else:
            return await self._acquire_local_permit(key)

    async def _acquire_redis_permit(self, key: str) -> bool:
        """基于Redis的分布式速率限制"""
        try:
            # 使用Redis的滑动窗口算法
            current_time = time.time()
            window = 60  # 1分钟窗口

            # 添加当前请求时间戳
            pipe = self.redis_client.pipeline()
            pipe.zadd(f"rate_limit:{key}", {str(current_time): current_time})
            pipe.zremrangebyscore(f"rate_limit:{key}", 0, current_time - window)
            pipe.zcard(f"rate_limit:{key}")
            pipe.expire(f"rate_limit:{key}", window)

            results = await pipe.execute()
            request_count = results[2]

            # 获取速率限制配置（这里应该从配置中获取）
            limit = 100  # 默认限制

            if request_count <= limit:
                return True
            else:
                return False

        except Exception as e:
            self.logger.error(f"Redis速率限制失败: {e}")
            # 降级到本地限制
            return await self._acquire_local_permit(key)

    async def _acquire_local_permit(self, key: str) -> bool:
        """本地速率限制"""
        if key not in self.local_limits:
            self.local_limits[key] = RateLimitInfo(
                limit=100,
                window=60,
                remaining=100,
                reset_time=time.time() + 60,
                requests=deque()
            )

        limit_info = self.local_limits[key]
        current_time = time.time()

        # 清理过期的请求
        while limit_info.requests and limit_info.requests[0] <= current_time - limit_info.window:
            limit_info.requests.popleft()

        # 检查是否超过限制
        if len(limit_info.requests) >= limit_info.limit:
            return False

        # 添加请求
        limit_info.requests.append(current_time)
        limit_info.remaining = limit_info.limit - len(limit_info.requests)

        return True

    async def get_remaining_requests(self, exchange_id: str, method: str) -> int:
        """获取剩余请求数"""
        key = f"{exchange_id}:{method}"

        if self.use_redis:
            try:
                current_time = time.time()
                count = await self.redis_client.zcount(f"rate_limit:{key}", current_time - 60, current_time)
                return max(0, 100 - count)
            except Exception as e:
                self.logger.error(f"获取Redis剩余请求数失败: {e}")

        # 本地限制回退
        if key in self.local_limits:
            return self.local_limits[key].remaining
        return 100
```

## 接受标准

### 必须满足的条件
- [ ] 实现完整的多交易所连接管理器
- [ ] 支持至少5个主流交易所（Binance、OKX、Huobi、Coinbase、Kraken）
- [ ] 实现连接池和连接复用机制
- [ ] 支持多种负载均衡策略（轮询、最少延迟、加权轮询、故障转移）
- [ ] 实现智能故障检测和自动恢复机制
- [ ] 实现分布式速率限制管理
- [ ] 支持健康检查和状态监控
- [ ] 提供完整的API接口和配置管理
- [ ] 通过性能测试和稳定性测试

### 性能要求
- **连接延迟**: 新建连接延迟 < 1秒
- **请求延迟**: 正常请求延迟 < 500ms
- **故障恢复**: 故障检测时间 < 30秒，恢复时间 < 60秒
- **并发处理**: 支持1000+并发请求
- **速率限制**: 速率限制精度误差 < 1%

### 技术规范
- 使用AsyncIO实现异步并发
- 基于CCXT 4.0+统一交易所接口
- 实现连接池和资源管理
- 支持配置热更新
- 完整的错误处理和异常管理

## 实现步骤

### 第一阶段：基础架构 (2天)
1. 设计Exchange Manager核心架构
2. 实现交易所连接管理基础类
3. 实现连接池和会话管理
4. 创建基础的请求执行机制

### 第二阶段：负载均衡和故障转移 (2天)
1. 实现多种负载均衡策略
2. 开发故障检测机制
3. 实现自动故障转移
4. 添加健康检查功能

### 第三阶段：速率限制和监控 (2天)
1. 实现分布式速率限制
2. 开发连接状态监控
3. 集成Prometheus指标收集
4. 添加性能优化

### 第四阶段：测试和优化 (2天)
1. 编写单元测试和集成测试
2. 进行性能测试和压力测试
3. 优化并发处理和资源使用
4. 完善文档和配置

## 交付物

### 文档
- Exchange Manager设计文档
- API接口文档
- 配置说明文档
- 性能测试报告

### 代码
- Exchange Manager核心实现
- 速率限制管理器
- 连接池管理器
- 监控和指标收集器
- 单元测试和集成测试

### 配置
- 交易所配置模板
- 速率限制配置
- 监控配置
- 健康检查配置

## 风险和依赖

### 技术风险
- CCXT库版本兼容性问题
- 异步并发编程的复杂性
- 分布式速率限制的准确性

### 依赖关系
- 依赖于CCXT库的稳定性
- 依赖于Redis集群的可用性
- 依赖于网络环境的稳定性

### 缓解措施
- 实现版本兼容性检查
- 添加完善的错误处理和降级机制
- 实现本地速率限制作为备选方案

## 验收标准
- 成功连接所有配置的交易所
- 负载均衡策略正常工作
- 故障转移机制有效
- 速率限制精确控制
- 系统性能满足要求
- 监控指标完整准确