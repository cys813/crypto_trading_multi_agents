---
name: Position Manager - 仓位信息管理
type: task
epic: 数据收集代理
status: open
priority: 2
created: 2025-09-25T20:20:35Z
estimated: 10 days
assigned: [待分配]
parallelizable: true
dependencies: ["001", "002", "004"]
---

# 任务: Position Manager - 仓位信息管理

## 任务描述
实现实时仓位同步、PnL计算和仓位管理功能，提供准确的仓位信息、盈亏计算、风险评估和历史记录，为交易决策提供可靠的仓位数据支持。

## 技术要求

### 核心架构设计

#### Position Manager 组件
- **实时仓位同步**: 从各交易所获取实时仓位信息
- **PnL计算**: 实时计算未实现盈亏和已实现盈亏
- **风险评估**: 计算仓位风险指标和集中度风险
- **历史记录**: 跟踪仓位变更历史和审计信息
- **缓存优化**: 高效的仓位数据缓存策略

#### 技术栈
- **核心库**: Python 3.8+ + AsyncIO
- **数据库**: PostgreSQL (业务数据) + Redis (缓存)
- **计算**: NumPy (数值计算) + Pandas (数据分析)
- **监控**: Prometheus指标收集
- **API**: FastAPI异步接口

### 实现架构

```python
# src/managers/position_manager.py
import asyncio
import time
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from decimal import Decimal
import numpy as np
import pandas as pd
from enum import Enum
import logging
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete
from sqlalchemy.orm import selectinload

from ..core.config import config
from ..core.logger import get_logger
from ..core.metrics import metrics
from ..core.exceptions import PositionError, DataSyncError
from ..exchanges.manager import exchange_manager
from ..storage.postgresql import get_db_session
from ..storage.redis import redis_client
from ..models.position import CurrentPosition, PositionHistory

class PositionSide(Enum):
    """仓位方向枚举"""
    LONG = "long"
    SHORT = "short"
    BOTH = "both"

class PositionStatus(Enum):
    """仓位状态枚举"""
    OPEN = "open"
    CLOSED = "closed"
    LIQUIDATED = "liquidated"
    PARTIALLY_CLOSED = "partially_closed"

@dataclass
class PositionInfo:
    """仓位信息"""
    exchange: str
    symbol: str
    side: str
    amount: Decimal
    entry_price: Decimal
    mark_price: Decimal
    unrealized_pnl: Decimal
    realized_pnl: Decimal
    leverage: int
    margin_type: str
    liquidation_price: Decimal
    maintenance_margin: Decimal
    percentage: float  # 占总资产比例
    risk_score: float  # 风险评分
    created_at: datetime
    updated_at: datetime

@dataclass
class PositionSummary:
    """仓位汇总信息"""
    total_positions: int
    total_unrealized_pnl: Decimal
    total_realized_pnl: Decimal
    total_equity: Decimal
    total_margin: Decimal
    position_distribution: Dict[str, float]  # 交易所分布
    symbol_distribution: Dict[str, float]   # 交易对分布
    risk_metrics: Dict[str, float]           # 风险指标
    last_sync_time: datetime

class PositionManager:
    """仓位管理器"""

    def __init__(self):
        self.logger = get_logger("position_manager")
        self.sync_interval = 5  # 5秒同步一次
        self.cache_ttl = 30     # 缓存30秒
        self.risk_threshold = 0.1  # 风险阈值10%
        self._running = False
        self._sync_task = None
        self.position_cache: Dict[str, PositionInfo] = {}
        self.summary_cache: Optional[PositionSummary] = None

    async def initialize(self):
        """初始化仓位管理器"""
        try:
            # 加载现有仓位数据
            await self._load_positions_from_db()

            # 启动同步任务
            self._running = True
            self._sync_task = asyncio.create_task(self._sync_loop())

            self.logger.info("Position Manager 初始化完成")

        except Exception as e:
            self.logger.error(f"Position Manager 初始化失败: {e}")
            raise

    async def _load_positions_from_db(self):
        """从数据库加载仓位数据"""
        async with get_db_session() as session:
            result = await session.execute(
                select(CurrentPosition).where(CurrentPosition.amount > 0)
            )
            positions = result.scalars().all()

            for position in positions:
                position_info = PositionInfo(
                    exchange=position.exchange,
                    symbol=position.symbol,
                    side=position.side,
                    amount=Decimal(str(position.amount)),
                    entry_price=Decimal(str(position.entry_price)),
                    mark_price=Decimal(str(position.mark_price or position.entry_price)),
                    unrealized_pnl=Decimal(str(position.unrealized_pnl or 0)),
                    realized_pnl=Decimal(str(position.realized_pnl or 0)),
                    leverage=position.leverage or 1,
                    margin_type=position.margin_type or "isolated",
                    liquidation_price=Decimal(str(position.liquidation_price or 0)),
                    maintenance_margin=Decimal(str(position.maintenance_margin or 0)),
                    percentage=0.0,  # 稍后计算
                    risk_score=0.0,  # 稍后计算
                    created_at=position.created_at,
                    updated_at=position.updated_at
                )

                cache_key = f"{position.exchange}:{position.symbol}:{position.side}"
                self.position_cache[cache_key] = position_info

    async def _sync_loop(self):
        """同步循环"""
        while self._running:
            try:
                await self._sync_all_positions()
                await asyncio.sleep(self.sync_interval)
            except Exception as e:
                self.logger.error(f"仓位同步失败: {e}")
                await asyncio.sleep(1)  # 错误后等待1秒再重试

    async def _sync_all_positions(self):
        """同步所有交易所的仓位"""
        sync_tasks = []

        # 获取所有启用的交易所
        exchange_status = await exchange_manager.get_exchange_status()

        for exchange_id, status in exchange_status.items():
            if status.get('status') == 'healthy':
                task = asyncio.create_task(self._sync_exchange_positions(exchange_id))
                sync_tasks.append(task)

        if sync_tasks:
            await asyncio.gather(*sync_tasks, return_exceptions=True)

        # 更新汇总信息
        await self._update_position_summary()

    async def _sync_exchange_positions(self, exchange_id: str):
        """同步单个交易所的仓位"""
        try:
            start_time = time.time()

            # 从交易所获取仓位信息
            positions_data = await exchange_manager.execute_request(
                exchange_id, 'fetch_positions'
            )

            if not positions_data:
                self.logger.debug(f"交易所 {exchange_id} 无仓位数据")
                return

            # 处理仓位数据
            processed_positions = []
            for pos_data in positions_data:
                position_info = await self._process_position_data(exchange_id, pos_data)
                if position_info:
                    processed_positions.append(position_info)

            # 更新数据库
            await self._update_positions_db(exchange_id, processed_positions)

            # 更新缓存
            await self._update_positions_cache(exchange_id, processed_positions)

            # 记录指标
            latency = (time.time() - start_time) * 1000
            metrics.record_position_sync(
                exchange=exchange_id,
                positions_count=len(processed_positions),
                latency=latency,
                status="success"
            )

            self.logger.debug(f"交易所 {exchange_id} 仓位同步完成，共 {len(processed_positions)} 个仓位")

        except Exception as e:
            self.logger.error(f"同步交易所 {exchange_id} 仓位失败: {e}")
            metrics.record_position_sync(
                exchange=exchange_id,
                positions_count=0,
                latency=0,
                status="error"
            )
            raise

    async def _process_position_data(self, exchange_id: str, pos_data: Dict[str, Any]) -> Optional[PositionInfo]:
        """处理单个仓位数据"""
        try:
            # 过滤掉无效仓位
            if not pos_data.get('contracts') or float(pos_data.get('contracts', 0)) == 0:
                return None

            symbol = pos_data.get('symbol')
            side = pos_data.get('side', 'both').lower()
            amount = Decimal(str(pos_data.get('contracts', 0)))
            entry_price = Decimal(str(pos_data.get('entryPrice', 0)))
            mark_price = Decimal(str(pos_data.get('markPrice', entry_price)))

            # 计算未实现盈亏
            unrealized_pnl = Decimal(str(pos_data.get('unrealizedPnl', 0)))
            realized_pnl = Decimal(str(pos_data.get('realizedPnl', 0)))

            # 提取其他信息
            leverage = pos_data.get('leverage', 1)
            margin_type = pos_data.get('marginType', 'isolated')
            liquidation_price = Decimal(str(pos_data.get('liquidationPrice', 0)))
            maintenance_margin = Decimal(str(pos_data.get('maintenanceMargin', 0)))

            # 创建仓位信息对象
            position_info = PositionInfo(
                exchange=exchange_id,
                symbol=symbol,
                side=side,
                amount=amount,
                entry_price=entry_price,
                mark_price=mark_price,
                unrealized_pnl=unrealized_pnl,
                realized_pnl=realized_pnl,
                leverage=leverage,
                margin_type=margin_type,
                liquidation_price=liquidation_price,
                maintenance_margin=maintenance_margin,
                percentage=0.0,  # 稍后计算
                risk_score=0.0,  # 稍后计算
                created_at=datetime.now(),
                updated_at=datetime.now()
            )

            return position_info

        except Exception as e:
            self.logger.error(f"处理仓位数据失败: {e}")
            return None

    async def _update_positions_db(self, exchange_id: str, positions: List[PositionInfo]):
        """更新数据库中的仓位信息"""
        async with get_db_session() as session:
            for position_info in positions:
                # 检查是否存在
                result = await session.execute(
                    select(CurrentPosition).where(
                        CurrentPosition.exchange == exchange_id,
                        CurrentPosition.symbol == position_info.symbol,
                        CurrentPosition.side == position_info.side
                    )
                )

                existing_position = result.scalar_one_or_none()

                if existing_position:
                    # 更新现有仓位
                    await session.execute(
                        update(CurrentPosition).where(
                            CurrentPosition.id == existing_position.id
                        ).values(
                            amount=float(position_info.amount),
                            entry_price=float(position_info.entry_price),
                            mark_price=float(position_info.mark_price),
                            unrealized_pnl=float(position_info.unrealized_pnl),
                            realized_pnl=float(position_info.realized_pnl),
                            leverage=position_info.leverage,
                            margin_type=position_info.margin_type,
                            liquidation_price=float(position_info.liquidation_price),
                            maintenance_margin=float(position_info.maintenance_margin),
                            updated_at=position_info.updated_at
                        )
                    )
                else:
                    # 创建新仓位
                    new_position = CurrentPosition(
                        exchange=exchange_id,
                        symbol=position_info.symbol,
                        side=position_info.side,
                        amount=float(position_info.amount),
                        entry_price=float(position_info.entry_price),
                        mark_price=float(position_info.mark_price),
                        unrealized_pnl=float(position_info.unrealized_pnl),
                        realized_pnl=float(position_info.realized_pnl),
                        leverage=position_info.leverage,
                        margin_type=position_info.margin_type,
                        liquidation_price=float(position_info.liquidation_price),
                        maintenance_margin=float(position_info.maintenance_margin),
                        created_at=position_info.created_at,
                        updated_at=position_info.updated_at
                    )
                    session.add(new_position)

            await session.commit()

    async def _update_positions_cache(self, exchange_id: str, positions: List[PositionInfo]):
        """更新仓位缓存"""
        # 计算总资产用于计算百分比
        total_equity = await self._calculate_total_equity()

        for position_info in positions:
            # 计算风险评分
            risk_score = await self._calculate_position_risk(position_info, total_equity)

            # 计算占总资产比例
            if total_equity > 0:
                position_value = position_info.amount * position_info.mark_price
                position_info.percentage = float(position_value / total_equity)
            else:
                position_info.percentage = 0.0

            position_info.risk_score = risk_score

            # 更新缓存
            cache_key = f"{exchange_id}:{position_info.symbol}:{position_info.side}"
            self.position_cache[cache_key] = position_info

            # 同时更新Redis缓存
            await redis_client.setex(
                f"position:{cache_key}",
                self.cache_ttl,
                position_info.model_dump_json()
            )

    async def _calculate_total_equity(self) -> Decimal:
        """计算总资产"""
        total_equity = Decimal('0')

        for position_info in self.position_cache.values():
            position_value = position_info.amount * position_info.mark_price
            total_equity += position_value + position_info.unrealized_pnl + position_info.realized_pnl

        return total_equity

    async def _calculate_position_risk(self, position: PositionInfo, total_equity: Decimal) -> float:
        """计算仓位风险评分"""
        risk_score = 0.0

        try:
            # 1. 仓位集中度风险
            if total_equity > 0:
                position_value = position.amount * position.mark_price
                concentration_risk = float(position_value / total_equity)
                risk_score += concentration_risk * 0.4  # 40%权重
            else:
                risk_score += 0.4

            # 2. 杠杆风险
            leverage_risk = min(position.leverage / 10.0, 1.0)  # 标准化到0-1
            risk_score += leverage_risk * 0.3  # 30%权重

            # 3. 清算风险
            if position.liquidation_price > 0:
                distance_to_liquidation = abs(position.mark_price - position.liquidation_price) / position.mark_price
                liquidation_risk = max(0, 1.0 - distance_to_liquidation * 10)  # 距离越近风险越高
                risk_score += liquidation_risk * 0.3  # 30%权重
            else:
                risk_score += 0.1  # 现货仓位风险较低

            return min(risk_score, 1.0)  # 限制在0-1之间

        except Exception as e:
            self.logger.error(f"计算仓位风险失败: {e}")
            return 0.5  # 默认中等风险

    async def _update_position_summary(self):
        """更新仓位汇总信息"""
        try:
            if not self.position_cache:
                self.summary_cache = None
                return

            # 计算汇总数据
            total_positions = len(self.position_cache)
            total_unrealized_pnl = sum(pos.unrealized_pnl for pos in self.position_cache.values())
            total_realized_pnl = sum(pos.realized_pnl for pos in self.position_cache.values())
            total_equity = await self._calculate_total_equity()
            total_margin = sum(pos.amount * pos.entry_price / pos.leverage for pos in self.position_cache.values())

            # 计算分布
            exchange_distribution = {}
            symbol_distribution = {}

            for pos in self.position_cache.values():
                position_value = pos.amount * pos.mark_price

                # 交易所分布
                exchange_distribution[pos.exchange] = exchange_distribution.get(pos.exchange, 0) + float(position_value)

                # 交易对分布
                symbol_distribution[pos.symbol] = symbol_distribution.get(pos.symbol, 0) + float(position_value)

            # 转换为百分比
            if float(total_equity) > 0:
                for key in exchange_distribution:
                    exchange_distribution[key] = exchange_distribution[key] / float(total_equity)

                for key in symbol_distribution:
                    symbol_distribution[key] = symbol_distribution[key] / float(total_equity)

            # 计算风险指标
            risk_metrics = await self._calculate_portfolio_risk_metrics()

            # 创建汇总对象
            self.summary_cache = PositionSummary(
                total_positions=total_positions,
                total_unrealized_pnl=total_unrealized_pnl,
                total_realized_pnl=total_realized_pnl,
                total_equity=total_equity,
                total_margin=total_margin,
                position_distribution=exchange_distribution,
                symbol_distribution=symbol_distribution,
                risk_metrics=risk_metrics,
                last_sync_time=datetime.now()
            )

            # 缓存到Redis
            if self.summary_cache:
                await redis_client.setex(
                    "position_summary",
                    self.cache_ttl,
                    self.summary_cache.model_dump_json()
                )

        except Exception as e:
            self.logger.error(f"更新仓位汇总失败: {e}")

    async def _calculate_portfolio_risk_metrics(self) -> Dict[str, float]:
        """计算投资组合风险指标"""
        try:
            if not self.position_cache:
                return {}

            positions = list(self.position_cache.values())

            # 计算各个风险指标
            max_position_risk = max(pos.risk_score for pos in positions)
            avg_position_risk = sum(pos.risk_score for pos in positions) / len(positions)

            # 高风险仓位数量
            high_risk_positions = sum(1 for pos in positions if pos.risk_score > 0.7)

            # 杠杆率分析
            avg_leverage = sum(pos.leverage for pos in positions) / len(positions)
            max_leverage = max(pos.leverage for pos in positions)

            # 清算风险仓位数量
            liquidation_risk_positions = sum(1 for pos in positions if pos.liquidation_price > 0 and
                                            abs(pos.mark_price - pos.liquidation_price) / pos.mark_price < 0.1)

            return {
                "max_position_risk": max_position_risk,
                "avg_position_risk": avg_position_risk,
                "high_risk_positions": high_risk_positions,
                "avg_leverage": avg_leverage,
                "max_leverage": max_leverage,
                "liquidation_risk_positions": liquidation_risk_positions,
                "portfolio_concentration": max(pos.percentage for pos in positions),
                "total_positions": len(positions)
            }

        except Exception as e:
            self.logger.error(f"计算投资组合风险指标失败: {e}")
            return {}

    async def get_positions(self, exchange_id: str = None, symbol: str = None) -> List[PositionInfo]:
        """获取仓位信息"""
        try:
            positions = []

            for key, position in self.position_cache.items():
                if exchange_id and position.exchange != exchange_id:
                    continue
                if symbol and position.symbol != symbol:
                    continue
                positions.append(position)

            return positions

        except Exception as e:
            self.logger.error(f"获取仓位信息失败: {e}")
            return []

    async def get_position_summary(self) -> Optional[PositionSummary]:
        """获取仓位汇总信息"""
        return self.summary_cache

    async def get_position_history(self, exchange_id: str = None, symbol: str = None,
                                 days: int = 7) -> List[Dict[str, Any]]:
        """获取仓位历史记录"""
        try:
            async with get_db_session() as session:
                query = select(PositionHistory)

                if exchange_id:
                    query = query.where(PositionHistory.exchange == exchange_id)
                if symbol:
                    query = query.where(PositionHistory.symbol == symbol)

                # 限制时间范围
                start_date = datetime.now() - timedelta(days=days)
                query = query.where(PositionHistory.created_at >= start_date)

                query = query.order_by(PositionHistory.created_at.desc())
                result = await session.execute(query)

                history = []
                for record in result.scalars().all():
                    history.append({
                        "exchange": record.exchange,
                        "symbol": record.symbol,
                        "side": record.side,
                        "amount": record.amount,
                        "entry_price": record.entry_price,
                        "exit_price": record.exit_price,
                        "realized_pnl": record.realized_pnl,
                        "fees": record.fees,
                        "duration": record.duration,
                        "created_at": record.created_at,
                        "closed_at": record.closed_at
                    })

                return history

        except Exception as e:
            self.logger.error(f"获取仓位历史记录失败: {e}")
            return []

    async def close(self):
        """关闭仓位管理器"""
        self._running = False

        if self._sync_task:
            self._sync_task.cancel()
            try:
                await self._sync_task
            except asyncio.CancelledError:
                pass

        self.position_cache.clear()
        self.summary_cache = None
        self.logger.info("Position Manager 已关闭")

# 全局仓位管理器实例
position_manager = PositionManager()
```

## 接受标准

### 必须满足的条件
- [ ] 实现实时仓位同步功能，支持所有配置的交易所
- [ ] 提供准确的PnL计算（未实现盈亏和已实现盈亏）
- [ ] 实现风险评估机制，包括仓位集中度、杠杆和清算风险
- [ ] 支持仓位历史记录跟踪和审计
- [ ] 实现高效的缓存策略，减少数据库查询
- [ ] 提供仓位汇总信息和投资组合分析
- [ ] 支持多维度仓位查询和过滤
- [ ] 实现完整的监控和指标收集
- [ ] 通过性能测试和稳定性测试

### 性能要求
- **同步延迟**: 仓位同步延迟 < 5秒
- **查询性能**: 缓存查询响应时间 < 10ms
- **计算准确度**: PnL计算准确度 > 99.9%
- **并发处理**: 支持1000+并发查询请求
- **缓存命中率**: 热点数据缓存命中率 > 95%

### 技术规范
- 使用异步编程模型提高性能
- 实现数据一致性保证机制
- 支持配置热更新
- 完整的错误处理和异常管理
- 符合数据安全和隐私要求

## 实现步骤

### 第一阶段：基础架构 (3天)
1. 设计Position Manager核心架构
2. 创建仓位数据模型和数据库表
3. 实现基础仓位同步功能
4. 开发PnL计算逻辑

### 第二阶段：风险评估 (3天)
1. 实现仓位风险评估算法
2. 开发风险指标计算
3. 实现投资组合分析功能
4. 添加风险预警机制

### 第三阶段：缓存和优化 (2天)
1. 实现高效缓存策略
2. 优化数据库查询性能
3. 实现数据压缩和清理
4. 添加性能监控

### 第四阶段：测试和集成 (2天)
1. 编写单元测试和集成测试
2. 进行性能测试和压力测试
3. 与其他模块集成测试
4. 完善文档和配置

## 交付物

### 文档
- Position Manager设计文档
- 风险评估算法文档
- API接口文档
- 配置说明文档

### 代码
- Position Manager核心实现
- 仓位同步器
- PnL计算器
- 风险评估器
- 缓存管理器
- 单元测试和集成测试

### 配置
- 仓位同步配置
- 风险阈值配置
- 缓存策略配置
- 监控配置

## 风险和依赖

### 技术风险
- 仓位数据同步可能存在延迟
- PnL计算精度可能受交易所API影响
- 风险评估算法可能需要持续优化

### 依赖关系
- 依赖于Exchange Manager的稳定性
- 依赖于数据库性能和可用性
- 依赖于Redis缓存的稳定性

### 缓解措施
- 实现多级缓存和降级机制
- 添加数据验证和校验逻辑
- 实现异步处理和重试机制

## 验收标准
- 仓位数据同步准确及时
- PnL计算精确可靠
- 风险评估合理有效
- 系统性能满足要求
- 监控指标完整准确
- 用户接口友好易用