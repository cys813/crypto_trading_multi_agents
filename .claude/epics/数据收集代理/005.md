---
name: Data Collector - 市场数据收集功能
type: task
epic: 数据收集代理
status: open
priority: 2
created: 2025-09-25T20:20:35Z
estimated: 9 days
assigned: [待分配]
parallelizable: true
dependencies: ["001", "002"]
---

# 任务: Data Collector - 市场数据收集功能

## 任务描述
实现市场数据收集器，支持OHLCV、ticker、orderbook、trades数据的实时收集，包含智能调度、增量获取、质量监控和多时间框架支持，为整个交易系统提供高质量的市场数据。

## 技术要求

### 核心架构设计

#### 数据收集器组件
- **数据类型支持**: OHLCV、ticker、orderbook、trades
- **多时间框架**: 1m, 5m, 15m, 1h, 4h, 1d等时间框架
- **智能调度**: 基于优先级和负载的任务调度
- **增量获取**: 基于时间戳和ID驱动的增量数据同步
- **质量监控**: 实时数据验证和异常检测

#### 技术栈
- **异步处理**: AsyncIO + asyncio
- **数据存储**: TimescaleDB + Redis
- **队列管理**: Redis Streams或RabbitMQ
- **监控**: Prometheus + 自定义指标
- **验证**: 自定义数据验证规则

### 实现架构

```python
# src/collectors/market_data.py
import asyncio
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, AsyncIterator
from dataclasses import dataclass, asdict
from enum import Enum
import json
import pandas as pd
import numpy as np
from ..core.config import config
from ..core.logger import get_logger
from ..core.metrics import metrics
from ..core.exceptions import ValidationError, DataQualityError
from ..exchanges.manager import exchange_manager
from ..storage.timescaledb import TimescaleDBStorage
from ..storage.redis import RedisStorage

class DataType(Enum):
    """数据类型枚举"""
    OHLCV = "ohlcv"
    TICKER = "ticker"
    ORDERBOOK = "orderbook"
    TRADES = "trades"

class DataQuality(Enum):
    """数据质量等级"""
    EXCELLENT = "excellent"  # 优秀
    GOOD = "good"           # 良好
    FAIR = "fair"           # 一般
    POOR = "poor"           # 较差
    INVALID = "invalid"     # 无效

@dataclass
class OHLCVData:
    """OHLCV数据结构"""
    timestamp: datetime
    exchange: str
    symbol: str
    timeframe: str
    open: float
    high: float
    low: float
    close: float
    volume: float
    quote_volume: Optional[float] = None
    trades_count: Optional[int] = None
    quality: DataQuality = DataQuality.GOOD

@dataclass
class TickerData:
    """Ticker数据结构"""
    timestamp: datetime
    exchange: str
    symbol: str
    last_price: float
    bid_price: Optional[float] = None
    ask_price: Optional[float] = None
    bid_volume: Optional[float] = None
    ask_volume: Optional[float] = None
    volume_24h: Optional[float] = None
    quote_volume_24h: Optional[float] = None
    price_change_24h: Optional[float] = None
    price_change_percent_24h: Optional[float] = None
    quality: DataQuality = DataQuality.GOOD

@dataclass
class OrderBookData:
    """订单簿数据结构"""
    timestamp: datetime
    exchange: str
    symbol: str
    bids: List[List[float]]  # [[price, amount], ...]
    asks: List[List[float]]  # [[price, amount], ...]
    timestamp_ms: Optional[int] = None
    quality: DataQuality = DataQuality.GOOD

@dataclass
class TradeData:
    """交易数据结构"""
    timestamp: datetime
    exchange: str
    symbol: str
    trade_id: str
    price: float
    amount: float
    side: str  # 'buy' or 'sell'
    type: Optional[str] = None
    taker_or_maker: Optional[str] = None
    quality: DataQuality = DataQuality.GOOD

class DataCollector:
    """数据收集器主类"""

    def __init__(self):
        self.logger = get_logger("data_collector")
        self.timescaledb = TimescaleDBStorage()
        self.redis = RedisStorage()
        self.collectors = {
            DataType.OHLCV: OHLCVCollector(self),
            DataType.TICKER: TickerCollector(self),
            DataType.ORDERBOOK: OrderBookCollector(self),
            DataType.TRADES: TradesCollector(self)
        }
        self.scheduler = DataScheduler(self)
        self.quality_monitor = DataQualityMonitor(self)
        self._running = False

    async def initialize(self):
        """初始化数据收集器"""
        try:
            # 初始化存储层
            await self.timescaledb.initialize()
            await self.redis.initialize()

            # 初始化各个收集器
            for collector in self.collectors.values():
                await collector.initialize()

            # 初始化调度器
            await self.scheduler.initialize()

            # 初始化质量监控
            await self.quality_monitor.initialize()

            self.logger.info("数据收集器初始化完成")

        except Exception as e:
            self.logger.error(f"数据收集器初始化失败: {e}")
            raise

    async def start(self):
        """启动数据收集"""
        self._running = True

        # 启动各个收集器
        collector_tasks = []
        for data_type, collector in self.collectors.items():
            task = asyncio.create_task(collector.start())
            collector_tasks.append(task)

        # 启动调度器
        scheduler_task = asyncio.create_task(self.scheduler.start())

        # 启动质量监控
        quality_task = asyncio.create_task(self.quality_monitor.start())

        try:
            await asyncio.gather(*collector_tasks, scheduler_task, quality_task)
        except Exception as e:
            self.logger.error(f"数据收集器运行错误: {e}")
            await self.stop()
            raise

    async def stop(self):
        """停止数据收集"""
        self._running = False

        # 停止各个收集器
        for collector in self.collectors.values():
            await collector.stop()

        # 停止调度器
        await self.scheduler.stop()

        # 停止质量监控
        await self.quality_monitor.stop()

        self.logger.info("数据收集器已停止")

class OHLCVCollector:
    """OHLCV数据收集器"""

    def __init__(self, data_collector: DataCollector):
        self.data_collector = data_collector
        self.logger = get_logger("ohlcv_collector")
        self.config = config.get('collector.market_data', {})
        self.symbols = self.config.get('symbols', ['BTC/USDT'])
        self.timeframes = self.config.get('timeframes', ['1m', '5m', '15m', '1h', '4h', '1d'])
        self.interval = self.config.get('interval', 60)  # 默认60秒
        self.last_timestamps = {}  # 记录最后获取的时间戳

    async def initialize(self):
        """初始化OHLCV收集器"""
        self.logger.info(f"OHLCV收集器初始化，支持交易对: {self.symbols}，时间框架: {self.timeframes}")

    async def start(self):
        """启动OHLCV数据收集"""
        self.logger.info("OHLCV收集器启动")

        while self.data_collector._running:
            try:
                await self._collect_ohlcv_data()
                await asyncio.sleep(self.interval)
            except Exception as e:
                self.logger.error(f"OHLCV数据收集失败: {e}")
                await asyncio.sleep(5)  # 错误后等待5秒

    async def _collect_ohlcv_data(self):
        """收集OHLCV数据"""
        tasks = []

        for symbol in self.symbols:
            for timeframe in self.timeframes:
                task = asyncio.create_task(self._collect_symbol_ohlcv(symbol, timeframe))
                tasks.append(task)

        results = await asyncio.gather(*tasks, return_exceptions=True)

        for result in results:
            if isinstance(result, Exception):
                self.logger.error(f"OHLCV收集任务失败: {result}")
            else:
                await self._process_ohlcv_data(result)

    async def _collect_symbol_ohlcv(self, symbol: str, timeframe: str) -> List[OHLCVData]:
        """收集单个交易对的OHLCV数据"""
        try:
            # 获取增量数据
            since = self.last_timestamps.get((symbol, timeframe))

            # 从交易所获取数据
            ohlcv_data = await exchange_manager.execute_request(
                'fetch_ohlcv',
                symbol=symbol,
                timeframe=timeframe,
                since=since,
                limit=100  # 限制数量避免过量请求
            )

            if not ohlcv_data:
                return []

            # 转换数据格式
            ohlcv_objects = []
            last_timestamp = None

            for candle in ohlcv_data:
                timestamp = datetime.fromtimestamp(candle[0] / 1000)  # CCXT返回毫秒时间戳
                ohlcv_obj = OHLCVData(
                    timestamp=timestamp,
                    exchange="binance",  # 应该根据实际交易所设置
                    symbol=symbol,
                    timeframe=timeframe,
                    open=float(candle[1]),
                    high=float(candle[2]),
                    low=float(candle[3]),
                    close=float(candle[4]),
                    volume=float(candle[5]),
                    quote_volume=float(candle[6]) if len(candle) > 6 else None,
                    trades_count=int(candle[7]) if len(candle) > 7 else None
                )

                # 数据质量验证
                ohlcv_obj.quality = await self._validate_ohlcv(ohlcv_obj)
                ohlcv_objects.append(ohlcv_obj)
                last_timestamp = timestamp

            # 更新最后时间戳
            if last_timestamp:
                self.last_timestamps[(symbol, timeframe)] = int(last_timestamp.timestamp() * 1000)

            return ohlcv_objects

        except Exception as e:
            self.logger.error(f"收集 {symbol} {timeframe} OHLCV数据失败: {e}")
            raise

    async def _validate_ohlcv(self, ohlcv: OHLCVData) -> DataQuality:
        """验证OHLCV数据质量"""
        try:
            # 基本数据验证
            if ohlcv.open <= 0 or ohlcv.high <= 0 or ohlcv.low <= 0 or ohlcv.close <= 0:
                return DataQuality.INVALID

            if ohlcv.volume < 0:
                return DataQuality.INVALID

            # 价格逻辑验证
            if not (ohlcv.low <= ohlcv.open <= ohlcv.high and
                    ohlcv.low <= ohlcv.close <= ohlcv.high):
                return DataQuality.POOR

            # 价格波动验证
            price_change = abs(ohlcv.close - ohlcv.open) / ohlcv.open
            if price_change > 0.5:  # 50%以上的波动可能异常
                return DataQuality.FAIR

            # 成交量验证
            if ohlcv.volume == 0:
                return DataQuality.FAIR

            return DataQuality.GOOD

        except Exception as e:
            self.logger.error(f"OHLCV数据验证失败: {e}")
            return DataQuality.INVALID

    async def _process_ohlcv_data(self, ohlcv_data: List[OHLCVData]):
        """处理OHLCV数据"""
        try:
            # 过滤无效数据
            valid_data = [data for data in ohlcv_data if data.quality != DataQuality.INVALID]

            if not valid_data:
                return

            # 存储到数据库
            await self.data_collector.timescaledb.store_ohlcv(valid_data)

            # 缓存到Redis
            for data in valid_data:
                cache_key = f"ohlcv:{data.exchange}:{data.symbol}:{data.timeframe}"
                await self.data_collector.redis.set_json(cache_key, asdict(data), ttl=300)  # 5分钟缓存

            # 记录指标
            metrics.record_data_collection(
                exchange="binance",
                data_type="ohlcv",
                status="success"
            )

            self.logger.debug(f"成功处理 {len(valid_data)} 条OHLCV数据")

        except Exception as e:
            self.logger.error(f"处理OHLCV数据失败: {e}")

class TickerCollector:
    """Ticker数据收集器"""

    def __init__(self, data_collector: DataCollector):
        self.data_collector = data_collector
        self.logger = get_logger("ticker_collector")
        self.config = config.get('collector.market_data', {})
        self.symbols = self.config.get('symbols', ['BTC/USDT'])
        self.interval = self.config.get('ticker_interval', 5)  # 5秒收集一次

    async def initialize(self):
        """初始化Ticker收集器"""
        self.logger.info(f"Ticker收集器初始化，支持交易对: {self.symbols}")

    async def start(self):
        """启动Ticker数据收集"""
        self.logger.info("Ticker收集器启动")

        while self.data_collector._running:
            try:
                await self._collect_ticker_data()
                await asyncio.sleep(self.interval)
            except Exception as e:
                self.logger.error(f"Ticker数据收集失败: {e}")
                await asyncio.sleep(1)

    async def _collect_ticker_data(self):
        """收集Ticker数据"""
        tasks = []

        for symbol in self.symbols:
            task = asyncio.create_task(self._collect_symbol_ticker(symbol))
            tasks.append(task)

        results = await asyncio.gather(*tasks, return_exceptions=True)

        for result in results:
            if isinstance(result, Exception):
                self.logger.error(f"Ticker收集任务失败: {result}")
            else:
                await self._process_ticker_data(result)

    async def _collect_symbol_ticker(self, symbol: str) -> TickerData:
        """收集单个交易对的Ticker数据"""
        try:
            ticker = await exchange_manager.execute_request('fetch_ticker', symbol=symbol)

            ticker_obj = TickerData(
                timestamp=datetime.fromtimestamp(ticker['timestamp'] / 1000 if ticker.get('timestamp') else time.time()),
                exchange="binance",
                symbol=symbol,
                last_price=float(ticker['last']),
                bid_price=float(ticker['bid']) if ticker.get('bid') else None,
                ask_price=float(ticker['ask']) if ticker.get('ask') else None,
                bid_volume=float(ticker['bidVolume']) if ticker.get('bidVolume') else None,
                ask_volume=float(ticker['askVolume']) if ticker.get('askVolume') else None,
                volume_24h=float(ticker['quoteVolume']) if ticker.get('quoteVolume') else None,
                quote_volume_24h=float(ticker['quoteVolume']) if ticker.get('quoteVolume') else None,
                price_change_24h=float(ticker['change']) if ticker.get('change') else None,
                price_change_percent_24h=float(ticker['percentage']) if ticker.get('percentage') else None
            )

            ticker_obj.quality = await self._validate_ticker(ticker_obj)
            return ticker_obj

        except Exception as e:
            self.logger.error(f"收集 {symbol} Ticker数据失败: {e}")
            raise

    async def _validate_ticker(self, ticker: TickerData) -> DataQuality:
        """验证Ticker数据质量"""
        try:
            if ticker.last_price <= 0:
                return DataQuality.INVALID

            if ticker.bid_price and ticker.ask_price:
                if ticker.bid_price >= ticker.ask_price:
                    return DataQuality.POOR

                spread = (ticker.ask_price - ticker.bid_price) / ticker.last_price
                if spread > 0.01:  # 1%以上的价差可能异常
                    return DataQuality.FAIR

            return DataQuality.GOOD

        except Exception as e:
            self.logger.error(f"Ticker数据验证失败: {e}")
            return DataQuality.INVALID

    async def _process_ticker_data(self, ticker_data: TickerData):
        """处理Ticker数据"""
        try:
            if ticker_data.quality == DataQuality.INVALID:
                return

            # 存储到数据库
            await self.data_collector.timescaledb.store_ticker(ticker_data)

            # 缓存到Redis
            cache_key = f"ticker:{ticker_data.exchange}:{ticker_data.symbol}"
            await self.data_collector.redis.set_json(cache_key, asdict(ticker_data), ttl=60)  # 1分钟缓存

            # 记录指标
            metrics.record_data_collection(
                exchange="binance",
                data_type="ticker",
                status="success"
            )

        except Exception as e:
            self.logger.error(f"处理Ticker数据失败: {e}")

class DataScheduler:
    """数据调度器"""

    def __init__(self, data_collector: DataCollector):
        self.data_collector = data_collector
        self.logger = get_logger("data_scheduler")
        self.schedules = {}
        self._running = False

    async def initialize(self):
        """初始化调度器"""
        self.logger.info("数据调度器初始化")

    async def start(self):
        """启动调度器"""
        self._running = True
        self.logger.info("数据调度器启动")

        while self._running:
            try:
                await self._execute_scheduled_tasks()
                await asyncio.sleep(1)  # 每秒检查一次
            except Exception as e:
                self.logger.error(f"调度器执行失败: {e}")
                await asyncio.sleep(5)

    async def stop(self):
        """停止调度器"""
        self._running = False
        self.logger.info("数据调度器已停止")

    async def _execute_scheduled_tasks(self):
        """执行计划任务"""
        current_time = datetime.now()

        # 检查是否有需要执行的任务
        # 这里可以实现更复杂的调度逻辑
        pass

class DataQualityMonitor:
    """数据质量监控器"""

    def __init__(self, data_collector: DataCollector):
        self.data_collector = data_collector
        self.logger = get_logger("data_quality_monitor")
        self.quality_stats = {}
        self._running = False

    async def initialize(self):
        """初始化质量监控"""
        self.logger.info("数据质量监控初始化")

    async def start(self):
        """启动质量监控"""
        self._running = True
        self.logger.info("数据质量监控启动")

        while self._running:
            try:
                await self._check_data_quality()
                await asyncio.sleep(60)  # 每分钟检查一次
            except Exception as e:
                self.logger.error(f"数据质量检查失败: {e}")
                await asyncio.sleep(30)

    async def stop(self):
        """停止质量监控"""
        self._running = False
        self.logger.info("数据质量监控已停止")

    async def _check_data_quality(self):
        """检查数据质量"""
        try:
            # 检查最近的数据质量
            # 实现数据质量统计和告警逻辑
            pass
        except Exception as e:
            self.logger.error(f"数据质量检查失败: {e}")

# 全局数据收集器实例
data_collector = DataCollector()
```

## 接受标准

### 必须满足的条件
- [ ] 实现完整的市场数据收集功能
- [ ] 支持OHLCV、ticker、orderbook、trades四种数据类型
- [ ] 支持多个时间框架（1m, 5m, 15m, 1h, 4h, 1d）
- [ ] 实现增量数据获取机制
- [ ] 包含数据质量验证和监控
- [ ] 支持智能调度和负载均衡
- [ ] 实现数据缓存和持久化
- [ ] 提供完整的监控指标
- [ ] 通过性能测试和数据完整性验证

### 性能要求
- **数据延迟**: 实时数据延迟 < 1秒，历史数据延迟 < 5秒
- **吞吐量**: 支持每秒1000+数据点处理
- **准确性**: 数据准确性 > 99.9%
- **可用性**: 系统可用性 > 99.9%
- **存储效率**: 数据压缩率 > 70%

### 技术规范
- 使用异步编程模型
- 实现增量数据同步
- 支持配置热更新
- 完整的错误处理和恢复机制
- 可扩展的收集器架构

## 实现步骤

### 第一阶段：基础架构 (2天)
1. 设计数据收集器架构
2. 实现基础数据结构
3. 创建收集器基类
4. 实现存储层抽象

### 第二阶段：OHLCV收集器 (2天)
1. 实现OHLCV数据收集
2. 添加多时间框架支持
3. 实现增量获取机制
4. 添加数据质量验证

### 第三阶段：其他数据收集器 (2天)
1. 实现Ticker数据收集器
2. 实现OrderBook数据收集器
3. 实现Trades数据收集器
4. 统一数据处理流程

### 第四阶段：调度和质量监控 (2天)
1. 实现智能调度器
2. 开发数据质量监控
3. 添加监控指标收集
4. 性能优化和测试

### 第五阶段：测试和部署 (1天)
1. 进行全面的功能测试
2. 性能测试和压力测试
3. 数据完整性验证
4. 部署配置和文档

## 交付物

### 文档
- 数据收集器设计文档
- API接口文档
- 数据格式规范
- 部署和运维指南

### 代码
- 完整的数据收集器实现
- 数据质量验证器
- 调度器和监控器
- 单元测试和集成测试

### 配置
- 数据收集配置模板
- 质量监控配置
- 存储配置
- 监控配置

## 风险和依赖

### 技术风险
- 高并发数据处理的性能问题
- 数据一致性和完整性保证
- 多交易所数据格式差异

### 依赖关系
- 依赖于Exchange Manager的稳定性
- 依赖于数据库和缓存的性能
- 依赖于网络环境的稳定性

### 缓解措施
- 实现数据缓冲和批处理
- 添加数据校验和修复机制
- 实现适配器模式处理数据差异

## 验收标准
- 所有数据类型正确收集
- 数据延迟满足要求
- 数据质量监控有效
- 系统性能达标
- 监控指标完整准确
- 通过所有测试用例