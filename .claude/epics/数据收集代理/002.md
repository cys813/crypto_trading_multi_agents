---
name: 数据库设计和存储架构实现
type: task
epic: 数据收集代理
status: open
priority: 1
created: 2025-09-25T20:20:35Z
estimated: 8 days
assigned: [待分配]
parallelizable: true
dependencies: []
---

# 任务: 数据库设计和存储架构实现

## 任务描述
设计和实现TimescaleDB、PostgreSQL、Redis的多数据库架构，包括数据表结构设计、分区策略、索引优化、缓存策略，为数据收集代理提供高性能、高可靠性的数据存储解决方案。

## 技术要求

### 数据库架构设计

#### TimescaleDB (时序数据存储)
- **用途**: 存储市场时序数据（OHLCV、ticker、orderbook、trades）
- **版本**: TimescaleDB 2.0+ (基于PostgreSQL 12+)
- **特性**: 自动分区、数据压缩、连续聚合、时序优化

#### PostgreSQL (业务数据存储)
- **用途**: 存储业务数据（仓位、订单、配置、元数据）
- **版本**: PostgreSQL 12+
- **特性**: 事务支持、关系查询、数据完整性

#### Redis (缓存和会话管理)
- **用途**: 实时数据缓存、会话管理、消息队列
- **版本**: Redis 6.0+
- **特性**: 内存存储、高性能、多种数据结构

### 数据表结构设计

#### TimescaleDB 表结构

```sql
-- OHLCV数据表
CREATE TABLE market_data_ohlcv (
    time TIMESTAMP NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    timeframe VARCHAR(10) NOT NULL,
    open DECIMAL(20, 8) NOT NULL,
    high DECIMAL(20, 8) NOT NULL,
    low DECIMAL(20, 8) NOT NULL,
    close DECIMAL(20, 8) NOT NULL,
    volume DECIMAL(20, 8) NOT NULL,
    quote_volume DECIMAL(20, 8),
    trades_count INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建超表并按时间分区
SELECT create_hypertable('market_data_ohlcv', 'time');
SELECT add_dimension('market_data_ohlcv', 'symbol', number_partitions => 10);

-- Ticker数据表
CREATE TABLE market_data_ticker (
    time TIMESTAMP NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    last_price DECIMAL(20, 8) NOT NULL,
    bid_price DECIMAL(20, 8),
    ask_price DECIMAL(20, 8),
    bid_volume DECIMAL(20, 8),
    ask_volume DECIMAL(20, 8),
    volume_24h DECIMAL(20, 8),
    quote_volume_24h DECIMAL(20, 8),
    price_change_24h DECIMAL(20, 8),
    price_change_percent_24h DECIMAL(20, 8),
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

SELECT create_hypertable('market_data_ticker', 'time');

-- Orderbook数据表
CREATE TABLE market_data_orderbook (
    time TIMESTAMP NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    bids JSONB NOT NULL,
    asks JSONB NOT NULL,
    timestamp_ms BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

SELECT create_hypertable('market_data_orderbook', 'time');

-- 交易数据表
CREATE TABLE market_data_trades (
    time TIMESTAMP NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    trade_id VARCHAR(100) NOT NULL,
    price DECIMAL(20, 8) NOT NULL,
    amount DECIMAL(20, 8) NOT NULL,
    side VARCHAR(10) NOT NULL,
    type VARCHAR(20),
    taker_or_maker VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

SELECT create_hypertable('market_data_trades', 'time');
```

#### PostgreSQL 表结构

```sql
-- 当前仓位表
CREATE TABLE current_positions (
    id SERIAL PRIMARY KEY,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(10) NOT NULL,
    amount DECIMAL(20, 8) NOT NULL,
    entry_price DECIMAL(20, 8) NOT NULL,
    mark_price DECIMAL(20, 8),
    unrealized_pnl DECIMAL(20, 8),
    realized_pnl DECIMAL(20, 8) DEFAULT 0,
    leverage DECIMAL(10, 2),
    margin_type VARCHAR(20),
    liquidation_price DECIMAL(20, 8),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(exchange, symbol, side)
);

-- 仓位历史表
CREATE TABLE position_history (
    id SERIAL PRIMARY KEY,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(10) NOT NULL,
    amount DECIMAL(20, 8) NOT NULL,
    entry_price DECIMAL(20, 8) NOT NULL,
    exit_price DECIMAL(20, 8),
    realized_pnl DECIMAL(20, 8),
    fees DECIMAL(20, 8),
    duration INTERVAL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    closed_at TIMESTAMP
);

-- 订单表
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    exchange_order_id VARCHAR(100) NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    type VARCHAR(20) NOT NULL,
    side VARCHAR(10) NOT NULL,
    amount DECIMAL(20, 8) NOT NULL,
    price DECIMAL(20, 8),
    status VARCHAR(20) NOT NULL,
    filled_amount DECIMAL(20, 8) DEFAULT 0,
    remaining_amount DECIMAL(20, 8),
    avg_fill_price DECIMAL(20, 8),
    fee DECIMAL(20, 8),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(exchange, exchange_order_id)
);

-- 系统配置表
CREATE TABLE system_config (
    id SERIAL PRIMARY KEY,
    config_key VARCHAR(100) UNIQUE NOT NULL,
    config_value TEXT NOT NULL,
    config_type VARCHAR(20) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 交易所配置表
CREATE TABLE exchange_config (
    id SERIAL PRIMARY KEY,
    exchange_name VARCHAR(50) UNIQUE NOT NULL,
    api_key TEXT,
    api_secret TEXT ENCRYPTED,
    passphrase TEXT ENCRYPTED,
    sandbox BOOLEAN DEFAULT FALSE,
    rate_limit INTEGER DEFAULT 100,
    enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 分区策略和索引优化

#### TimescaleDB 分区策略
- **时间分区**: 按天自动分区，保留7天热数据，30天温数据，1年冷数据
- **交易对分区**: 对高频交易对进行额外分区
- **压缩策略**: 对30天以上的历史数据自动压缩

#### 索引优化
```sql
-- TimescaleDB索引
CREATE INDEX idx_ohlcv_exchange_symbol_time ON market_data_ohlcv (exchange, symbol, time DESC);
CREATE INDEX idx_ticker_exchange_symbol_time ON market_data_ticker (exchange, symbol, time DESC);
CREATE INDEX idx_trades_exchange_symbol_time ON market_data_trades (exchange, symbol, time DESC);

-- PostgreSQL索引
CREATE INDEX idx_positions_exchange_symbol ON current_positions (exchange, symbol);
CREATE INDEX idx_orders_exchange_status ON orders (exchange, status);
CREATE INDEX idx_orders_created_at ON orders (created_at DESC);
CREATE INDEX idx_position_history_symbol_time ON position_history (symbol, created_at DESC);
```

### 缓存策略

#### Redis 缓存设计
```python
# 缓存键命名规范
{
    # 实时数据缓存 (TTL: 1分钟)
    "market_data:ticker:{exchange}:{symbol}",
    "market_data:orderbook:{exchange}:{symbol}",

    # 仓位信息缓存 (TTL: 5秒)
    "positions:{exchange}:{symbol}",
    "positions:summary:{exchange}",

    # 订单状态缓存 (TTL: 10秒)
    "orders:active:{exchange}",
    "orders:status:{exchange}:{order_id}",

    # 系统配置缓存 (TTL: 1小时)
    "config:system:{key}",
    "config:exchange:{exchange}",

    # 速率限制缓存 (TTL: 1分钟)
    "rate_limit:{exchange}:{endpoint}",

    # 会话管理 (TTL: 24小时)
    "session:{user_id}",
    "session:token:{token}"
}
```

#### 缓存策略
- **写策略**: 先写数据库，再更新缓存
- **读策略**: 先读缓存，缓存未命中再查数据库
- **失效策略**: 基于TTL的自动失效 + 主动失效
- **预热策略**: 系统启动时预加载热点数据

## 接受标准

### 必须满足的条件
- [ ] 完成完整的数据库schema设计文档
- [ ] 实现所有数据库表的创建和初始化脚本
- [ ] 配置TimescaleDB的超表和分区策略
- [ ] 实现所有必要的索引和性能优化
- [ ] 建立Redis缓存策略和数据结构设计
- [ ] 实现数据库连接池和连接管理
- [ ] 完成数据迁移脚本和版本管理
- [ ] 实现数据库监控和性能指标收集
- [ ] 通过数据库性能测试和压力测试

### 性能要求
- **写入性能**: 时序数据写入延迟 < 50ms
- **查询性能**: 常用查询响应时间 < 100ms
- **缓存命中率**: 热点数据缓存命中率 > 95%
- **并发处理**: 支持1000+并发数据库连接
- **数据完整性**: 99.99%的数据完整性保证

### 技术规范
- 使用SQLAlchemy ORM进行数据库操作
- 实现数据库连接池和连接管理
- 支持数据库事务和回滚机制
- 实现数据备份和恢复策略
- 支持数据库版本管理和迁移

## 实现步骤

### 第一阶段：数据库设计 (2天)
1. 分析数据需求和使用场景
2. 设计数据库schema和表结构
3. 制定分区策略和索引方案
4. 设计Redis缓存架构

### 第二阶段：数据库实现 (3天)
1. 创建数据库初始化脚本
2. 实现TimescaleDB超表和分区配置
3. 创建所有必要的索引和约束
4. 实现数据库连接池和管理

### 第三阶段：缓存实现 (2天)
1. 实现Redis缓存层
2. 设计缓存策略和失效机制
3. 实现缓存预热和更新机制
4. 集成缓存到数据访问层

### 第四阶段：测试和优化 (1天)
1. 进行数据库性能测试
2. 优化查询性能和索引策略
3. 实现数据库监控和告警
4. 完善文档和部署脚本

## 交付物

### 文档
- 数据库设计文档（包含ER图、表结构说明）
- 分区策略和性能优化文档
- 缓存策略设计文档
- 数据库运维和备份指南

### 代码和脚本
- 数据库初始化脚本（SQL）
- 数据迁移脚本（Alembic）
- 数据库操作封装类
- Redis缓存实现代码
- 数据库监控和性能指标收集代码

### 配置
- 数据库连接配置
- 缓存配置文件
- 监控和告警配置
- 备份和恢复配置

## 风险和依赖

### 技术风险
- 数据库性能可能无法满足高并发需求
- 数据一致性问题可能在分布式环境中出现
- 缓存策略可能导致数据不一致

### 依赖关系
- 依赖于数据库服务器的硬件资源
- 依赖于网络环境的稳定性和带宽
- 依赖于TimescaleDB和Redis的版本兼容性

### 缓解措施
- 实施完善的数据库监控和性能调优
- 建立数据一致性和完整性检查机制
- 实现缓存失效和数据同步机制

## 验收标准
- 数据库schema设计合理，满足业务需求
- 时序数据存储性能达标，支持高并发写入
- 缓存策略有效，提高数据访问性能
- 数据一致性和完整性得到保证
- 监控和告警系统完善，能够及时发现和解决问题